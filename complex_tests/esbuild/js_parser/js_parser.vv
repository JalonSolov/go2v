module js_parser

import math
import regexp
import sort
import unicode.utf8
import ast // local module
import compat // local module
import config // local module
import helpers // local module
import js_ast // local module
import js_lexer // local module
import logger // local module
import renamer // local module
import runtime // local module
// This parser does two passes:
// 1. Parse the source into an AST, create the scope tree, and declare symbols.
//  2. Visit each node in the AST, bind identifiers to declared symbols, do
//     constant folding, substitute compile-time variable definitions, and
//     lower certain syntactic constructs as appropriate given the language
//     target.
// So many things have been put in so few passes because we want to minimize
// the number of full-tree passes to improve performance. However, we need
// to have at least two separate passes to handle variable hoisting. See the
// comment about scopesInOrder below for more information.

struct parser {
pub mut:
	options                     Options
	log                         logger.Log
	source                      logger.Source
	tracker                     logger.LineColumnTracker
	fn_or_arrow_data_parse      fnOrArrowDataParse
	fn_only_data_visit          fnOnlyDataVisit
	allocated_names             []string
	current_scope               &js_ast.Scope = unsafe { nil }
	scopes_for_current_part     []&js_ast.Scope
	symbols                     []ast.Symbol
	ast_helpers                 js_ast.HelperContext
	ts_use_counts               []u32
	injected_define_symbols     []ast.Ref
	injected_symbol_sources     map[ast.Ref]InjectedSymbolSource
	injected_dot_names          map[string][]injectedDotName
	drop_labels_map             map[string]string
	expr_comments               map[logger.Loc][]string
	mangled_props               map[string]ast.Ref
	reserved_props              map[string]Bool
	symbol_uses                 map[ast.Ref]js_ast.SymbolUse
	import_symbol_property_uses map[ast.Ref]map[string]js_ast.SymbolUse
	symbol_call_uses            map[ast.Ref]js_ast.SymbolCallUse
	declared_symbols            []js_ast.DeclaredSymbol
	glob_pattern_imports        []globPatternImport
	runtime_imports             map[string]ast.LocRef
	duplicate_case_checker      duplicateCaseChecker
	unrepresentable_identifiers map[string]Bool
	legacy_octal_literals       map[js_ast.E]logger.Range
	scopes_in_order_for_enum    map[logger.Loc][]scopeOrder
	binary_expr_stack           []binaryExprVisitor
	// For strict mode handling
	hoisted_ref_for_sloppy_mode_block_fn map[ast.Ref]ast.Ref
	// For lowering private methods
	private_getters map[ast.Ref]ast.Ref
	private_setters map[ast.Ref]ast.Ref
	// These are for TypeScript
	//
	// We build up enough information about the TypeScript namespace hierarchy to
	// be able to resolve scope lookups and property accesses for TypeScript enum
	// and namespace features. Each JavaScript scope object inside a namespace
	// has a reference to a map of exported namespace members from sibling scopes.
	//
	// In addition, there is a map from each relevant symbol reference to the data
	// associated with that namespace or namespace member: "refToTSNamespaceMemberData".
	// This gives enough info to be able to resolve queries into the namespace.
	//
	// When visiting expressions, namespace metadata is associated with the most
	// recently visited node. If namespace metadata is present, "tsNamespaceTarget"
	// will be set to the most recently visited node (as a way to mark that this
	// node has metadata) and "tsNamespaceMemberData" will be set to the metadata.
	ref_to_tsn_amespace_member_data map[ast.Ref]js_ast.TSNamespaceMemberData
	ts_namespace_target             js_ast.E
	ts_namespace_member_data        js_ast.TSNamespaceMemberData
	emitted_namespace_vars          map[ast.Ref]Bool
	is_exported_inside_namespace    map[ast.Ref]ast.Ref
	local_type_names                map[string]Bool
	ts_enums                        map[ast.Ref]map[string]js_ast.TSEnumValue
	const_values                    map[ast.Ref]js_ast.ConstValue
	prop_derived_ctor_value         js_ast.E
	prop_method_decorator_scope     &js_ast.Scope = unsafe { nil }
	// This is the reference to the generated function argument for the namespace,
	// which is different than the reference to the namespace itself:
	//
	//   namespace ns {
	//   }
	//
	// The code above is transformed into something like this:
	//
	//   var ns1;
	//   (function(ns2) {
	//   })(ns1 || (ns1 = {}));
	//
	// This variable is "ns2" not "ns1". It is only used during the second
	// "visit" pass.
	enclosing_namespace_arg_ref &ast.Ref = unsafe { nil }
	// Imports (both ES6 and CommonJS) are tracked at the top level
	import_records                  []ast.ImportRecord
	import_records_for_current_part []u32
	export_star_import_records      []u32
	// These are for handling ES6 imports and exports
	import_items_for_namespace map[ast.Ref]NamespaceImportItems
	is_import_item             map[ast.Ref]Bool
	named_imports              map[ast.Ref]js_ast.NamedImport
	named_exports              map[string]js_ast.NamedExport
	top_level_symbol_to_parts  map[ast.Ref][]u32
	import_namespace_ccm_ap    map[ImportNamespaceCall]Bool
	// The parser does two passes and we need to pass the scope tree information
	// from the first pass to the second pass. That's done by tracking the calls
	// to pushScopeForParsePass() and popScope() during the first pass in
	// scopesInOrder.
	//
	// Then, when the second pass calls pushScopeForVisitPass() and popScope(),
	// we consume entries from scopesInOrder and make sure they are in the same
	// order. This way the second pass can efficiently use the same scope tree
	// as the first pass without having to attach the scope tree to the AST.
	//
	// We need to split this into two passes because the pass that declares the
	// symbols must be separate from the pass that binds identifiers to declared
	// symbols to handle declaring a hoisted "var" symbol in a nested scope and
	// binding a name to it in a parent or sibling scope.
	scopes_in_order []scopeOrder
	// These propagate the name from the parent context into an anonymous child
	// expression. For example:
	//
	//   let foo = function() {}
	//   assert.strictEqual(foo.name, 'foo')
	//
	name_to_keep        string
	name_to_keep_is_for js_ast.E
	// These properties are for the visit pass, which runs after the parse pass.
	// The visit pass binds identifiers to declared symbols, does constant
	// folding, substitutes compile-time variable definitions, and lowers certain
	// syntactic constructs as appropriate.
	stmt_expr_value                          js_ast.E
	call_target                              js_ast.E
	dot_or_index_target                      js_ast.E
	template_tag                             js_ast.E
	delete_target                            js_ast.E
	loop_body                                js_ast.S
	suspicious_logical_operator_inside_arrow js_ast.E
	module_scope                             &js_ast.Scope = unsafe { nil }
	// This is internal-only data used for the implementation of Yarn PnP
	manifest_for_yarn_pn_p      js_ast.Expr
	string_locals_for_yarn_pn_p map[ast.Ref]StringLocalForYarnPnP
	// This helps recognize the "await import()" pattern. When this is present,
	// warnings about non-string import paths will be omitted inside try blocks.
	await_target js_ast.E
	// This helps recognize the "import().catch()" pattern. We also try to avoid
	// warning about this just like the "try { await import() }" pattern.
	then_catch_chain thenCatchChain
	// When bundling, hoisted top-level local variables declared with "var" in
	// nested scopes are moved up to be declared in the top-level scope instead.
	// The old "var" statements are turned into regular assignments instead. This
	// makes it easier to quickly scan the top-level statements for "var" locals
	// with the guarantee that all will be found.
	relocated_top_level_vars []ast.LocRef
	// We need to lower private names such as "#foo" if they are used in a brand
	// check such as "#foo in x" even if the private name syntax would otherwise
	// be supported. This is because private names are a newly-added feature.
	//
	// However, this parser operates in only two passes for speed. The first pass
	// parses things and declares variables, and the second pass lowers things and
	// resolves references to declared variables. So the existence of a "#foo in x"
	// expression for a specific "#foo" cannot be used to decide to lower "#foo"
	// because it's too late by that point. There may be another expression such
	// as "x.#foo" before that point and that must be lowered as well even though
	// it has already been visited.
	//
	// Instead what we do is track just the names of fields used in private brand
	// checks during the first pass. This tracks the names themselves, not symbol
	// references. Then, during the second pass when we are about to enter into
	// a class, we conservatively decide to lower all private names in that class
	// which are used in a brand check anywhere in the file.
	lower_all_of_these_private_names map[string]Bool
	// Temporary variables used for lowering
	temp_lets_to_declare           []ast.Ref
	temp_refs_to_declare           []tempRef
	top_level_temp_refs_to_declare []tempRef
	lexer                          js_lexer.Lexer
	// Private field access in a decorator lowers all private fields in that class
	parse_experimental_decorator_nesting isize
	// Temporary variables used for lowering
	temp_ref_count           isize
	top_level_temp_ref_count isize
	// We need to scan over the source contents to recover the line and column offsets
	jsx_source_loc    isize
	jsx_source_line   isize
	jsx_source_column isize
	exports_ref       ast.Ref
	require_ref       ast.Ref
	module_ref        ast.Ref
	import_meta_ref   ast.Ref
	promise_ref       ast.Ref
	reg_exp_ref       ast.Ref
	super_ctor_ref    ast.Ref
	// Imports from "react/jsx-runtime" and "react", respectively.
	// (Or whatever was specified in the "importSource" option)
	jsx_runtime_imports map[string]ast.LocRef
	jsx_legacy_imports  map[string]ast.LocRef
	// For lowering private methods
	weak_map_ref                 ast.Ref
	weak_set_ref                 ast.Ref
	esm_import_statement_keyword logger.Range
	esm_import_meta              logger.Range
	esm_export_keyword           logger.Range
	enclosing_class_keyword      logger.Range
	top_level_await_keyword      logger.Range
	live_top_level_await_keyword logger.Range
	latest_arrow_arg_loc         logger.Loc
	forbid_suffix_after_as_loc   logger.Loc
	first_jsxe_lement_loc        logger.Loc
	fn_or_arrow_data_visit       fnOrArrowDataVisit
	// ArrowFunction is a special case in the grammar. Although it appears to be
	// a PrimaryExpression, it's actually an AssignmentExpression. This means if
	// a AssignmentExpression ends up producing an ArrowFunction then nothing can
	// come after it other than the comma operator, since the comma operator is
	// the only thing above AssignmentExpression under the Expression rule:
	//
	//   AssignmentExpression:
	//     ArrowFunction
	//     ConditionalExpression
	//     LeftHandSideExpression = AssignmentExpression
	//     LeftHandSideExpression AssignmentOperator AssignmentExpression
	//
	//   Expression:
	//     AssignmentExpression
	//     Expression , AssignmentExpression
	//
	after_arrow_body_loc logger.Loc
	// Setting this to true disables warnings about code that is very likely to
	// be a bug. This is used to ignore issues inside "node_modules" directories.
	// This has caught real issues in the past. However, it's not esbuild's job
	// to find bugs in other libraries, and these warnings are problematic for
	// people using these libraries with esbuild. The only fix is to either
	// disable all esbuild warnings and not get warnings about your own code, or
	// to try to get the warning fixed in the affected library. This is
	// especially annoying if the warning is a false positive as was the case in
	// https://github.com/firebase/firebase-js-sdk/issues/3814. So these warnings
	// are now disabled for code inside "node_modules" directories.
	suppress_warnings_about_weird_code bool
	// A file is considered to be an ECMAScript module if it has any of the
	// features of one (e.g. the "export" keyword), otherwise it's considered
	// a CommonJS module.
	//
	// However, we have a single exception: a file where the only ESM feature
	// is the "import" keyword is allowed to have CommonJS exports. This feature
	// is necessary to be able to synchronously import ESM code into CommonJS,
	// which we need to enable in a few important cases. Some examples are:
	// our runtime code, injected files (the "inject" feature is ESM-only),
	// and certain automatically-generated virtual modules from plugins.
	is_file_considered_to_have_esme_xports bool
	is_file_considered_esm                 bool
	// Inside a TypeScript namespace, an "export declare" statement can be used
	// to cause a namespace to be emitted even though it has no other observable
	// effect. This flag is used to implement this feature.
	//
	// Specifically, namespaces should be generated for all of the following
	// namespaces below except for "f", which should not be generated:
	//
	//   namespace a { export declare const a }
	//   namespace b { export declare let [[b]] }
	//   namespace c { export declare function c() }
	//   namespace d { export declare class d {} }
	//   namespace e { export declare enum e {} }
	//   namespace f { export declare namespace f {} }
	//
	// The TypeScript compiler compiles this into the following code (notice "f"
	// is missing):
	//
	//   var a; (function (a_1) {})(a || (a = {}));
	//   var b; (function (b_1) {})(b || (b = {}));
	//   var c; (function (c_1) {})(c || (c = {}));
	//   var d; (function (d_1) {})(d || (d = {}));
	//   var e; (function (e_1) {})(e || (e = {}));
	//
	// Note that this should not be implemented by declaring symbols for "export
	// declare" statements because the TypeScript compiler doesn't generate any
	// code for these statements, so these statements are actually references to
	// global variables. There is one exception, which is that local variables
	// *should* be declared as symbols because they are replaced with. This seems
	// like very arbitrary behavior but it's what the TypeScript compiler does,
	// so we try to match it.
	//
	// Specifically, in the following code below "a" and "b" should be declared
	// and should be substituted with "ns.a" and "ns.b" but the other symbols
	// shouldn't. References to the other symbols actually refer to global
	// variables instead of to symbols that are exported from the namespace.
	// This is the case as of TypeScript 4.3. I assume this is a TypeScript bug:
	//
	//   namespace ns {
	//     export declare const a
	//     export declare let [[b]]
	//     export declare function c()
	//     export declare class d { }
	//     export declare enum e { }
	//     console.log(a, b, c, d, e)
	//   }
	//
	// The TypeScript compiler compiles this into the following code:
	//
	//   var ns;
	//   (function (ns) {
	//       console.log(ns.a, ns.b, c, d, e);
	//   })(ns || (ns = {}));
	//
	// Relevant issue: https://github.com/evanw/esbuild/issues/1158
	has_non_local_export_declare_inside_namespace bool
	// When this flag is enabled, we attempt to fold all expressions that
	// TypeScript would consider to be "constant expressions". This flag is
	// enabled inside each enum body block since TypeScript requires numeric
	// constant folding in enum definitions.
	//
	// We also enable this flag in certain cases in JavaScript files such as when
	// parsing "const" declarations at the top of a non-ESM file, but we still
	// reuse TypeScript's notion of "constant expressions" for our own convenience.
	//
	// As of TypeScript 5.0, a "constant expression" is defined as follows:
	//
	//   An expression is considered a constant expression if it is
	//
	//   * a number or string literal,
	//   * a unary +, -, or ~ applied to a numeric constant expression,
	//   * a binary +, -, *, /, %, **, <<, >>, >>>, |, &, ^ applied to two numeric constant expressions,
	//   * a binary + applied to two constant expressions whereof at least one is a string,
	//   * a template expression where each substitution expression is a constant expression,
	//   * a parenthesized constant expression,
	//   * a dotted name (e.g. x.y.z) that references a const variable with a constant expression initializer and no type annotation,
	//   * a dotted name that references an enum member with an enum literal type, or
	//   * a dotted name indexed by a string literal (e.g. x.y["z"]) that references an enum member with an enum literal type.
	//
	// More detail: https://github.com/microsoft/TypeScript/pull/50528. Note that
	// we don't implement certain items in this list. For example, we don't do all
	// number-to-string conversions since ours might differ from how JavaScript
	// would do it, which would be a correctness issue.
	should_fold_type_script_constant_expressions bool
	allow_in                                     bool
	allow_private_identifiers                    bool
	has_top_level_return                         bool
	latest_return_had_semicolon                  bool
	message_about_this_is_undefined              bool
	is_control_flow_dead                         bool
	// If this is true, then all top-level statements are wrapped in a try/catch
	will_wrap_module_in_try_catch_for_using bool
}

struct globPatternImport {
pub mut:
	assert_or_with    &ast.ImportAssertOrWith = unsafe { nil }
	parts             []helpers.GlobPart
	name              string
	approximate_range logger.Range
	ref               ast.Ref
	kind              ast.ImportKind
}

struct namespaceImportItems {
pub mut:
	entries             map[string]ast.LocRef
	import_record_index u32
}

struct stringLocalForYarnPnP {
pub mut:
	value []u16
	loc   logger.Loc
}

struct injectedSymbolSource {
pub mut:
	source logger.Source
	loc    logger.Loc
}

struct injectedDotName {
pub mut:
	parts                 []string
	injected_define_index u32
}

type importNamespaceCallKind = u8

enum importNamespaceCallKind {
	expr_kind_call
	expr_kind_new
	expr_kind_jsxt_ag
}

struct importNamespaceCall {
pub mut:
	ref  ast.Ref
	kind importNamespaceCallKind
}

struct thenCatchChain {
pub mut:
	next_target       js_ast.E
	catch_loc         logger.Loc
	has_multiple_args bool
	has_catch         bool
}

// This is used as part of an incremental build cache key. Some of these values
// can potentially change between builds if they are derived from nearby
// "package.json" or "tsconfig.json" files that were changed since the last
// build.
struct Options {
pub mut:
	injected_files   []config.InjectedFile
	jsx              config.JSXOptions
	ts_always_strict &config.TSAlwaysStrict = unsafe { nil }
	mangle_props     &regexp.Regexp         = unsafe { nil }
	reserve_props    &regexp.Regexp         = unsafe { nil }
	drop_labels      []string
	// This pointer will always be different for each build but the contents
	// shouldn't ever behave different semantically. We ignore this field for the
	// equality comparison.
	defines &config.ProcessedDefines = unsafe { nil }
	// This is an embedded struct. Always access these directly instead of off
	// the name "optionsThatSupportStructuralEquality". This is only grouped like
	// this to make the equality comparison easier and safer (and hopefully faster).
}

struct optionsThatSupportStructuralEquality {
pub mut:
	original_target_env                   string
	module_type_data                      js_ast.ModuleTypeData
	unsupported_jsf_eatures               compat.JSFeature
	unsupported_jsf_eature_overrides      compat.JSFeature
	unsupported_jsf_eature_overrides_mask compat.JSFeature
	// Byte-sized values go here (gathered together here to keep this object compact)
	ts                         config.TSOptions
	mode                       config.Mode
	platform                   config.Platform
	output_format              config.Format
	ascii_only                 bool
	keep_names                 bool
	minify_syntax              bool
	minify_identifiers         bool
	minify_whitespace          bool
	omit_runtime_for_tests     bool
	omit_jsxr_untime_for_tests bool
	ignore_dcea_nnotations     bool
	tree_shaking               bool
	drop_debugger              bool
	mangle_quoted              bool
	// This is an internal-only option used for the implementation of Yarn PnP
	decode_hydrate_runtime_state_yarn_pn_p bool
}

pub fn options_for_yarn_pn_p() Options {
	return Options{
		options_that_support_structural_equality: OptionsThatSupportStructuralEquality{
			decode_hydrate_runtime_state_yarn_pn_p: true
		}
	}
}

pub fn options_from_config(options &config.Options) Options {
	return Options{
		injected_files:                           options.injected_files
		jsx:                                      options.jsx
		defines:                                  options.defines
		ts_always_strict:                         options.tsa_lways_strict
		mangle_props:                             options.mangle_props
		reserve_props:                            options.reserve_props
		drop_labels:                              options.drop_labels
		options_that_support_structural_equality: OptionsThatSupportStructuralEquality{
			unsupported_jsf_eatures:               options.unsupported_jsf_eatures
			unsupported_jsf_eature_overrides:      options.unsupported_jsf_eature_overrides
			unsupported_jsf_eature_overrides_mask: options.unsupported_jsf_eature_overrides_mask
			original_target_env:                   options.original_target_env
			ts:                                    options.ts
			mode:                                  options.mode
			platform:                              options.platform
			output_format:                         options.output_format
			module_type_data:                      options.module_type_data
			ascii_only:                            options.asciio_nly
			keep_names:                            options.keep_names
			minify_syntax:                         options.minify_syntax
			minify_identifiers:                    options.minify_identifiers
			minify_whitespace:                     options.minify_whitespace
			omit_runtime_for_tests:                options.omit_runtime_for_tests
			omit_jsxr_untime_for_tests:            options.omit_jsxr_untime_for_tests
			ignore_dcea_nnotations:                options.ignore_dcea_nnotations
			tree_shaking:                          options.tree_shaking
			drop_debugger:                         options.drop_debugger
			mangle_quoted:                         options.mangle_quoted
		}
	}
}

pub fn (a &Options) equal(b &Options) bool {
	if a.options_that_support_structural_equality != b.options_that_support_structural_equality {
		return false
	}
	if a.ts_always_strict == nil && b.ts_always_strict != nil
		|| a.ts_always_strict != nil && b.ts_always_strict == nil
		|| a.ts_always_strict != nil && b.ts_always_strict != nil
		&& &a.ts_always_strict != &b.ts_always_strict {
		return false
	}
	if !is_same_regexp(a.mangle_props, b.mangle_props)
		|| !is_same_regexp(a.reserve_props, b.reserve_props) {
		return false
	}
	if !helpers.string_arrays_equal(a.drop_labels, b.drop_labels) {
		return false
	}
	if a.injected_files.len != b.injected_files.len {
		return false
	}
	for i, x in a.injected_files {
		mut y := b.injected_files[i]
		if x.source != y.source || x.define_name != y.define_name || x.exports.len != y.exports.len {
			return false
		}
		for j, _ in x.exports {
			if x.exports[j] != y.exports[j] {
				return false
			}
		}
	}
	if a.jsx.parse != b.jsx.parse || !jsx_exprs_equal(a.jsx.factory, b.jsx.factory)
		|| !jsx_exprs_equal(a.jsx.fragment, b.jsx.fragment) {
		return false
	}
	if (a.defines != nil || b.defines != nil) && (a.defines == nil || b.defines == nil
		|| a.defines.identifier_defines.len != b.defines.identifier_defines.len
		|| a.defines.dot_defines.len != b.defines.dot_defines.len) {
		panic('Internal error')
	}
	return true
}

fn is_same_regexp(a &regexp.Regexp, b &regexp.Regexp) bool {
	if a == nil {
		return b == nil
	} else {
		return b != nil && a.string() == b.string()
	}
}

fn jsx_exprs_equal(a config.DefineExpr, b config.DefineExpr) bool {
	if !helpers.string_arrays_equal(a.parts, b.parts) {
		return false
	}
	if a.constant != nil {
		if b.constant == nil || !js_ast.values_look_the_same(a.constant, b.constant) {
			return false
		}
	} else if b.constant != nil {
		return false
	}
	return true
}

struct tempRef {
pub mut:
	value_or_nil js_ast.Expr
	ref          ast.Ref
}

const loc_module_scope = -1

struct scopeOrder {
pub mut:
	scope &js_ast.Scope = unsafe { nil }
	loc   logger.Loc
}

type awaitOrYield = u8

enum awaitOrYield {
	allow_ident
	allow_expr
	forbid_all
}

// This is function-specific information used during parsing. It is saved and
// restored on the call stack around code that parses nested functions and
// arrow expressions.
struct fnOrArrowDataParse {
pub mut:
	arrow_arg_errors       &DeferredArrowArgErrors = unsafe { nil }
	decorator_scope        &js_ast.Scope           = unsafe { nil }
	async_range            logger.Range
	needs_async_loc        logger.Loc
	await                  awaitOrYield
	yield                  awaitOrYield
	allow_super_call       bool
	allow_super_property   bool
	is_top_level           bool
	is_constructor         bool
	is_type_script_declare bool
	is_this_disallowed     bool
	is_return_disallowed   bool
	// In TypeScript, forward declarations of functions have no bodies
	allow_missing_body_for_type_script bool
}

// This is function-specific information used during visiting. It is saved and
// restored on the call stack around code that parses nested functions and
// arrow expressions.
struct fnOrArrowDataVisit {
pub mut:
	// This is used to silence unresolvable imports due to "require" calls inside
	// a try/catch statement. The assumption is that the try/catch statement is
	// there to handle the case where the reference to "require" crashes.
	try_body_count                     i32
	try_catch_loc                      logger.Loc
	is_arrow                           bool
	is_async                           bool
	is_generator                       bool
	is_inside_loop                     bool
	is_inside_switch                   bool
	is_derived_class_ctor              bool
	is_outside_fn_or_arrow             bool
	should_lower_super_property_access bool
}

// This is function-specific information used during visiting. It is saved and
// restored on the call stack around code that parses nested functions (but not
// nested arrow functions).
struct fnOnlyDataVisit {
pub mut:
	// This is a reference to the magic "arguments" variable that exists inside
	// functions in JavaScript. It will be non-nil inside functions and nil
	// otherwise.
	arguments_ref &ast.Ref = unsafe { nil }
	// Arrow functions don't capture the value of "this" and "arguments". Instead,
	// the values are inherited from the surrounding context. If arrow functions
	// are turned into regular functions due to lowering, we will need to generate
	// local variables to capture these values so they are preserved correctly.
	this_capture_ref      &ast.Ref = unsafe { nil }
	arguments_capture_ref &ast.Ref = unsafe { nil }
	// If true, we're inside a static class context where "this" expressions
	// should be replaced with the class name.
	should_replace_this_with_inner_class_name_ref bool
	// This is true if "this" is equal to the class name. It's true if we're in a
	// static class field initializer, a static class method, or a static class
	// block.
	is_in_static_class_context bool
	// This is a reference to the enclosing class name if there is one. It's used
	// to implement "this" and "super" references. A name is automatically generated
	// if one is missing so this will always be present inside a class body.
	inner_class_name_ref &ast.Ref = unsafe { nil }
	// If we're inside an async arrow function and async functions are not
	// supported, then we will have to convert that arrow function to a generator
	// function. That means references to "arguments" inside the arrow function
	// will have to reference a captured variable instead of the real variable.
	is_inside_async_arrow_fn bool
	// If false, disallow "new.target" expressions. We disallow all "new.target"
	// expressions at the top-level of the file (i.e. not inside a function or
	// a class field). Technically since CommonJS files are wrapped in a function
	// you can use "new.target" in node as an alias for "undefined" but we don't
	// support that.
	is_new_target_allowed bool
	// If false, the value for "this" is the top-level module scope "this" value.
	// That means it's "undefined" for ECMAScript modules and "exports" for
	// CommonJS modules. We track this information so that we can substitute the
	// correct value for these top-level "this" references at compile time instead
	// of passing the "this" expression through to the output and leaving the
	// interpretation up to the run-time behavior of the generated code.
	//
	// If true, the value for "this" is nested inside something (either a function
	// or a class declaration). That means the top-level module scope "this" value
	// has been shadowed and is now inaccessible.
	is_this_nested bool
	// Do not warn about "this" being undefined for code that the TypeScript
	// compiler generates that looks like this:
	//
	//   var __rest = (this && this.__rest) || function (s, e) {
	//     ...
	//   };
	//
	silence_message_about_this_being_undefined bool
}

const bloom_filter_size = 251

struct duplicateCaseValue {
pub mut:
	value js_ast.Expr
	hash  u32
}

struct duplicateCaseChecker {
pub mut:
	cases        []duplicateCaseValue
	bloom_filter []u8
}

fn (dc &DuplicateCaseChecker) reset() {
	dc.cases = dc.cases[..0]
	mut bytes := dc.bloom_filter
	for i, _ in bytes {
		bytes[i] = isize(0)
	}
}

fn (dc &DuplicateCaseChecker) check(p &Parser, expr js_ast.Expr) {
	mut hash, ok := duplicate_case_hash(expr)
	if ok {
		mut bucket := hash % bloom_filter_size
		mut entry := &dc.bloom_filter[bucket / 8]
		mut mask := u8(1) << (bucket % 8)
		if (&entry & mask) != 0 {
			for _, c in dc.cases {
				if c.hash == hash {
					mut equals, could_be_incorrect := duplicate_case_equals(c.value, expr)
					if equals {
						mut laterRange := 0
						mut earlierRange := 0
						_, ok_1 := expr.data
						if ok {
							later_range = p.source.range_of_string(expr.loc)
						} else {
							later_range = p.source.range_of_operator_before(expr.loc,
								'case')
						}
						_, ok_2 := c.value.data
						if ok {
							earlier_range = p.source.range_of_string(c.value.loc)
						} else {
							earlier_range = p.source.range_of_operator_before(c.value.loc,
								'case')
						}
						mut text := 'This case clause will never be evaluated because it duplicates an earlier case clause'
						if could_be_incorrect {
							text = 'This case clause may never be evaluated because it likely duplicates an earlier case clause'
						}
						mut kind := logger.warning
						if p.suppress_warnings_about_weird_code {
							kind = logger.debug
						}
						p.log.add_idw_ith_notes(logger.msg_id_js_duplicate_case, kind,
							&p.tracker, later_range, text, [
							p.tracker.msg_data(earlier_range, 'The earlier case clause is here:'),
						])
					}
					return
				}
			}
		}
		*entry |= mask
		dc.cases << DuplicateCaseValue{
			hash:  hash
			value: expr
		}
	}
}

fn duplicate_case_hash(expr js_ast.Expr) (u32, bool) {
	mut e := expr.data
	match e {
		js_ast.EInlinedEnum {
			return duplicate_case_hash(e.value)
		}
		js_ast.ENull {
			return 0, true
		}
		js_ast.EUndefined {
			return 1, true
		}
		js_ast.EBoolean {
			if e.value {
				return helpers.hash_combine(2, 1), true
			}
			return helpers.hash_combine(2, 0), true
		}
		js_ast.ENumber {
			mut bits := math.float64bits(e.value)
			return helpers.hash_combine(helpers.hash_combine(3, u32(bits)), u32(bits >> 32)), true
		}
		js_ast.EString {
			mut hash := u32(4)
			for _, c in e.value {
				hash = helpers.hash_combine(hash, u32(c))
			}
			return hash, true
		}
		js_ast.EBigInt {
			mut hash_1 := u32(5)
			for _, c_1 in e.value {
				hash = helpers.hash_combine(hash, u32(c))
			}
			return hash, true
		}
		js_ast.EIdentifier {
			return helpers.hash_combine(6, e.ref.inner_index), true
		}
		js_ast.EDot {
			mut target, ok := duplicate_case_hash(e.target)
			if ok {
				return helpers.hash_combine_string(helpers.hash_combine(7, target), e.name), true
			}
		}
		js_ast.EIndex {
			mut target_1, ok_1 := duplicate_case_hash(e.target)
			if ok {
				mut index, ok_2 := duplicate_case_hash(e.index)
				if ok {
					return helpers.hash_combine(helpers.hash_combine(8, target), index), true
				}
			}
		}
	}
	return 0, false
}

fn duplicate_case_equals(left js_ast.Expr, right js_ast.Expr) (bool, bool) {
	mut b, ok := right.data
	if ok {
		return duplicate_case_equals(left, b.value)
	}
	mut a := left.data
	match a {
		js_ast.EInlinedEnum {
			return duplicate_case_equals(a.value, right)
		}
		js_ast.ENull {
			_, ok_1 := right.data
			return ok, false
		}
		js_ast.EUndefined {
			_, ok_2 := right.data
			return ok, false
		}
		js_ast.EBoolean {
			mut b_1, ok_3 := right.data
			return ok && a.value == b.value, false
		}
		js_ast.ENumber {
			mut b_2, ok_4 := right.data
			return ok && a.value == b.value, false
		}
		js_ast.EString {
			mut b_3, ok_5 := right.data
			return ok && helpers.utf_16_equals_utf_16(a.value, b.value), false
		}
		js_ast.EBigInt {
			mut b_4, ok_6 := right.data
			if ok {
				mut equal, ok_7 := js_ast.check_equality_big_int(a.value, b.value)
				return ok && equal, false
			}
		}
		js_ast.EIdentifier {
			mut b_5, ok_8 := right.data
			return ok && a.ref == b.ref, false
		}
		js_ast.EDot {
			mut b_6, ok_9 := right.data
			if ok && a.optional_chain == b.optional_chain && a.name == b.name {
				mut equals, _ := duplicate_case_equals(a.target, b.target)
				return equals, true
			}
		}
		js_ast.EIndex {
			mut b_7, ok_10 := right.data
			if ok && a.optional_chain == b.optional_chain {
				mut equals_1, _ := duplicate_case_equals(a.index, b.index)
				if equals {
					mut equals_2, _ := duplicate_case_equals(a.target, b.target)
					return equals, true
				}
			}
		}
	}
	return false, false
}

type duplicatePropertiesIn = u8

enum duplicatePropertiesIn {
	duplicate_properties_in_object
	duplicate_properties_in_class
}

fn (p &Parser) warn_about_duplicate_properties(properties []js_ast.Property, in_ duplicatePropertiesIn) {
	if properties.len < 2 {
		return
	}

	mut instance_keys := map[string]ExistingKey{}
	mut static_keys := map[string]ExistingKey{}
	for _, property in properties {
		if property.kind != js_ast.property_spread {
			mut str, ok := property.key.data
			if ok {
				mut keys := map[string]ExistingKey{}
				if property.flags.has(js_ast.property_is_static) {
					keys = static_keys
				} else {
					keys = instance_keys
				}
				mut key := helpers.utf_16_to_string(str.value)
				mut prev_key := keys[key]
				mut next_key := ExistingKey{
					kind: key_normal
					loc:  property.key.loc
				}
				if property.kind == js_ast.property_getter {
					next_key.kind = key_get
				} else if property.kind == js_ast.property_setter {
					next_key.kind = key_set
				}
				if prev_key.kind != key_missing && (in_ != duplicate_properties_in_object
					|| key != '__proto__') && (
					in_ != duplicate_properties_in_class || key != 'constructor') {
					if prev_key.kind == key_get && next_key.kind == key_set
						|| prev_key.kind == key_set && next_key.kind == key_get {
						next_key.kind = key_get_and_set
					} else {
						mut id := 0
						mut what := 0
						mut where := 0
						match in_ {
							duplicate_properties_in_object {
								id = logger.msg_id_js_duplicate_object_key
								what = 'key'
								where = 'object literal'
							}
							duplicate_properties_in_class {
								id = logger.msg_id_js_duplicate_class_member
								what = 'member'
								where = 'class body'
							}
						}
						mut r := js_lexer.range_of_identifier(p.source, property.key.loc)
						p.log.add_idw_ith_notes(id, logger.warning, &p.tracker, r, strconv.v_sprintf('Duplicate %s %q in %s',
							what, key, where), [
							p.tracker.msg_data(js_lexer.range_of_identifier(p.source,
								prev_key.loc), strconv.v_sprintf('The original %s %q is here:',
								what, key)),
						])
					}
				}
				keys[key] = next_key
			}
		}
	}
}

fn is_jump_statement(data js_ast.S) bool {
	// append no rhs

	// lhs.len==0
	return false
}

fn jump_stmts_look_the_same(left js_ast.S, right js_ast.S) bool {
	mut a := left
	match a {
		js_ast.SBreak {
			mut b, ok := right
			return ok && (a.label == nil) == (b.label == nil) && (a.label == nil
				|| a.label.ref == b.label.ref)
		}
		js_ast.SContinue {
			mut b_1, ok_1 := right
			return ok && (a.label == nil) == (b.label == nil) && (a.label == nil
				|| a.label.ref == b.label.ref)
		}
		js_ast.SReturn {
			mut b_2, ok_2 := right
			return ok && (a.value_or_nil.data == nil) == (b.value_or_nil.data == nil) && (
				a.value_or_nil.data == nil
				|| js_ast.values_look_the_same(a.value_or_nil.data, b.value_or_nil.data))
		}
		js_ast.SThrow {
			mut b_3, ok_3 := right
			return ok && js_ast.values_look_the_same(a.value.data, b.value.data)
		}
	}
	return false
}

fn (p &Parser) select_local_kind(kind js_ast.LocalKind) js_ast.LocalKind {
	if p.current_scope.parent == nil && (kind == js_ast.local_let || kind == js_ast.local_const) && (
		p.options.mode == config.mode_bundle || p.will_wrap_module_in_try_catch_for_using) {
		return js_ast.local_var
	}
	if p.options.mode == config.mode_bundle && kind == js_ast.local_const && p.options.minify_syntax {
		return js_ast.local_let
	}
	return kind
}

fn (p &Parser) push_scope_for_parse_pass(kind js_ast.ScopeKind, loc logger.Loc) isize {
	mut parent := p.current_scope
	mut scope := &js_ast.Scope{
		kind:    kind
		parent:  parent
		members: map[string]js_ast.ScopeMember{}
		label:   ast.LocRef{
			ref: ast.invalid_ref
		}
	}
	if parent != nil {
		parent.children << scope
		scope.strict_mode = parent.strict_mode
		scope.use_strict_loc = parent.use_strict_loc
	}
	p.current_scope = scope
	if p.scopes_in_order.len > 0 {
		mut prev_start := p.scopes_in_order[p.scopes_in_order.len - 1].loc.start
		if prev_start >= loc.start {
			panic(strconv.v_sprintf('Scope location %d must be greater than %d', loc.start,
				prev_start))
		}
	}
	if kind == js_ast.scope_function_body {
		if scope.parent.kind != js_ast.scope_function_args {
			panic('Internal error')
		}
		for name, member in scope.parent.members {
			mut kind_1 := p.symbols[member.ref.inner_index].kind
			if kind != ast.symbol_hoisted_function {
				scope.members[name] = member
			}
		}
	}
	mut scope_index := p.scopes_in_order.len
	p.scopes_in_order << ScopeOrder{
		loc:   loc
		scope: scope
	}
	return scope_index
}

fn (p &Parser) pop_scope() {
	if p.current_scope.contains_direct_eval {
		for _, member in p.current_scope.members {
			if p.options.mode == config.mode_bundle && p.current_scope.parent == nil && p.is_file_considered_esm {
				continue
			}
			p.symbols[member.ref.inner_index].flags |= ast.must_not_be_renamed
		}
	}
	p.current_scope = p.current_scope.parent
}

fn (p &Parser) pop_and_discard_scope(scope_index isize) {
	for i := p.scopes_in_order.len - 1; i >= scope_index; i-- {
		mut scope := p.scopes_in_order[i].scope
		mut parent := scope.parent
		mut last := parent.children.len - 1
		if parent.children[last] != scope {
			panic('Internal error')
		}
		parent.children = parent.children[..last]
	}
	p.current_scope = p.current_scope.parent
	p.scopes_in_order = p.scopes_in_order[..scope_index]
}

fn (p &Parser) pop_and_flatten_scope(scope_index isize) {
	mut to_flatten := p.current_scope
	mut parent := to_flatten.parent
	p.current_scope = parent
	copy(p.scopes_in_order[scope_index..], p.scopes_in_order[scope_index + 1..])
	p.scopes_in_order = p.scopes_in_order[..p.scopes_in_order.len - 1]
	mut last := parent.children.len - 1
	if parent.children[last] != to_flatten {
		panic('Internal error')
	}
	parent.children = parent.children[..last]
	for _, scope in to_flatten.children {
		scope.parent = parent
		parent.children << scope
	}
}

// Undo all scopes pushed and popped after this scope index. This assumes that
// the scope stack is at the same level now as it was at the given scope index.
fn (p &Parser) discard_scopes_up_to(scope_index isize) {
	mut children := p.current_scope.children
	for _, child in p.scopes_in_order[scope_index..] {
		if child.scope.parent == p.current_scope {
			for i := children.len - 1; i >= 0; i-- {
				if children[i] == child.scope {
					children << children[i + 1..]
					break
				}
			}
		}
	}
	p.current_scope.children = children
	p.scopes_in_order = p.scopes_in_order[..scope_index]
}

fn (p &Parser) new_symbol(kind ast.SymbolKind, name string) ast.Ref {
	mut ref := ast.Ref{
		source_index: p.source.index
		inner_index:  u32(p.symbols.len)
	}
	p.symbols << ast.Symbol{
		kind:          kind
		original_name: name
		link:          ast.invalid_ref
	}
	if p.options.ts.parse {
		p.ts_use_counts << 0
	}
	return ref
}

// This is similar to "ast.MergeSymbols" but it works with this parser's
// one-level symbol map instead of the linker's two-level symbol map. It also
// doesn't handle cycles since they shouldn't come up due to the way this
// function is used.
fn (p &Parser) merge_symbols(old ast.Ref, new ast.Ref) ast.Ref {
	if old == new {
		return new
	}
	mut old_symbol := &p.symbols[old.inner_index]
	if old_symbol.link != ast.invalid_ref {
		old_symbol.link = p.merge_symbols(old_symbol.link, new)
		return old_symbol.link
	}
	mut new_symbol := &p.symbols[new.inner_index]
	if new_symbol.link != ast.invalid_ref {
		new_symbol.link = p.merge_symbols(old, new_symbol.link)
		return new_symbol.link
	}
	old_symbol.link = new
	new_symbol.merge_contents_with(old_symbol)
	return new
}

type mergeResult = isize

enum mergeResult {
	merge_forbidden
	merge_replace_with_new
	merge_overwrite_with_new
	merge_keep_existing
	merge_become_private_get_set_pair
	merge_become_private_static_get_set_pair
}

fn (p &Parser) can_merge_symbols(scope &js_ast.Scope, existing ast.SymbolKind, new ast.SymbolKind) mergeResult {
	if existing == ast.symbol_unbound {
		return merge_replace_with_new
	}
	if p.options.ts.parse && existing == ast.symbol_import {
		return merge_replace_with_new
	}
	if new == ast.symbol_tse_num && existing == ast.symbol_tse_num {
		return merge_keep_existing
	}
	if new == ast.symbol_tse_num && existing == ast.symbol_tsn_amespace {
		return merge_replace_with_new
	}
	if new == ast.symbol_tsn_amespace {
		match existing {
			ast.symbol_tsn_amespace, ast.symbol_hoisted_function,
			ast.symbol_generator_or_async_function, ast.symbol_tse_num, ast.symbol_class {
				return merge_keep_existing
			}
		}
	}
	if new.is_hoisted_or_function() && existing.is_hoisted_or_function() && (
		scope.kind == js_ast.scope_entry || scope.kind == js_ast.scope_function_body
		|| scope.kind == js_ast.scope_function_args || new == existing && new.is_hoisted()) {
		return merge_replace_with_new
	}
	if existing == ast.symbol_private_get && new == ast.symbol_private_set
		|| existing == ast.symbol_private_set && new == ast.symbol_private_get {
		return merge_become_private_get_set_pair
	}
	if existing == ast.symbol_private_static_get && new == ast.symbol_private_static_set
		|| existing == ast.symbol_private_static_set && new == ast.symbol_private_static_get {
		return merge_become_private_static_get_set_pair
	}
	if existing == ast.symbol_catch_identifier && new == ast.symbol_hoisted {
		return merge_replace_with_new
	}
	if existing == ast.symbol_arguments && new == ast.symbol_hoisted {
		return merge_keep_existing
	}
	if existing == ast.symbol_arguments && new != ast.symbol_hoisted {
		return merge_overwrite_with_new
	}
	return merge_forbidden
}

fn (p &Parser) add_symbol_already_declared_error(name string, new_loc logger.Loc, old_loc logger.Loc) {
	p.log.add_error_with_notes(&p.tracker, js_lexer.range_of_identifier(p.source, new_loc),
		strconv.v_sprintf('The symbol %q has already been declared', name), [
		p.tracker.msg_data(js_lexer.range_of_identifier(p.source, old_loc), strconv.v_sprintf('The symbol %q was originally declared here:',
			name)),
	])
}

fn (p &Parser) declare_symbol(kind ast.SymbolKind, loc logger.Loc, name string) ast.Ref {
	p.check_for_unrepresentable_identifier(loc, name)
	mut ref := p.new_symbol(kind, name)
	mut existing, ok := p.current_scope.members[name]
	if ok {
		mut symbol := &p.symbols[existing.ref.inner_index]
		match p.can_merge_symbols(p.current_scope, symbol.kind, kind) {
			merge_forbidden {
				p.add_symbol_already_declared_error(name, loc, existing.loc)
				return existing.ref
			}
			merge_keep_existing {
				ref = existing.ref
			}
			merge_replace_with_new {
				symbol.link = ref
				p.current_scope.replaced << existing
				if p.options.minify_syntax && kind.is_function() && symbol.kind.is_function() {
					symbol.flags |= ast.remove_overwritten_function_declaration
				}
			}
			merge_become_private_get_set_pair {
				ref = existing.ref
				symbol.kind = ast.symbol_private_get_set_pair
			}
			merge_become_private_static_get_set_pair {
				ref = existing.ref
				symbol.kind = ast.symbol_private_static_get_set_pair
			}
			merge_overwrite_with_new {}
		}
	}
	p.current_scope.members[name] = js_ast.ScopeMember{
		ref: ref
		loc: loc
	}
	return ref
}

// This type is just so we can use Go's native sort function
type scopeMemberArray = []js_ast.ScopeMember

pub fn (a scopeMemberArray) len() isize {
	return a.len
}

pub fn (a scopeMemberArray) swap(i isize, j isize) {
	a[i], a[j] = a[j], a[i]
}

pub fn (a scopeMemberArray) less(i isize, j isize) bool {
	mut ai := a[i].ref
	mut bj := a[j].ref
	return ai.inner_index < bj.inner_index || ai.inner_index == bj.inner_index
		&& ai.source_index < bj.source_index
}

fn (p &Parser) hoist_symbols(scope &js_ast.Scope) {
	if scope.strict_mode != js_ast.sloppy_mode && scope.kind == js_ast.scope_block
		|| scope.parent == nil && p.is_file_considered_esm {
		for _, replaced in scope.replaced {
			mut symbol := &p.symbols[replaced.ref.inner_index]
			if symbol.kind.is_function() {
				mut member, ok := scope.members[symbol.original_name]
				if ok && p.symbols[member.ref.inner_index].kind.is_function() {
					mut notes := []logger.MsgData{}
					if scope.parent == nil && p.is_file_considered_esm {
						_, notes = p.why_esm_odule()
						notes[0].text = strconv.v_sprintf('Duplicate top-level function declarations are not allowed in an ECMAScript module. %s',
							notes[0].text)
					} else {
						mut where := 0
						where, notes = p.why_strict_mode(scope)
						notes[0].text = strconv.v_sprintf('Duplicate function declarations are not allowed in nested blocks %s. %s',
							where, notes[0].text)
					}
					p.log.add_error_with_notes(&p.tracker, js_lexer.range_of_identifier(p.source,
						member.loc), strconv.v_sprintf('The symbol %q has already been declared',
						symbol.original_name), append([
						p.tracker.msg_data(js_lexer.range_of_identifier(p.source, replaced.loc),
							strconv.v_sprintf('The symbol %q was originally declared here:',
							symbol.original_name)),
					], notes))
				}
			}
		}
	}
	if !scope.kind.stops_hoisting() {
		mut sorted_members := ScopeMemberArray{
			len: 0
			cap: scope.members.len
		}
		for _, member_1 in scope.members {
			sorted_members << member
		}
		sort.sort(sorted_members)
		sort.sort(sorted_members)
	}
	for _, child in scope.children {
		p.hoist_symbols(child)
	}
}

fn (p &Parser) declare_binding(kind ast.SymbolKind, binding js_ast.Binding, opts parseStmtOpts) {
	js_ast.for_each_identifier_binding(binding, fn (loc logger.Loc, b &js_ast.BIdentifier) {
		if !opts.is_type_script_declare || opts.is_namespace_scope && opts.is_export {
			b.ref = p.declare_symbol(kind, loc, p.load_name_from_ref(b.ref))
		}
	})
}

fn (p &Parser) record_usage(ref ast.Ref) {
	if !p.is_control_flow_dead {
		p.symbols[ref.inner_index].use_count_estimate++
		mut use := p.symbol_uses[ref]
		use.count_estimate++
		p.symbol_uses[ref] = use
	}
	if p.options.ts.parse {
		p.ts_use_counts[ref.inner_index]++
	}
}

fn (p &Parser) ignore_usage(ref ast.Ref) {
	if !p.is_control_flow_dead {
		p.symbols[ref.inner_index].use_count_estimate--
		mut use := p.symbol_uses[ref]
		use.count_estimate--
		if use.count_estimate == 0 {
			p.symbol_uses.delete(ref)
		} else {
			p.symbol_uses[ref] = use
		}
	}
}

fn (p &Parser) ignore_usage_of_identifier_in_dot_chain(expr js_ast.Expr) {
	for {
		mut e := expr.data
		match e {
			js_ast.EIdentifier {
				p.ignore_usage(e.ref)
			}
			js_ast.EDot {
				expr = e.target
				continue
			}
			js_ast.EIndex {
				_, ok := e.index.data
				if ok {
					expr = e.target
					continue
				}
			}
		}
		return
	}
}

fn (p &Parser) import_from_runtime(loc logger.Loc, name string) js_ast.Expr {
	mut it, ok := p.runtime_imports[name]
	if !ok {
		it.loc = loc
		it.ref = p.new_symbol(ast.symbol_other, name)
		p.module_scope.generated << it.ref
		p.runtime_imports[name] = it
	}
	p.record_usage(it.ref)
	return js_ast.Expr{
		loc:  loc
		data: &js_ast.EIdentifier{
			ref: it.ref
		}
	}
}

fn (p &Parser) call_runtime(loc logger.Loc, name string, args []js_ast.Expr) js_ast.Expr {
	return js_ast.Expr{
		loc:  loc
		data: &js_ast.ECall{
			target: p.import_from_runtime(loc, name)
			args:   args
		}
	}
}

type JSXImport = u8

enum JSXImport {
	jsxi_mport_jsx
	jsxi_mport_jsxs
	jsxi_mport_fragment
	jsxi_mport_create_element
}

fn (p &Parser) import_jsxs_ymbol(loc logger.Loc, jsx JSXImport) js_ast.Expr {
	mut symbols := map[string]ast.LocRef{}
	mut name := 0
	match jsx {
		jsxi_mport_jsx {
			symbols = p.jsx_runtime_imports
			if p.options.jsx.development {
				name = 'jsxDEV'
			} else {
				name = 'jsx'
			}
		}
		jsxi_mport_jsxs {
			symbols = p.jsx_runtime_imports
			if p.options.jsx.development {
				name = 'jsxDEV'
			} else {
				name = 'jsxs'
			}
		}
		jsxi_mport_fragment {
			symbols = p.jsx_runtime_imports
			name = 'Fragment'
		}
		jsxi_mport_create_element {
			symbols = p.jsx_legacy_imports
			name = 'createElement'
		}
	}
	mut it, ok := symbols[name]
	if !ok {
		it.loc = loc
		it.ref = p.new_symbol(ast.symbol_other, name)
		p.module_scope.generated << it.ref
		p.is_import_item[it.ref] = true
		symbols[name] = it
	}
	p.record_usage(it.ref)
	return p.handle_identifier(loc, &js_ast.EIdentifier{
		ref: it.ref
	}, IdentifierOpts{
		was_originally_identifier: true
	})
}

fn (p &Parser) value_to_substitute_for_require(loc logger.Loc) js_ast.Expr {
	if p.source.index != runtime.source_index && config.should_call_runtime_require(p.options.mode,
		p.options.output_format) {
		return p.import_from_runtime(loc, '__require')
	}
	p.record_usage(p.require_ref)
	return js_ast.Expr{
		loc:  loc
		data: &js_ast.EIdentifier{
			ref: p.require_ref
		}
	}
}

fn (p &Parser) make_promise_ref() ast.Ref {
	if p.promise_ref == ast.invalid_ref {
		p.promise_ref = p.new_symbol(ast.symbol_unbound, 'Promise')
	}
	return p.promise_ref
}

fn (p &Parser) make_reg_exp_ref() ast.Ref {
	if p.reg_exp_ref == ast.invalid_ref {
		p.reg_exp_ref = p.new_symbol(ast.symbol_unbound, 'RegExp')
		p.module_scope.generated << p.reg_exp_ref
	}
	return p.reg_exp_ref
}

// The name is temporarily stored in the ref until the scope traversal pass
// happens, at which point a symbol will be generated and the ref will point
// to the symbol instead.
//
// The scope traversal pass will reconstruct the name using one of two methods.
// In the common case, the name is a slice of the file itself. In that case we
// can just store the slice and not need to allocate any extra memory. In the
// rare case, the name is an externally-allocated string. In that case we store
// an index to the string and use that index during the scope traversal pass.
fn (p &Parser) store_name_in_ref(name js_lexer.MaybeSubstring) ast.Ref {
	if name.start.is_valid() {
		return ast.Ref{
			source_index: -u32(name.string.len)
			inner_index:  u32(name.start.get_index())
		}
	} else {
		mut ref := ast.Ref{
			source_index: 0x80000000
			inner_index:  u32(p.allocated_names.len)
		}
		p.allocated_names << name.string
		return ref
	}
}

// This is the inverse of storeNameInRef() above
fn (p &Parser) load_name_from_ref(ref ast.Ref) string {
	if ref.source_index == 0x80000000 {
		return p.allocated_names[ref.inner_index]
	}
	else {
		if (ref.source_index & 0x80000000) == 0 {
			panic('Internal error: invalid symbol reference')
		}
		return p.source.contents[ref.inner_index..i32(ref.inner_index) - i32(ref.source_index)]
	}
}

// Due to ES6 destructuring patterns, there are many cases where it's
// impossible to distinguish between an array or object literal and a
// destructuring assignment until we hit the "=" operator later on.
// This object defers errors about being in one state or the other
// until we discover which state we're in.
struct deferredErrors {
pub mut:
	// These are errors for expressions
	invalid_expr_default_value  logger.Range
	invalid_expr_after_question logger.Range
	array_spread_feature        logger.Range
	// These errors are for arrow functions
	invalid_parens []logger.Range
}

fn (from &DeferredErrors) merge_into(to &DeferredErrors) {
	if from.invalid_expr_default_value.len > 0 {
		to.invalid_expr_default_value = from.invalid_expr_default_value
	}
	if from.invalid_expr_after_question.len > 0 {
		to.invalid_expr_after_question = from.invalid_expr_after_question
	}
	if from.array_spread_feature.len > 0 {
		to.array_spread_feature = from.array_spread_feature
	}
	if from.invalid_parens.len > 0 {
		if to.invalid_parens.len > 0 {
			to.invalid_parens << from.invalid_parens
		} else {
			to.invalid_parens = from.invalid_parens
		}
	}
}

fn (p &Parser) log_expr_errors(errors &DeferredErrors) {
	if errors.invalid_expr_default_value.len > 0 {
		p.log.add_error(&p.tracker, errors.invalid_expr_default_value, 'Unexpected "="')
	}
	if errors.invalid_expr_after_question.len > 0 {
		mut r := errors.invalid_expr_after_question
		p.log.add_error(&p.tracker, r, strconv.v_sprintf('Unexpected %q', p.source.contents[r.loc.start..
			r.loc.start + r.len]))
	}
	if errors.array_spread_feature.len > 0 {
		p.mark_syntax_feature(compat.array_spread, errors.array_spread_feature)
	}
}

fn (p &Parser) log_deferred_arrow_arg_errors(errors &DeferredErrors) {
	for _, paren in errors.invalid_parens {
		p.log.add_error(&p.tracker, paren, 'Invalid binding pattern')
	}
}

fn (p &Parser) log_nullish_coalescing_error_precedence_error(op string) {
	mut prev_op := '??'
	if p.lexer.token == js_lexer.tq_uestion_question {
		op, prev_op = prev_op, op
	}
	p.log.add_error_with_notes(&p.tracker, p.lexer.range(), strconv.v_sprintf('Cannot use %q with %q without parentheses',
		op, prev_op), [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
	])
}

fn define_value_can_be_used_in_assign_target(data js_ast.E) bool {
	// append no rhs

	// lhs.len==0
	return false
}

fn (p &Parser) log_assign_to_define(r logger.Range, name string, expr js_ast.Expr) {
	if expr.data != nil {
		mut parts := []string{}
		for {
			mut id, ok := expr.data
			if ok {
				parts << p.load_name_from_ref(id.ref)
				break
			}
			else {
				mut dot, ok_1 := expr.data
				if ok {
					parts << dot.name
					parts << '.'
					expr = dot.target
				}
				else {
					mut index, ok_2 := expr.data
					if ok {
						mut str, ok_3 := index.index.data
						if ok {
							parts << ']'
							parts << helpers.quote_single(helpers.utf_16_to_string(str.value),
								false).str()

							parts << '['
							expr = index.target
						} else {
							return
						}
					}
				}
			}
		}
		for i, j := isize(0), parts.len - 1; i < j; i, j = i + 1, j - 1 {
			parts[i], parts[j] = parts[j], parts[i]
		}
		name = parts.join('')
	}
	mut kind := logger.warning
	if p.suppress_warnings_about_weird_code {
		kind = logger.debug
	}
	p.log.add_idw_ith_notes(logger.msg_id_js_assign_to_define, kind, &p.tracker, r, strconv.v_sprintf('Suspicious assignment to defined constant %q',
		name), [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
	])
}

// The "await" and "yield" expressions are never allowed in argument lists but
// may or may not be allowed otherwise depending on the details of the enclosing
// function or module. This needs to be handled when parsing an arrow function
// argument list because we don't know if these expressions are not allowed until
// we reach the "=>" token (or discover the absence of one).
//
// Specifically, for await:
//
//	// This is ok
//	async function foo() { (x = await y) }
//
//	// This is an error
//	async function foo() { (x = await y) => {} }
//
// And for yield:
//
//	// This is ok
//	function* foo() { (x = yield y) }
//
//	// This is an error
//	function* foo() { (x = yield y) => {} }
struct deferredArrowArgErrors {
pub mut:
	invalid_expr_await logger.Range
	invalid_expr_yield logger.Range
}

fn (p &Parser) log_arrow_arg_errors(errors &DeferredArrowArgErrors) {
	if errors.invalid_expr_await.len > 0 {
		p.log.add_error(&p.tracker, errors.invalid_expr_await, 'Cannot use an "await" expression here:')
	}
	if errors.invalid_expr_yield.len > 0 {
		p.log.add_error(&p.tracker, errors.invalid_expr_yield, 'Cannot use a "yield" expression here:')
	}
}

fn (p &Parser) key_name_for_error(key js_ast.Expr) string {
	mut k := key.data
	match k {
		js_ast.EString {
			return strconv.v_sprintf('%q', helpers.utf_16_to_string(k.value))
		}
		js_ast.EPrivateIdentifier {
			return strconv.v_sprintf('%q', p.load_name_from_ref(k.ref))
		}
	}
	return 'property'
}

fn (p &Parser) check_for_legacy_octal_literal(e js_ast.E) {
	if p.lexer.is_legacy_octal_literal {
		if p.legacy_octal_literals == nil {
			p.legacy_octal_literals = map[js_ast.E]logger.Range{}
		}
		p.legacy_octal_literals[e] = p.lexer.range()
	}
}

fn (p &Parser) notes_for_assert_type_json(record &ast.ImportRecord, alias string) []logger.MsgData {
	return [
		p.tracker.msg_data(js_lexer.range_of_import_assert_or_with(p.source, &ast.find_assert_or_with_entry(record.assert_or_with.entries,
			'type'), js_lexer.key_and_value_range), 'The JSON import assertion is here:'), // UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
	]
}

// This assumes the caller has already checked for TStringLiteral or TNoSubstitutionTemplateLiteral
fn (p &Parser) parse_string_literal() js_ast.Expr {
	mut legacyOctalLoc := 0
	mut loc := p.lexer.loc()
	mut text := p.lexer.string_literal()
	mut has_property_key_comment := (p.lexer.has_comment_before & js_lexer.key_comment_before) != 0
	if has_property_key_comment {
		mut name := helpers.utf_16_to_string(text)
		if p.is_mangled_prop(name) {
			mut value := js_ast.Expr{
				loc:  loc
				data: &js_ast.ENameOfSymbol{
					ref:                      p.store_name_in_ref(js_lexer.MaybeSubstring{
						string: name
					})
					has_property_key_comment: true
				}
			}
			p.lexer.next()
			return value
		}
	}
	if p.lexer.legacy_octal_loc.start > loc.start {
		legacy_octal_loc = p.lexer.legacy_octal_loc
	}
	mut value_1 := js_ast.Expr{
		loc:  loc
		data: &js_ast.EString{
			value:                    text
			legacy_octal_loc:         legacy_octal_loc
			prefer_template:          p.lexer.token == js_lexer.tn_o_substitution_template_literal
			has_property_key_comment: has_property_key_comment
		}
	}
	p.lexer.next()
	return value
}

struct propertyOpts {
pub mut:
	decorators        []js_ast.Decorator
	decorator_scope   &js_ast.Scope = unsafe { nil }
	decorator_context decoratorContextFlags
	async_range       logger.Range
	generator_range   logger.Range
	ts_declare_range  logger.Range
	class_keyword     logger.Range
	is_async          bool
	is_generator      bool
	// Class-related options
	is_static         bool
	is_tsa_bstract    bool
	is_class          bool
	class_has_extends bool
}

fn (p &Parser) parse_property(start_loc logger.Loc, kind js_ast.PropertyKind, opts propertyOpts, errors &DeferredErrors) (js_ast.Property, bool) {
	mut flags := 0
	mut key := 0
	mut closeBracketLoc := 0
	mut key_range := p.lexer.range()
	match p.lexer.token {
		js_lexer.tn_umeric_literal {
			key = js_ast.Expr{
				loc:  p.lexer.loc()
				data: &js_ast.ENumber{
					value: p.lexer.number
				}
			}
			p.check_for_legacy_octal_literal(key.data)
			p.lexer.next()
		}
		js_lexer.ts_tring_literal {
			key = p.parse_string_literal()
			if !p.options.minify_syntax {
				flags |= js_ast.property_prefer_quoted_key
			}
		}
		js_lexer.tb_ig_integer_literal {
			key = js_ast.Expr{
				loc:  p.lexer.loc()
				data: &js_ast.EBigInt{
					value: p.lexer.identifier.string
				}
			}
			p.mark_syntax_feature(compat.bigint, p.lexer.range())
			p.lexer.next()
		}
		js_lexer.tp_rivate_identifier {
			if p.options.ts.parse && p.options.ts.config.experimental_decorators == config.true_ && opts.decorators.len > 0 {
				p.log.add_error(&p.tracker, p.lexer.range(), 'TypeScript experimental decorators cannot be used on private identifiers')
			} else if !opts.is_class {
				p.lexer.expected(js_lexer.ti_dentifier)
			} else if opts.ts_declare_range.len != 0 {
				p.log.add_error(&p.tracker, opts.ts_declare_range, '"declare" cannot be used with a private identifier')
			}
			mut name := p.lexer.identifier
			key = js_ast.Expr{
				loc:  p.lexer.loc()
				data: &js_ast.EPrivateIdentifier{
					ref: p.store_name_in_ref(name)
				}
			}
			p.report_private_name_usage(name.string)
			p.lexer.next()
		}
		js_lexer.to_pen_bracket {
			flags |= js_ast.property_is_computed
			p.mark_syntax_feature(compat.object_extensions, p.lexer.range())
			p.lexer.next()
			mut was_identifier := p.lexer.token == js_lexer.ti_dentifier
			mut expr := p.parse_expr(js_ast.lc_omma)
			if p.options.ts.parse && p.lexer.token == js_lexer.tc_olon && was_identifier && opts.is_class {
				_, ok := expr.data
				if ok {
					if opts.ts_declare_range.len != 0 {
						p.log.add_error(&p.tracker, opts.ts_declare_range, '"declare" cannot be used with an index signature')
					}
					p.lexer.next()
					p.skip_type_script_type(js_ast.ll_owest)
					p.lexer.expect(js_lexer.tc_lose_bracket)
					p.lexer.expect(js_lexer.tc_olon)
					p.skip_type_script_type(js_ast.ll_owest)
					p.lexer.expect_or_insert_semicolon()
					return js_ast.Property{}, false
				}
			}
			close_bracket_loc = p.save_expr_comments_here()
			p.lexer.expect(js_lexer.tc_lose_bracket)
			key = expr
		}
		js_lexer.ta_sterisk {
			if kind != js_ast.property_field && (kind != js_ast.property_method
				|| opts.is_generator) {
				p.lexer.unexpected()
			}
			opts.is_generator = true
			opts.generator_range = p.lexer.range()
			p.lexer.next()
			return p.parse_property(start_loc, js_ast.property_method, opts, errors)
		}
		else {
			mut name_1 := p.lexer.identifier
			mut raw := p.lexer.raw()
			mut name_range := p.lexer.range()
			if !p.lexer.is_identifier_or_keyword() {
				p.lexer.expect(js_lexer.ti_dentifier)
			}
			p.lexer.next()
			if kind == js_ast.property_field {
				mut could_be_modifier_keyword := p.lexer.is_identifier_or_keyword()
				if !could_be_modifier_keyword {
					match p.lexer.token {
						js_lexer.to_pen_bracket, js_lexer.tn_umeric_literal,
						js_lexer.ts_tring_literal, js_lexer.ta_sterisk,
						js_lexer.tp_rivate_identifier {
							could_be_modifier_keyword = true
						}
					}
				}
				if could_be_modifier_keyword {
					match name.string {
						'get' {
							if !opts.is_async && raw == name.string {
								p.mark_syntax_feature(compat.object_accessors, name_range)
								return p.parse_property(start_loc, js_ast.property_getter,
									opts, nil)
							}
						}
						'set' {
							if !opts.is_async && raw == name.string {
								p.mark_syntax_feature(compat.object_accessors, name_range)
								return p.parse_property(start_loc, js_ast.property_setter,
									opts, nil)
							}
						}
						'accessor' {
							if !p.lexer.has_newline_before && !opts.is_async && opts.is_class
								&& raw == name.string {
								return p.parse_property(start_loc, js_ast.property_auto_accessor,
									opts, nil)
							}
						}
						'async' {
							if !p.lexer.has_newline_before && !opts.is_async && raw == name.string {
								opts.is_async = true
								opts.async_range = name_range
								return p.parse_property(start_loc, js_ast.property_method,
									opts, nil)
							}
						}
						'static' {
							if !opts.is_static && !opts.is_async && opts.is_class
								&& raw == name.string {
								opts.is_static = true
								return p.parse_property(start_loc, kind, opts, nil)
							}
						}
						'declare' {
							if !p.lexer.has_newline_before && opts.is_class && p.options.ts.parse && opts.ts_declare_range.len == 0 && raw == name.string {
								opts.ts_declare_range = name_range
								mut scope_index := p.scopes_in_order.len
								mut prop, ok_1 := p.parse_property(start_loc, kind, opts,
									nil)
								if ok && prop.kind == js_ast.property_field && prop.value_or_nil.data == nil && (p.options.ts.config.experimental_decorators == config.true_ && opts.decorators.len > 0) {
									prop.kind = js_ast.property_declare_or_abstract
									return prop, true
								}
								p.discard_scopes_up_to(scope_index)
								return js_ast.Property{}, false
							}
						}
						'abstract' {
							if !p.lexer.has_newline_before && opts.is_class && p.options.ts.parse
								&& !opts.is_tsa_bstract && raw == name.string {
								opts.is_tsa_bstract = true
								mut scope_index_1 := p.scopes_in_order.len
								mut prop_1, ok_2 := p.parse_property(start_loc, kind,
									opts, nil)
								if ok && prop.kind == js_ast.property_field && prop.value_or_nil.data == nil && (p.options.ts.config.experimental_decorators == config.true_ && opts.decorators.len > 0) {
									prop.kind = js_ast.property_declare_or_abstract
									return prop, true
								}
								p.discard_scopes_up_to(scope_index)
								return js_ast.Property{}, false
							}
						}
						'private', 'protected', 'public', 'readonly', 'override' {
							if opts.is_class && p.options.ts.parse && raw == name.string {
								return p.parse_property(start_loc, kind, opts, nil)
							}
						}
					}
				} else if p.lexer.token == js_lexer.to_pen_brace && name.string == 'static' && opts.decorators.len == 0 {
					mut loc := p.lexer.loc()
					p.lexer.next()
					mut old_fn_or_arrow_data_parse := p.fn_or_arrow_data_parse
					p.fn_or_arrow_data_parse = FnOrArrowDataParse{
						is_return_disallowed: true
						allow_super_property: true
						await:                forbid_all
					}
					p.push_scope_for_parse_pass(js_ast.scope_class_static_init, loc)
					mut stmts := p.parse_stmts_up_to(js_lexer.tc_lose_brace, ParseStmtOpts{})
					p.pop_scope()
					p.fn_or_arrow_data_parse = old_fn_or_arrow_data_parse
					mut close_brace_loc := p.lexer.loc()
					p.lexer.expect(js_lexer.tc_lose_brace)
					return js_ast.Property{
						kind:               js_ast.property_class_static_block
						loc:                start_loc
						class_static_block: &js_ast.ClassStaticBlock{
							loc:   loc
							block: js_ast.SBlock{
								stmts:           stmts
								close_brace_loc: close_brace_loc
							}
						}
					}, true
				}
			}
			if p.is_mangled_prop(name.string) {
				key = js_ast.Expr{
					loc:  name_range.loc
					data: &js_ast.ENameOfSymbol{
						ref: p.store_name_in_ref(name)
					}
				}
			} else {
				key = js_ast.Expr{
					loc:  name_range.loc
					data: &js_ast.EString{
						value: helpers.string_to_utf_16(name.string)
					}
				}
			}
			if !opts.is_class && kind == js_ast.property_field && p.lexer.token != js_lexer.tc_olon && p.lexer.token != js_lexer.to_pen_paren && p.lexer.token != js_lexer.tl_ess_than && js_lexer.keywords[name.string] == js_lexer.t(0) {
				if p.fn_or_arrow_data_parse.await != allow_ident && name.string == 'await'
					|| p.fn_or_arrow_data_parse.yield != allow_ident && name.string == 'yield' {
					p.log.add_error(&p.tracker, name_range, strconv.v_sprintf('Cannot use %q as an identifier here:',
						name.string))
				}
				mut ref := p.store_name_in_ref(name)
				mut value := js_ast.Expr{
					loc:  key.loc
					data: &js_ast.EIdentifier{
						ref: ref
					}
				}
				mut initializerOrNil := 0
				if errors != nil && p.lexer.token == js_lexer.te_quals {
					errors.invalid_expr_default_value = p.lexer.range()
					p.lexer.next()
					initializer_or_nil = p.parse_expr(js_ast.lc_omma)
				}
				return js_ast.Property{
					kind:               kind
					loc:                start_loc
					key:                key
					value_or_nil:       value
					initializer_or_nil: initializer_or_nil
					flags:              js_ast.property_was_shorthand
				}, true
			}
		}
	}
	mut has_type_parameters := false
	mut has_definite_assignment_assertion_operator := false
	if p.options.ts.parse {
		if opts.is_class {
			if p.lexer.token == js_lexer.tq_uestion {
				p.lexer.next()
			} else if p.lexer.token == js_lexer.te_xclamation && !p.lexer.has_newline_before
				&& (kind == js_ast.property_field || kind == js_ast.property_auto_accessor) {
				p.lexer.next()
				has_definite_assignment_assertion_operator = true
			}
		}
		if !has_definite_assignment_assertion_operator && kind != js_ast.property_auto_accessor {
			has_type_parameters = p.skip_type_script_type_parameters(allow_const_modifier) != did_not_skip_anything
		}
	}
	if kind == js_ast.property_auto_accessor || (opts.is_class && kind == js_ast.property_field
		&& !has_type_parameters && (p.lexer.token != js_lexer.to_pen_paren
		|| has_definite_assignment_assertion_operator)) {
		if !flags.has(js_ast.property_is_computed) {
			mut str, ok_3 := key.data
			if ok && (helpers.utf_16_equals_string(str.value, 'constructor')
				|| opts.is_static && helpers.utf_16_equals_string(str.value, 'prototype')) {
				p.log.add_error(&p.tracker, key_range, strconv.v_sprintf('Invalid field name %q',
					helpers.utf_16_to_string(str.value)))
			}
		}
		if p.options.ts.parse && p.lexer.token == js_lexer.tc_olon {
			p.lexer.next()
			p.skip_type_script_type(js_ast.ll_owest)
		}
		if p.lexer.token == js_lexer.te_quals {
			p.lexer.next()
			mut old_is_this_disallowed := p.fn_or_arrow_data_parse.is_this_disallowed
			mut old_allow_super_property := p.fn_or_arrow_data_parse.allow_super_property
			p.fn_or_arrow_data_parse.is_this_disallowed = false
			p.fn_or_arrow_data_parse.allow_super_property = true
			initializer_or_nil = p.parse_expr(js_ast.lc_omma)
			p.fn_or_arrow_data_parse.is_this_disallowed = old_is_this_disallowed
			p.fn_or_arrow_data_parse.allow_super_property = old_allow_super_property
		}
		mut private, ok_4 := key.data
		if ok {
			mut name_2 := p.load_name_from_ref(private.ref)
			if name == '#constructor' {
				p.log.add_error(&p.tracker, key_range, strconv.v_sprintf('Invalid field name %q',
					name))
			}
			mut declare := 0
			if kind == js_ast.property_auto_accessor {
				if opts.is_static {
					declare = ast.symbol_private_static_get_set_pair
				} else {
					declare = ast.symbol_private_get_set_pair
				}
				private.ref = p.declare_symbol(declare, key.loc, name)
				p.private_getters[private.ref] = p.new_symbol(ast.symbol_other, name[1..] + '_get')
				p.private_setters[private.ref] = p.new_symbol(ast.symbol_other, name[1..] + '_set')
			}
			else {
				if opts.is_static {
					declare = ast.symbol_private_static_field
				} else {
					declare = ast.symbol_private_field
				}
				private.ref = p.declare_symbol(declare, key.loc, name)
			}
		}
		p.lexer.expect_or_insert_semicolon()
		if opts.is_static {
			flags |= js_ast.property_is_static
		}
		return js_ast.Property{
			decorators:         opts.decorators
			loc:                start_loc
			kind:               kind
			flags:              flags
			key:                key
			initializer_or_nil: initializer_or_nil
			close_bracket_loc:  close_bracket_loc
		}, true
	}
	if p.lexer.token == js_lexer.to_pen_paren || kind.is_method_definition() || opts.is_class {
		mut has_error := false
		if !has_error && opts.ts_declare_range.len != 0 {
			mut what := 'method'
			if kind == js_ast.property_getter {
				what = 'getter'
			} else if kind == js_ast.property_setter {
				what = 'setter'
			}
			p.log.add_error(&p.tracker, opts.ts_declare_range, '"declare" cannot be used with a ' +
				what)
			has_error = true
		}
		if opts.is_async && p.mark_async_fn(opts.async_range, opts.is_generator) {
			has_error = true
		}
		if !has_error && opts.is_generator && p.mark_syntax_feature(compat.generator,
			opts.generator_range) {
			has_error = true
		}
		if !has_error && p.lexer.token == js_lexer.to_pen_paren && kind != js_ast.property_getter && kind != js_ast.property_setter && p.mark_syntax_feature(compat.object_extensions,
			p.lexer.range()) {
			has_error = true
		}
		mut loc_1 := p.lexer.loc()
		mut scope_index_2 := p.push_scope_for_parse_pass(js_ast.scope_function_args, loc)
		mut is_constructor := false
		if opts.is_class && !flags.has(js_ast.property_is_computed) {
			mut str_1, ok_5 := key.data
			if ok {
				if !opts.is_static && helpers.utf_16_equals_string(str.value, 'constructor') {
					if kind == js_ast.property_getter {
						p.log.add_error(&p.tracker, key_range, 'Class constructor cannot be a getter')
					} else if kind == js_ast.property_setter {
						p.log.add_error(&p.tracker, key_range, 'Class constructor cannot be a setter')
					} else if opts.is_async {
						p.log.add_error(&p.tracker, key_range, 'Class constructor cannot be an async function')
					} else if opts.is_generator {
						p.log.add_error(&p.tracker, key_range, 'Class constructor cannot be a generator')
					} else {
						is_constructor = true
					}
				} else if opts.is_static && helpers.utf_16_equals_string(str.value, 'prototype') {
					p.log.add_error(&p.tracker, key_range, 'Invalid static method name "prototype"')
				}
			}
		}
		mut await := allow_ident
		mut yield := allow_ident
		if opts.is_async {
			await = allow_expr
		}
		if opts.is_generator {
			yield = allow_expr
		}
		mut fn_, had_body := p.parse_fn(nil, opts.class_keyword, opts.decorator_context,
			FnOrArrowDataParse{
			needs_async_loc:                    key.loc
			async_range:                        opts.async_range
			await:                              await
			yield:                              yield
			allow_super_call:                   opts.class_has_extends && is_constructor
			allow_super_property:               true
			decorator_scope:                    opts.decorator_scope
			is_constructor:                     is_constructor
			allow_missing_body_for_type_script: p.options.ts.parse && opts.is_class
		})
		if !had_body {
			p.pop_and_discard_scope(scope_index)
			return js_ast.Property{}, false
		}
		p.pop_scope()
		fn_.is_unique_formal_parameters = true
		mut value_1 := js_ast.Expr{
			loc:  loc
			data: &js_ast.EFunction{
				fn_: fn_
			}
		}
		match kind {
			js_ast.property_getter {
				if fn_.args.len > 0 {
					mut r := js_lexer.range_of_identifier(p.source, fn_.args[0].binding.loc)
					p.log.add_error(&p.tracker, r, strconv.v_sprintf('Getter %s must have zero arguments',
						p.key_name_for_error(key)))
				}
			}
			js_ast.property_setter {
				if fn_.args.len != 1 {
					mut r_1 := js_lexer.range_of_identifier(p.source, key.loc)
					if fn_.args.len > 1 {
						r = js_lexer.range_of_identifier(p.source, fn_.args[1].binding.loc)
					}
					p.log.add_error(&p.tracker, r, strconv.v_sprintf('Setter %s must have exactly one argument',
						p.key_name_for_error(key)))
				}
			}
			else {
				kind = js_ast.property_method
			}
		}
		mut private_1, ok_6 := key.data
		if ok {
			mut suffix := 0
			match kind {
				js_ast.property_getter {
					if opts.is_static {
						declare = ast.symbol_private_static_get
					} else {
						declare = ast.symbol_private_get
					}
					suffix = '_get'
				}
				js_ast.property_setter {
					if opts.is_static {
						declare = ast.symbol_private_static_set
					} else {
						declare = ast.symbol_private_set
					}
					suffix = '_set'
				}
				else {
					if opts.is_static {
						declare = ast.symbol_private_static_method
					} else {
						declare = ast.symbol_private_method
					}
					suffix = '_fn'
				}
			}
			mut name_3 := p.load_name_from_ref(private.ref)
			if name == '#constructor' {
				p.log.add_error(&p.tracker, key_range, strconv.v_sprintf('Invalid method name %q',
					name))
			}
			private.ref = p.declare_symbol(declare, key.loc, name)
			mut method_ref := p.new_symbol(ast.symbol_other, name[1..] + suffix)
			if kind == js_ast.property_setter {
				p.private_setters[private.ref] = method_ref
			} else {
				p.private_getters[private.ref] = method_ref
			}
		}
		if opts.is_static {
			flags |= js_ast.property_is_static
		}
		return js_ast.Property{
			decorators:        opts.decorators
			loc:               start_loc
			kind:              kind
			flags:             flags
			key:               key
			value_or_nil:      value
			close_bracket_loc: close_bracket_loc
		}, true
	}
	p.lexer.expect(js_lexer.tc_olon)
	mut value_2 := p.parse_expr_or_bindings(js_ast.lc_omma, errors)
	return js_ast.Property{
		loc:               start_loc
		kind:              kind
		flags:             flags
		key:               key
		value_or_nil:      value
		close_bracket_loc: close_bracket_loc
	}, true
}

fn (p &Parser) parse_property_binding() js_ast.PropertyBinding {
	mut key := 0
	mut closeBracketLoc := 0
	mut is_computed := false
	mut prefer_quoted_key := false
	mut loc := p.lexer.loc()
	match p.lexer.token {
		js_lexer.td_ot_dot_dot {
			p.lexer.next()
			mut value := js_ast.Binding{
				loc:  p.save_expr_comments_here()
				data: &js_ast.BIdentifier{
					ref: p.store_name_in_ref(p.lexer.identifier)
				}
			}
			p.lexer.expect(js_lexer.ti_dentifier)
			return js_ast.PropertyBinding{
				loc:       loc
				is_spread: true
				value:     value
			}
		}
		js_lexer.tn_umeric_literal {
			key = js_ast.Expr{
				loc:  p.lexer.loc()
				data: &js_ast.ENumber{
					value: p.lexer.number
				}
			}
			p.check_for_legacy_octal_literal(key.data)
			p.lexer.next()
		}
		js_lexer.ts_tring_literal {
			key = p.parse_string_literal()
			prefer_quoted_key = !p.options.minify_syntax
		}
		js_lexer.tb_ig_integer_literal {
			key = js_ast.Expr{
				loc:  p.lexer.loc()
				data: &js_ast.EBigInt{
					value: p.lexer.identifier.string
				}
			}
			p.mark_syntax_feature(compat.bigint, p.lexer.range())
			p.lexer.next()
		}
		js_lexer.to_pen_bracket {
			is_computed = true
			p.lexer.next()
			key = p.parse_expr(js_ast.lc_omma)
			close_bracket_loc = p.save_expr_comments_here()
			p.lexer.expect(js_lexer.tc_lose_bracket)
		}
		else {
			mut name := p.lexer.identifier
			mut name_range := p.lexer.range()
			if !p.lexer.is_identifier_or_keyword() {
				p.lexer.expect(js_lexer.ti_dentifier)
			}
			p.lexer.next()
			if p.is_mangled_prop(name.string) {
				key = js_ast.Expr{
					loc:  name_range.loc
					data: &js_ast.ENameOfSymbol{
						ref: p.store_name_in_ref(name)
					}
				}
			} else {
				key = js_ast.Expr{
					loc:  name_range.loc
					data: &js_ast.EString{
						value: helpers.string_to_utf_16(name.string)
					}
				}
			}
			if p.lexer.token != js_lexer.tc_olon && p.lexer.token != js_lexer.to_pen_paren {
				if p.fn_or_arrow_data_parse.await != allow_ident && name.string == 'await'
					|| p.fn_or_arrow_data_parse.yield != allow_ident && name.string == 'yield' {
					p.log.add_error(&p.tracker, name_range, strconv.v_sprintf('Cannot use %q as an identifier here:',
						name.string))
				}
				mut ref := p.store_name_in_ref(name)
				mut value_1 := js_ast.Binding{
					loc:  name_range.loc
					data: &js_ast.BIdentifier{
						ref: ref
					}
				}
				mut defaultValueOrNil := 0
				if p.lexer.token == js_lexer.te_quals {
					p.lexer.next()
					default_value_or_nil = p.parse_expr(js_ast.lc_omma)
				}
				return js_ast.PropertyBinding{
					loc:                  loc
					key:                  key
					value:                value
					default_value_or_nil: default_value_or_nil
				}
			}
		}
	}
	p.lexer.expect(js_lexer.tc_olon)
	mut value_2 := p.parse_binding(ParseBindingOpts{})
	if p.lexer.token == js_lexer.te_quals {
		p.lexer.next()
		default_value_or_nil = p.parse_expr(js_ast.lc_omma)
	}
	return js_ast.PropertyBinding{
		loc:                  loc
		is_computed:          is_computed
		prefer_quoted_key:    prefer_quoted_key
		key:                  key
		value:                value
		default_value_or_nil: default_value_or_nil
		close_bracket_loc:    close_bracket_loc
	}
}

// These properties have special semantics in JavaScript. They must not be
// mangled or we could potentially fail to parse valid JavaScript syntax or
// generate invalid JavaScript syntax as output.
//
// This list is only intended to contain properties specific to the JavaScript
// language itself to avoid syntax errors in the generated output. It's not
// intended to contain properties for JavaScript APIs. Those must be provided
// by the user.
__global permanentReservedProps = {
	'__proto__':   true
	'constructor': true
	'prototype':   true
}
fn (p &Parser) is_mangled_prop(name string) bool {
	if p.options.mangle_props == nil {
		return false
	}
	if p.options.mangle_props.match_string(name) && !permanent_reserved_props[name]
		&& (p.options.reserve_props == nil || !p.options.reserve_props.match_string(name)) {
		return true
	}
	mut reserved_props := p.reserved_props
	if reserved_props == nil {
		reserved_props = map[string]Bool{}
		p.reserved_props = reserved_props
	}
	reserved_props[name] = true
	return false
}

fn (p &Parser) symbol_for_mangled_prop(name string) ast.Ref {
	mut mangled_props := p.mangled_props
	if mangled_props == nil {
		mangled_props = map[string]ast.Ref{}
		p.mangled_props = mangled_props
	}
	mut ref, ok := mangled_props[name]
	if !ok {
		ref = p.new_symbol(ast.symbol_mangled_prop, name)
		mangled_props[name] = ref
	}
	if !p.is_control_flow_dead {
		p.symbols[ref.inner_index].use_count_estimate++
	}
	return ref
}

type wasOriginallyDotOrIndex = u8

enum wasOriginallyDotOrIndex {
	was_originally_dot
	was_originally_index
}

fn (p &Parser) dot_or_mangled_prop_parse(target js_ast.Expr, name js_lexer.MaybeSubstring, name_loc logger.Loc, optional_chain js_ast.OptionalChain, original wasOriginallyDotOrIndex) js_ast.E {
	if (original != was_originally_index || p.options.mangle_quoted) && p.is_mangled_prop(name.string) {
		return &js_ast.EIndex{
			target:         target
			index:          js_ast.Expr{
				loc:  name_loc
				data: &js_ast.ENameOfSymbol{
					ref: p.store_name_in_ref(name)
				}
			}
			optional_chain: optional_chain
		}
	}
	return &js_ast.EDot{
		target:         target
		name:           name.string
		name_loc:       name_loc
		optional_chain: optional_chain
	}
}

fn (p &Parser) dot_or_mangled_prop_visit(target js_ast.Expr, name string, name_loc logger.Loc) js_ast.E {
	if p.is_mangled_prop(name) {
		return &js_ast.EIndex{
			target: target
			index:  js_ast.Expr{
				loc:  name_loc
				data: &js_ast.ENameOfSymbol{
					ref: p.symbol_for_mangled_prop(name)
				}
			}
		}
	}
	return &js_ast.EDot{
		target:   target
		name:     name
		name_loc: name_loc
	}
}

fn (p &Parser) parse_arrow_body(args []js_ast.Arg, data fnOrArrowDataParse) &js_ast.EArrow {
	mut arrow_loc := p.lexer.loc()
	if p.lexer.has_newline_before {
		p.log.add_error(&p.tracker, p.lexer.range(), 'Unexpected newline before "=>"')
		panic(js_lexer.LexerPanic{})
	}
	p.lexer.expect(js_lexer.te_quals_greater_than)
	for _, arg in args {
		p.declare_binding(ast.symbol_hoisted, arg.binding, ParseStmtOpts{})
	}
	data.is_this_disallowed = p.fn_or_arrow_data_parse.is_this_disallowed
	data.allow_super_call = p.fn_or_arrow_data_parse.allow_super_call
	data.allow_super_property = p.fn_or_arrow_data_parse.allow_super_property
	if p.lexer.token == js_lexer.to_pen_brace {
		mut body := p.parse_fn_body(data)
		p.after_arrow_body_loc = p.lexer.loc()
		return &js_ast.EArrow{
			args: args
			body: body
		}
	}
	p.push_scope_for_parse_pass(js_ast.scope_function_body, arrow_loc)
	defer {
		p.pop_scope
	}
	mut old_fn_or_arrow_data := p.fn_or_arrow_data_parse
	p.fn_or_arrow_data_parse = data
	mut expr := p.parse_expr(js_ast.lc_omma)
	p.fn_or_arrow_data_parse = old_fn_or_arrow_data
	return &js_ast.EArrow{
		args:        args
		prefer_expr: true
		body:        js_ast.FnBody{
			loc:   arrow_loc
			block: js_ast.SBlock{
				stmts: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				]
			}
		}
	}
}

fn (p &Parser) check_for_arrow_after_the_current_token() bool {
	mut old_lexer := p.lexer
	p.lexer.is_log_disabled = true
	defer {
		mut r := recover()
		_, is_lexer_panic := r
		if is_lexer_panic {
			p.lexer = old_lexer
		} else if r != nil {
			panic(r)
		}
	}
	p.lexer.next()
	mut is_arrow_after_this_token := p.lexer.token == js_lexer.te_quals_greater_than
	p.lexer = old_lexer
	return is_arrow_after_this_token
}

// This parses an expression. This assumes we've already parsed the "async"
// keyword and are currently looking at the following token.
fn (p &Parser) parse_async_prefix_expr(async_range logger.Range, level js_ast.L, flags exprFlag) js_ast.Expr {
	if !p.lexer.has_newline_before && p.lexer.token == js_lexer.tf_unction {
		return p.parse_fn_expr(async_range.loc, true, async_range)
	}
	if !p.lexer.has_newline_before && level < js_ast.lm_ember {
		match p.lexer.token {
			js_lexer.te_quals_greater_than {
				if level <= js_ast.la_ssign {
					mut arg := js_ast.Arg{
						binding: js_ast.Binding{
							loc:  async_range.loc
							data: &js_ast.BIdentifier{
								ref: p.store_name_in_ref(js_lexer.MaybeSubstring{
									string: 'async'
								})
							}
						}
					}
					p.push_scope_for_parse_pass(js_ast.scope_function_args, async_range.loc)
					defer {
						p.pop_scope
					}
					return js_ast.Expr{
						loc:  async_range.loc
						data: p.parse_arrow_body([arg], FnOrArrowDataParse{
							needs_async_loc: async_range.loc
						})
					}
				}
			}
			js_lexer.ti_dentifier {
				if level <= js_ast.la_ssign {
					mut is_arrow_fn := true
					if (flags & expr_flag_for_loop_init) != 0 && p.lexer.identifier.string == 'of' {
						is_arrow_fn = p.check_for_arrow_after_the_current_token()
						if !is_arrow_fn && (flags & expr_flag_for_await_loop_init) == 0 && p.lexer.raw() == 'of' {
							mut r := logger.Range{
								loc: async_range.loc
								len: p.lexer.range().end() - async_range.loc.start
							}
							p.log.add_error(&p.tracker, r, 'For loop initializers cannot start with "async of"')
							panic(js_lexer.LexerPanic{})
						}
					}
					if is_arrow_fn {
						p.mark_async_fn(async_range, false)
						mut ref := p.store_name_in_ref(p.lexer.identifier)
						mut arg_1 := js_ast.Arg{
							binding: js_ast.Binding{
								loc:  p.lexer.loc()
								data: &js_ast.BIdentifier{
									ref: ref
								}
							}
						}
						p.lexer.next()
						p.push_scope_for_parse_pass(js_ast.scope_function_args, async_range.loc)
						defer {
							p.pop_scope
						}
						mut arrow := p.parse_arrow_body([arg], FnOrArrowDataParse{
							needs_async_loc: arg.binding.loc
							await:           allow_expr
						})
						arrow.is_async = true
						return js_ast.Expr{
							loc:  async_range.loc
							data: arrow
						}
					}
				}
			}
			js_lexer.to_pen_paren {
				p.lexer.next()
				return p.parse_paren_expr(async_range.loc, level, ParenExprOpts{
					async_range: async_range
				})
			}
			js_lexer.tl_ess_than {
				if p.options.ts.parse && (!p.options.jsx.parse || p.is_tsa_rrow_fn_jsx()) {
					mut result := p.try_skip_type_script_type_parameters_then_open_paren_with_backtracking()
					if result != did_not_skip_anything {
						p.lexer.next()
						return p.parse_paren_expr(async_range.loc, level, ParenExprOpts{
							async_range:    async_range
							force_arrow_fn: result == definitely_type_parameters
						})
					}
				}
			}
		}
	}
	return js_ast.Expr{
		loc:  async_range.loc
		data: &js_ast.EIdentifier{
			ref: p.store_name_in_ref(js_lexer.MaybeSubstring{
				string: 'async'
			})
		}
	}
}

fn (p &Parser) parse_fn_expr(loc logger.Loc, is_async bool, async_range logger.Range) js_ast.Expr {
	p.lexer.next()
	mut is_generator := p.lexer.token == js_lexer.ta_sterisk
	mut has_error := false
	if is_async {
		has_error = p.mark_async_fn(async_range, is_generator)
	}
	if is_generator {
		if !has_error {
			p.mark_syntax_feature(compat.generator, p.lexer.range())
		}
		p.lexer.next()
	}
	mut name := 0
	p.push_scope_for_parse_pass(js_ast.scope_function_args, loc)
	defer {
		p.pop_scope
	}
	if p.lexer.token == js_lexer.ti_dentifier {
		name = &ast.LocRef{
			loc: p.lexer.loc()
		}
		mut text := p.lexer.identifier.string
		if text != 'arguments' {
			name.ref = p.declare_symbol(ast.symbol_hoisted_function, name.loc, text)
		} else {
			name.ref = p.new_symbol(ast.symbol_hoisted_function, text)
		}
		p.lexer.next()
	}
	if p.options.ts.parse {
		p.skip_type_script_type_parameters(allow_const_modifier)
	}
	mut await := allow_ident
	mut yield := allow_ident
	if is_async {
		await = allow_expr
	}
	if is_generator {
		yield = allow_expr
	}
	mut fn_, _ := p.parse_fn(name, logger.Range{}, 0, FnOrArrowDataParse{
		needs_async_loc: loc
		async_range:     async_range
		await:           await
		yield:           yield
	})
	p.validate_function_name(fn_, fn_expr)
	return js_ast.Expr{
		loc:  loc
		data: &js_ast.EFunction{
			fn_: fn_
		}
	}
}

struct parenExprOpts {
pub mut:
	async_range    logger.Range
	force_arrow_fn bool
}

// This assumes that the open parenthesis has already been parsed by the caller
fn (p &Parser) parse_paren_expr(loc logger.Loc, level js_ast.L, opts parenExprOpts) js_ast.Expr {
	mut items := []
	{}
	mut errors := DeferredErrors{}
	mut arrow_arg_errors := DeferredArrowArgErrors{}
	mut spread_range := logger.Range{}
	mut type_colon_range := logger.Range{}
	mut comma_after_spread := logger.Loc{}
	mut is_async := opts.async_range.len > 0
	mut scope_index := p.push_scope_for_parse_pass(js_ast.scope_function_args, loc)
	mut old_allow_in := p.allow_in
	p.allow_in = true
	mut old_fn_or_arrow_data := p.fn_or_arrow_data_parse
	p.fn_or_arrow_data_parse.arrow_arg_errors = &arrow_arg_errors
	for p.lexer.token != js_lexer.tc_lose_paren {
		mut item_loc := p.lexer.loc()
		mut is_spread := p.lexer.token == js_lexer.td_ot_dot_dot
		if is_spread {
			spread_range = p.lexer.range()
			p.mark_syntax_feature(compat.rest_argument, spread_range)
			p.lexer.next()
		}
		p.latest_arrow_arg_loc = p.lexer.loc()
		mut item := p.parse_expr_or_bindings(js_ast.lc_omma, &errors)
		if is_spread {
			item = js_ast.Expr{
				loc:  item_loc
				data: &js_ast.ESpread{
					value: item
				}
			}
		}
		if p.options.ts.parse && p.lexer.token == js_lexer.tc_olon {
			type_colon_range = p.lexer.range()
			p.lexer.next()
			p.skip_type_script_type(js_ast.ll_owest)
		}
		if p.options.ts.parse && p.lexer.token == js_lexer.te_quals && p.lexer.loc() != p.forbid_suffix_after_as_loc {
			p.lexer.next()
			item = js_ast.assign(item, p.parse_expr(js_ast.lc_omma))
		}
		items << item
		if p.lexer.token != js_lexer.tc_omma {
			break
		}
		if is_spread {
			comma_after_spread = p.lexer.loc()
		}
		p.lexer.next()
	}
	p.lexer.expect(js_lexer.tc_lose_paren)
	p.allow_in = old_allow_in
	p.fn_or_arrow_data_parse = old_fn_or_arrow_data
	if p.lexer.token == js_lexer.te_quals_greater_than || opts.force_arrow_fn
		|| p.options.ts.parse && p.lexer.token == js_lexer.tc_olon {
		if level > js_ast.la_ssign {
			p.lexer.unexpected()
		}
		mut invalidLog := 0
		mut args := []
		{}
		if is_async {
			p.mark_async_fn(opts.async_range, false)
		}
		for _, item_1 in items {
			mut is_spread_1 := false
			mut spread, ok := item.data
			if ok {
				item = spread.value
				is_spread = true
			}
			mut binding, initializer_or_nil, log := p.convert_expr_to_binding_and_initializer(item,
				invalid_log, is_spread)
			invalid_log = log
			args << js_ast.Arg{
				binding:        binding
				default_or_nil: initializer_or_nil
			}
		}
		if p.lexer.token == js_lexer.te_quals_greater_than
			|| invalid_log.invalid_tokens.len == 0
			&& p.try_skip_type_script_arrow_return_type_with_backtracking()
			|| opts.force_arrow_fn {
			if comma_after_spread.start != 0 {
				p.log.add_error(&p.tracker, logger.Range{
					loc: comma_after_spread
					len: 1
				}, 'Unexpected "," after rest pattern')
			}
			p.log_arrow_arg_errors(&arrow_arg_errors)
			p.log_deferred_arrow_arg_errors(&errors)
			if invalid_log.invalid_tokens.len > 0 {
				for _, token in invalid_log.invalid_tokens {
					p.log.add_error(&p.tracker, token, 'Invalid binding pattern')
				}
				panic(js_lexer.LexerPanic{})
			}
			for _, entry in invalid_log.syntax_features {
				p.mark_syntax_feature(entry.feature, entry.token)
			}
			mut await := allow_ident
			if is_async {
				await = allow_expr
			}
			mut arrow := p.parse_arrow_body(args, FnOrArrowDataParse{
				needs_async_loc: loc
				await:           await
			})
			arrow.is_async = is_async
			arrow.has_rest_arg = spread_range.len > 0
			p.pop_scope()
			return js_ast.Expr{
				loc:  loc
				data: arrow
			}
		}
	}
	p.pop_and_flatten_scope(scope_index)
	if type_colon_range.len > 0 {
		p.log.add_error(&p.tracker, type_colon_range, 'Unexpected ":"')
		panic(js_lexer.LexerPanic{})
	}
	if is_async {
		p.log_expr_errors(&errors)
		mut async := js_ast.Expr{
			loc:  loc
			data: &js_ast.EIdentifier{
				ref: p.store_name_in_ref(js_lexer.MaybeSubstring{
					string: 'async'
				})
			}
		}
		return js_ast.Expr{
			loc:  loc
			data: &js_ast.ECall{
				target: async
				args:   items
			}
		}
	}
	if items.len > 0 {
		p.log_expr_errors(&errors)
		if spread_range.len > 0 {
			p.log.add_error(&p.tracker, spread_range, 'Unexpected "..."')
			panic(js_lexer.LexerPanic{})
		}
		mut value := js_ast.join_all_with_comma(items)
		p.mark_expr_as_parenthesized(value, loc, is_async)
		return value
	}
	p.lexer.expected(js_lexer.te_quals_greater_than)
	return js_ast.Expr{}
}

struct invalidLog {
pub mut:
	invalid_tokens  []logger.Range
	syntax_features []syntaxFeature
}

struct syntaxFeature {
pub mut:
	feature compat.JSFeature
	token   logger.Range
}

fn (p &Parser) convert_expr_to_binding_and_initializer(expr js_ast.Expr, invalid_log invalidLog, is_spread bool) (js_ast.Binding, js_ast.Expr, invalidLog) {
	mut initializerOrNil := 0
	mut assign, ok := expr.data
	if ok && assign.op == js_ast.bin_op_assign {
		initializer_or_nil = assign.right
		expr = assign.left
	}
	mut binding, invalid_log_1 := p.convert_expr_to_binding(expr, invalid_log)
	if initializer_or_nil.data != nil {
		mut equals_range := p.source.range_of_operator_before(initializer_or_nil.loc,
			'=')
		if is_spread {
			p.log.add_error(&p.tracker, equals_range, 'A rest argument cannot have a default initializer')
		} else {
			invalid_log.syntax_features << SyntaxFeature{
				feature: compat.default_argument
				token:   equals_range
			}
		}
	}
	return binding, initializer_or_nil, invalid_log
}

// Note: do not write to "p.log" in this function. Any errors due to conversion
// from expression to binding should be written to "invalidLog" instead. That
// way we can potentially keep this as an expression if it turns out it's not
// needed as a binding after all.
fn (p &Parser) convert_expr_to_binding(expr js_ast.Expr, invalid_log invalidLog) (js_ast.Binding, invalidLog) {
	mut e := expr.data
	match e {
		js_ast.EMissing {
			return js_ast.Binding{
				loc:  expr.loc
				data: js_ast.bm_issing_shared
			}, invalid_log
		}
		js_ast.EIdentifier {
			return js_ast.Binding{
				loc:  expr.loc
				data: &js_ast.BIdentifier{
					ref: e.ref
				}
			}, invalid_log
		}
		js_ast.EArray {
			if e.comma_after_spread.start != 0 {
				invalid_log.invalid_tokens << logger.Range{
					loc: e.comma_after_spread
					len: 1
				}
			}
			invalid_log.syntax_features << SyntaxFeature{
				feature: compat.destructuring
				token:   p.source.range_of_operator_after(expr.loc, '[')
			}
			mut items := []
			{}
			mut is_spread := false
			for _, item in e.items {
				mut i, ok := item.data
				if ok {
					is_spread = true
					item = i.value
					_, ok_1 := item.data
					if !ok {
						p.mark_syntax_feature(compat.nested_rest_binding, p.source.range_of_operator_after(item.loc,
							'['))
					}
				}
				mut binding, initializer_or_nil, log := p.convert_expr_to_binding_and_initializer(item,
					invalid_log, is_spread)
				invalid_log = log
				items << js_ast.ArrayBinding{
					binding:              binding
					default_value_or_nil: initializer_or_nil
					loc:                  item.loc
				}
			}
			return js_ast.Binding{
				loc:  expr.loc
				data: &js_ast.BArray{
					items:             items
					has_spread:        is_spread
					is_single_line:    e.is_single_line
					close_bracket_loc: e.close_bracket_loc
				}
			}, invalid_log
		}
		js_ast.EObject {
			if e.comma_after_spread.start != 0 {
				invalid_log.invalid_tokens << logger.Range{
					loc: e.comma_after_spread
					len: 1
				}
			}
			invalid_log.syntax_features << SyntaxFeature{
				feature: compat.destructuring
				token:   p.source.range_of_operator_after(expr.loc, '{')
			}
			mut properties := []
			{}
			for _, property in e.properties {
				if property.kind.is_method_definition() {
					invalid_log.invalid_tokens << js_lexer.range_of_identifier(p.source,
						property.key.loc)
					continue
				}
				mut binding_1, initializer_or_nil_1, log_1 := p.convert_expr_to_binding_and_initializer(property.value_or_nil,
					invalid_log, false)
				invalid_log = log
				if initializer_or_nil.data == nil {
					initializer_or_nil = property.initializer_or_nil
				}
				properties << js_ast.PropertyBinding{
					loc:                  property.loc
					is_spread:            property.kind == js_ast.property_spread
					is_computed:          property.flags.has(js_ast.property_is_computed)
					key:                  property.key
					value:                binding
					default_value_or_nil: initializer_or_nil
				}
			}
			return js_ast.Binding{
				loc:  expr.loc
				data: &js_ast.BObject{
					properties:      properties
					is_single_line:  e.is_single_line
					close_brace_loc: e.close_brace_loc
				}
			}, invalid_log
		}
		else {
			invalid_log.invalid_tokens << logger.Range{
				loc: expr.loc
			}
			return js_ast.Binding{}, invalid_log
		}
	}
}

fn (p &Parser) save_expr_comments_here() logger.Loc {
	mut loc := p.lexer.loc()
	if p.expr_comments != nil && p.lexer.comments_before_token.len > 0 {
		mut comments := []string{len: p.lexer.CommentsBeforeToken.len}
		for i, comment in p.lexer.comments_before_token {
			comments[i] = p.source.comment_text_without_indent(comment)
		}
		p.expr_comments[loc] = comments
		p.lexer.comments_before_token = p.lexer.comments_before_token[0..]
	}
	return loc
}

type exprFlag = u8

const expr_flag_decorator = 1 << iota
const expr_flag_for_loop_init = 2 << iota
const expr_flag_for_await_loop_init = 3 << iota

fn (p &Parser) parse_prefix(level js_ast.L, errors &DeferredErrors, flags exprFlag) js_ast.Expr {
	mut loc := p.save_expr_comments_here()
	match p.lexer.token {
		js_lexer.ts_uper {
			mut super_range := p.lexer.range()
			p.lexer.next()
			match p.lexer.token {
				js_lexer.to_pen_paren {
					if level < js_ast.lc_all && p.fn_or_arrow_data_parse.allow_super_call {
						return js_ast.Expr{
							loc:  loc
							data: js_ast.es_uper_shared
						}
					}
				}
				js_lexer.td_ot, js_lexer.to_pen_bracket {
					if p.fn_or_arrow_data_parse.allow_super_property {
						return js_ast.Expr{
							loc:  loc
							data: js_ast.es_uper_shared
						}
					}
				}
			}
			p.log.add_error(&p.tracker, super_range, 'Unexpected "super"')
			return js_ast.Expr{
				loc:  loc
				data: js_ast.es_uper_shared
			}
		}
		js_lexer.to_pen_paren {
			if errors != nil {
				errors.invalid_parens << p.lexer.range()
			}
			p.lexer.next()
			if level > js_ast.la_ssign {
				mut old_allow_in := p.allow_in
				p.allow_in = true
				mut value := p.parse_expr(js_ast.ll_owest)
				p.mark_expr_as_parenthesized(value, loc, false)
				p.lexer.expect(js_lexer.tc_lose_paren)
				p.allow_in = old_allow_in
				return value
			}
			mut value_1 := p.parse_paren_expr(loc, level, ParenExprOpts{})
			return value
		}
		js_lexer.tf_alse {
			p.lexer.next()
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EBoolean{
					value: false
				}
			}
		}
		js_lexer.tt_rue {
			p.lexer.next()
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EBoolean{
					value: true
				}
			}
		}
		js_lexer.tn_ull {
			p.lexer.next()
			return js_ast.Expr{
				loc:  loc
				data: js_ast.en_ull_shared
			}
		}
		js_lexer.tt_his {
			if p.fn_or_arrow_data_parse.is_this_disallowed {
				p.log.add_error(&p.tracker, p.lexer.range(), 'Cannot use "this" here:')
			}
			p.lexer.next()
			return js_ast.Expr{
				loc:  loc
				data: js_ast.et_his_shared
			}
		}
		js_lexer.tp_rivate_identifier {
			if !p.allow_private_identifiers || !p.allow_in || level >= js_ast.lc_ompare {
				p.lexer.unexpected()
			}
			mut name := p.lexer.identifier
			p.lexer.next()
			if p.lexer.token != js_lexer.ti_n {
				p.lexer.expected(js_lexer.ti_n)
			}
			if p.options.unsupported_jsf_eatures.has(compat.class_private_brand_check) {
				if p.lower_all_of_these_private_names == nil {
					p.lower_all_of_these_private_names = map[string]Bool{}
				}
				p.lower_all_of_these_private_names[name.string] = true
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EPrivateIdentifier{
					ref: p.store_name_in_ref(name)
				}
			}
		}
		js_lexer.ti_dentifier {
			mut name_1 := p.lexer.identifier
			mut name_range := p.lexer.range()
			mut raw := p.lexer.raw()
			p.lexer.next()
			match name.string {
				'async' {
					if raw == 'async' {
						return p.parse_async_prefix_expr(name_range, level, flags)
					}
				}
				'await' {
					match p.fn_or_arrow_data_parse.await {
						forbid_all {
							p.log.add_error(&p.tracker, name_range, 'The keyword "await" cannot be used here:')
						}
						allow_expr {
							if raw != 'await' {
								p.log.add_error(&p.tracker, name_range, 'The keyword "await" cannot be escaped')
							}
							else {
								if p.fn_or_arrow_data_parse.is_top_level {
									p.top_level_await_keyword = name_range
								}
								if p.fn_or_arrow_data_parse.arrow_arg_errors != nil {
									p.fn_or_arrow_data_parse.arrow_arg_errors.invalid_expr_await = name_range
								}
								mut value_2 := p.parse_expr(js_ast.lp_refix)
								if p.lexer.token == js_lexer.ta_sterisk_asterisk {
									p.lexer.unexpected()
								}
								return js_ast.Expr{
									loc:  loc
									data: &js_ast.EAwait{
										value: value
									}
								}
							}
						}
						allow_ident {
							p.lexer.prev_token_was_await_keyword = true
							p.lexer.await_keyword_loc = loc
							p.lexer.fn_or_arrow_start_loc = p.fn_or_arrow_data_parse.needs_async_loc
						}
					}
				}
				'yield' {
					match p.fn_or_arrow_data_parse.yield {
						forbid_all {
							p.log.add_error(&p.tracker, name_range, 'The keyword "yield" cannot be used here:')
						}
						allow_expr {
							if raw != 'yield' {
								p.log.add_error(&p.tracker, name_range, 'The keyword "yield" cannot be escaped')
							}
							else {
								if level > js_ast.la_ssign {
									p.log.add_error(&p.tracker, name_range, 'Cannot use a "yield" expression here without parentheses:')
								}
								if p.fn_or_arrow_data_parse.arrow_arg_errors != nil {
									p.fn_or_arrow_data_parse.arrow_arg_errors.invalid_expr_yield = name_range
								}
								return p.parse_yield_expr(loc)
							}
						}
						allow_ident {
							if !p.lexer.has_newline_before {
								match p.lexer.token {
									js_lexer.tn_ull, js_lexer.ti_dentifier, js_lexer.tf_alse,
									js_lexer.tt_rue, js_lexer.tn_umeric_literal,
									js_lexer.tb_ig_integer_literal, js_lexer.ts_tring_literal {
										p.log.add_error(&p.tracker, name_range, 'Cannot use "yield" outside a generator function')
										return p.parse_yield_expr(loc)
									}
								}
							}
						}
					}
				}
			}
			if p.lexer.token == js_lexer.te_quals_greater_than && level <= js_ast.la_ssign {
				mut ref := p.store_name_in_ref(name)
				mut arg := js_ast.Arg{
					binding: js_ast.Binding{
						loc:  loc
						data: &js_ast.BIdentifier{
							ref: ref
						}
					}
				}
				p.push_scope_for_parse_pass(js_ast.scope_function_args, loc)
				defer {
					p.pop_scope
				}
				return js_ast.Expr{
					loc:  loc
					data: p.parse_arrow_body([arg], FnOrArrowDataParse{
						needs_async_loc: loc
					})
				}
			}
			mut ref_1 := p.store_name_in_ref(name)
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EIdentifier{
					ref: ref
				}
			}
		}
		js_lexer.ts_tring_literal, js_lexer.tn_o_substitution_template_literal {
			return p.parse_string_literal()
		}
		js_lexer.tt_emplate_head {
			mut legacyOctalLoc := 0
			mut head_loc := p.lexer.loc()
			mut head := p.lexer.string_literal()
			if p.lexer.legacy_octal_loc.start > loc.start {
				legacy_octal_loc = p.lexer.legacy_octal_loc
			}
			mut parts, tail_legacy_octal_loc := p.parse_template_parts(false)
			if tail_legacy_octal_loc.start > 0 {
				legacy_octal_loc = tail_legacy_octal_loc
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.ETemplate{
					head_loc:         head_loc
					head_cooked:      head
					parts:            parts
					legacy_octal_loc: legacy_octal_loc
				}
			}
		}
		js_lexer.tn_umeric_literal {
			mut value_3 := js_ast.Expr{
				loc:  loc
				data: &js_ast.ENumber{
					value: p.lexer.number
				}
			}
			p.check_for_legacy_octal_literal(value.data)
			p.lexer.next()
			return value
		}
		js_lexer.tb_ig_integer_literal {
			mut value_4 := p.lexer.identifier
			p.mark_syntax_feature(compat.bigint, p.lexer.range())
			p.lexer.next()
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EBigInt{
					value: value.string
				}
			}
		}
		js_lexer.ts_lash, js_lexer.ts_lash_equals {
			p.lexer.scan_reg_exp()
			mut value_5 := p.lexer.raw()
			p.lexer.next()
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.ERegExp{
					value: value
				}
			}
		}
		js_lexer.tv_oid {
			p.lexer.next()
			mut value_6 := p.parse_expr(js_ast.lp_refix)
			if p.lexer.token == js_lexer.ta_sterisk_asterisk {
				p.lexer.unexpected()
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EUnary{
					op:    js_ast.un_op_void
					value: value
				}
			}
		}
		js_lexer.tt_ypeof {
			p.lexer.next()
			mut value_7 := p.parse_expr(js_ast.lp_refix)
			if p.lexer.token == js_lexer.ta_sterisk_asterisk {
				p.lexer.unexpected()
			}
			_, value_is_identifier := value.data
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EUnary{
					op:                               js_ast.un_op_typeof
					value:                            value
					was_originally_typeof_identifier: value_is_identifier
				}
			}
		}
		js_lexer.td_elete {
			p.lexer.next()
			mut value_8 := p.parse_expr(js_ast.lp_refix)
			if p.lexer.token == js_lexer.ta_sterisk_asterisk {
				p.lexer.unexpected()
			}
			mut index, ok := value.data
			if ok {
				mut private, ok_1 := index.index.data
				if ok {
					mut name_2 := p.load_name_from_ref(private.ref)
					mut r := logger.Range{
						loc: index.index.loc
						len: i32(name.len)
					}
					p.log.add_error(&p.tracker, r, strconv.v_sprintf('Deleting the private name %q is forbidden',
						name))
				}
			}
			_, value_is_identifier_1 := value.data
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EUnary{
					op:                                                     js_ast.un_op_delete
					value:                                                  value
					was_originally_delete_of_identifier_or_property_access: value_is_identifier
						|| js_ast.is_property_access(value)
				}
			}
		}
		js_lexer.tp_lus {
			p.lexer.next()
			mut value_9 := p.parse_expr(js_ast.lp_refix)
			if p.lexer.token == js_lexer.ta_sterisk_asterisk {
				p.lexer.unexpected()
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EUnary{
					op:    js_ast.un_op_pos
					value: value
				}
			}
		}
		js_lexer.tm_inus {
			p.lexer.next()
			mut value_10 := p.parse_expr(js_ast.lp_refix)
			if p.lexer.token == js_lexer.ta_sterisk_asterisk {
				p.lexer.unexpected()
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EUnary{
					op:    js_ast.un_op_neg
					value: value
				}
			}
		}
		js_lexer.tt_ilde {
			p.lexer.next()
			mut value_11 := p.parse_expr(js_ast.lp_refix)
			if p.lexer.token == js_lexer.ta_sterisk_asterisk {
				p.lexer.unexpected()
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EUnary{
					op:    js_ast.un_op_cpl
					value: value
				}
			}
		}
		js_lexer.te_xclamation {
			p.lexer.next()
			mut value_12 := p.parse_expr(js_ast.lp_refix)
			if p.lexer.token == js_lexer.ta_sterisk_asterisk {
				p.lexer.unexpected()
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EUnary{
					op:    js_ast.un_op_not
					value: value
				}
			}
		}
		js_lexer.tm_inus_minus {
			p.lexer.next()
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EUnary{
					op:    js_ast.un_op_pre_dec
					value: p.parse_expr(js_ast.lp_refix)
				}
			}
		}
		js_lexer.tp_lus_plus {
			p.lexer.next()
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EUnary{
					op:    js_ast.un_op_pre_inc
					value: p.parse_expr(js_ast.lp_refix)
				}
			}
		}
		js_lexer.tf_unction {
			return p.parse_fn_expr(loc, false, logger.Range{})
		}
		js_lexer.tc_lass {
			return p.parse_class_expr(nil)
		}
		js_lexer.ta_t {
			mut decorators := p.parse_decorators(p.current_scope, logger.Range{}, decorator_before_class_expr)
			return p.parse_class_expr(decorators)
		}
		js_lexer.tn_ew {
			p.lexer.next()
			if p.lexer.token == js_lexer.td_ot {
				p.lexer.next()
				if p.lexer.token != js_lexer.ti_dentifier || p.lexer.raw() != 'target' {
					p.lexer.unexpected()
				}
				mut r_1 := logger.Range{
					loc: loc
					len: p.lexer.range().end() - loc.start
				}
				p.mark_syntax_feature(compat.new_target, r)
				p.lexer.next()
				return js_ast.Expr{
					loc:  loc
					data: &js_ast.ENewTarget{
						range: r
					}
				}
			}
			mut target := p.parse_expr_with_flags(js_ast.lm_ember, flags)
			mut args := []
			{}
			mut closeParenLoc := 0
			mut isMultiLine := 0
			if p.lexer.token == js_lexer.to_pen_paren {
				args, close_paren_loc, is_multi_line = p.parse_call_args()
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.ENew{
					target:          target
					args:            args
					close_paren_loc: close_paren_loc
					is_multi_line:   is_multi_line
				}
			}
		}
		js_lexer.to_pen_bracket {
			p.lexer.next()
			mut is_single_line := !p.lexer.has_newline_before
			mut items := []
			{}
			mut self_errors := DeferredErrors{}
			mut comma_after_spread := logger.Loc{}
			mut old_allow_in_1 := p.allow_in
			p.allow_in = true
			for p.lexer.token != js_lexer.tc_lose_bracket {
				match p.lexer.token {
					js_lexer.tc_omma {
						items << js_ast.Expr{
							loc:  p.lexer.loc()
							data: js_ast.em_issing_shared
						}
					}
					js_lexer.td_ot_dot_dot {
						if errors != nil {
							errors.array_spread_feature = p.lexer.range()
						} else {
							p.mark_syntax_feature(compat.array_spread, p.lexer.range())
						}
						mut dots_loc := p.save_expr_comments_here()
						p.lexer.next()
						mut item := p.parse_expr_or_bindings(js_ast.lc_omma, &self_errors)
						items << js_ast.Expr{
							loc:  dots_loc
							data: &js_ast.ESpread{
								value: item
							}
						}
						if p.lexer.token == js_lexer.tc_omma {
							comma_after_spread = p.lexer.loc()
						}
					}
					else {
						mut item_1 := p.parse_expr_or_bindings(js_ast.lc_omma, &self_errors)
						items << item
					}
				}
				if p.lexer.token != js_lexer.tc_omma {
					break
				}
				if p.lexer.has_newline_before {
					is_single_line = false
				}
				p.lexer.next()
				if p.lexer.has_newline_before {
					is_single_line = false
				}
			}
			if p.lexer.has_newline_before {
				is_single_line = false
			}
			mut close_bracket_loc := p.save_expr_comments_here()
			p.lexer.expect(js_lexer.tc_lose_bracket)
			p.allow_in = old_allow_in
			if p.will_need_binding_pattern() {
			} else if errors == nil {
				p.log_expr_errors(&self_errors)
			} else {
				self_errors.merge_into(errors)
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EArray{
					items:              items
					comma_after_spread: comma_after_spread
					is_single_line:     is_single_line
					close_bracket_loc:  close_bracket_loc
				}
			}
		}
		js_lexer.to_pen_brace {
			p.lexer.next()
			mut is_single_line_1 := !p.lexer.has_newline_before
			mut properties := []
			{}
			mut self_errors_1 := DeferredErrors{}
			mut comma_after_spread_1 := logger.Loc{}
			mut old_allow_in_2 := p.allow_in
			p.allow_in = true
			for p.lexer.token != js_lexer.tc_lose_brace {
				if p.lexer.token == js_lexer.td_ot_dot_dot {
					mut dot_loc := p.save_expr_comments_here()
					p.lexer.next()
					mut value_13 := p.parse_expr_or_bindings(js_ast.lc_omma, &self_errors)
					properties << js_ast.Property{
						kind:         js_ast.property_spread
						loc:          dot_loc
						value_or_nil: value
					}
					if p.lexer.token == js_lexer.tc_omma {
						comma_after_spread = p.lexer.loc()
					}
				}
				else {
					mut property, ok_2 := p.parse_property(p.save_expr_comments_here(),
						js_ast.property_field, PropertyOpts{}, &self_errors)
					if ok {
						properties << property
					}
				}
				if p.lexer.token != js_lexer.tc_omma {
					break
				}
				if p.lexer.has_newline_before {
					is_single_line = false
				}
				p.lexer.next()
				if p.lexer.has_newline_before {
					is_single_line = false
				}
			}
			if p.lexer.has_newline_before {
				is_single_line = false
			}
			mut close_brace_loc := p.save_expr_comments_here()
			p.lexer.expect(js_lexer.tc_lose_brace)
			p.allow_in = old_allow_in
			if p.will_need_binding_pattern() {
			} else if errors == nil {
				p.log_expr_errors(&self_errors)
			} else {
				self_errors.merge_into(errors)
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EObject{
					properties:         properties
					comma_after_spread: comma_after_spread
					is_single_line:     is_single_line
					close_brace_loc:    close_brace_loc
				}
			}
		}
		js_lexer.tl_ess_than {
			if p.options.ts.parse && p.options.jsx.parse && p.is_tsa_rrow_fn_jsx() {
				p.skip_type_script_type_parameters(allow_const_modifier)
				p.lexer.expect(js_lexer.to_pen_paren)
				return p.parse_paren_expr(loc, level, ParenExprOpts{
					force_arrow_fn: true
				})
			}
			if !p.options.jsx.parse && !p.options.ts.parse {
				mut how := 0
				match logger.api {
					logger.cliapi {
						how = ' You can use "--loader:.js=jsx" to do that.'
					}
					logger.jsapi {
						how = ' You can use "loader: { \'.js\': \'jsx\' }" to do that.'
					}
					logger.go_api {
						how = ' You can use \'Loader: map[string]api.Loader{".js": api.LoaderJSX}\' to do that.'
					}
				}
				p.log.add_error_with_notes(&p.tracker, p.lexer.range(), 'The JSX syntax extension is not currently enabled',
					[// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				])
				p.options.jsx.parse = true
			}
			if p.options.jsx.parse {
				p.lexer.next_inside_jsxe_lement()
				mut element := p.parse_jsxe_lement(loc)
				p.lexer.next()
				return element
			}
			if p.options.ts.parse {
				if p.options.ts.no_ambiguous_less_than && !p.is_tsa_rrow_fn_jsx() {
					p.log.add_error(&p.tracker, p.lexer.range(), 'This syntax is not allowed in files with the ".mts" or ".cts" extension')
				}
				mut result := p.try_skip_type_script_type_parameters_then_open_paren_with_backtracking()
				if result != did_not_skip_anything {
					p.lexer.expect(js_lexer.to_pen_paren)
					return p.parse_paren_expr(loc, level, ParenExprOpts{
						force_arrow_fn: result == definitely_type_parameters
					})
				}
				p.lexer.next()
				p.skip_type_script_type(js_ast.ll_owest)
				p.lexer.expect_greater_than(false)
				mut value_14 := p.parse_prefix(level, errors, flags)
				return value
			}
			p.lexer.unexpected()
			return js_ast.Expr{}
		}
		js_lexer.ti_mport {
			p.lexer.next()
			return p.parse_import_expr(loc, level)
		}
		else {
			p.lexer.unexpected()
			return js_ast.Expr{}
		}
	}
}

fn (p &Parser) parse_yield_expr(loc logger.Loc) js_ast.Expr {
	mut is_star := p.lexer.token == js_lexer.ta_sterisk
	if is_star && !p.lexer.has_newline_before {
		p.lexer.next()
	}
	mut valueOrNil := 0
	if is_star {
		value_or_nil = p.parse_expr(js_ast.ly_ield)
	} else {
		match p.lexer.token {
			js_lexer.tc_lose_brace, js_lexer.tc_lose_bracket, js_lexer.tc_lose_paren,
			js_lexer.tc_olon, js_lexer.tc_omma, js_lexer.ts_emicolon {}
			else {
				if !p.lexer.has_newline_before {
					value_or_nil = p.parse_expr(js_ast.ly_ield)
				}
			}
		}
	}
	return js_ast.Expr{
		loc:  loc
		data: &js_ast.EYield{
			value_or_nil: value_or_nil
			is_star:      is_star
		}
	}
}

fn (p &Parser) will_need_binding_pattern() bool {
	match p.lexer.token {
		js_lexer.te_quals {
			return true
		}
		js_lexer.ti_n {
			return !p.allow_in
		}
		js_lexer.ti_dentifier {
			return !p.allow_in && p.lexer.is_contextual_keyword('of')
		}
		else {
			return false
		}
	}
}

// Note: The caller has already parsed the "import" keyword
fn (p &Parser) parse_import_expr(loc logger.Loc, level js_ast.L) js_ast.Expr {
	if p.lexer.token == js_lexer.td_ot {
		p.lexer.next()
		if !p.lexer.is_contextual_keyword('meta') {
			p.lexer.expected_string('"meta"')
		}
		p.esm_import_meta = logger.Range{
			loc: loc
			len: p.lexer.range().end() - loc.start
		}
		p.lexer.next()
		return js_ast.Expr{
			loc:  loc
			data: &js_ast.EImportMeta{
				range_len: p.esm_import_meta.len
			}
		}
	}
	if level > js_ast.lc_all {
		mut r := js_lexer.range_of_identifier(p.source, loc)
		p.log.add_error(&p.tracker, r, 'Cannot use an "import" expression here without parentheses:')
	}
	mut old_allow_in := p.allow_in
	p.allow_in = true
	p.lexer.expect(js_lexer.to_pen_paren)
	mut value := p.parse_expr(js_ast.lc_omma)
	mut optionsOrNil := 0
	if p.lexer.token == js_lexer.tc_omma {
		p.lexer.next()
		if p.lexer.token != js_lexer.tc_lose_paren {
			options_or_nil = p.parse_expr(js_ast.lc_omma)
			if p.lexer.token == js_lexer.tc_omma {
				p.lexer.next()
			}
		}
	}
	mut close_paren_loc := p.save_expr_comments_here()
	p.lexer.expect(js_lexer.tc_lose_paren)
	p.allow_in = old_allow_in
	return js_ast.Expr{
		loc:  loc
		data: &js_ast.EImportCall{
			expr:            value
			options_or_nil:  options_or_nil
			close_paren_loc: close_paren_loc
		}
	}
}

fn (p &Parser) parse_expr_or_bindings(level js_ast.L, errors &DeferredErrors) js_ast.Expr {
	return p.parse_expr_common(level, errors, 0)
}

fn (p &Parser) parse_expr(level js_ast.L) js_ast.Expr {
	return p.parse_expr_common(level, nil, 0)
}

fn (p &Parser) parse_expr_with_flags(level js_ast.L, flags exprFlag) js_ast.Expr {
	return p.parse_expr_common(level, nil, flags)
}

fn (p &Parser) parse_expr_common(level js_ast.L, errors &DeferredErrors, flags exprFlag) js_ast.Expr {
	mut lexer_comment_flags := p.lexer.has_comment_before
	mut expr := p.parse_prefix(level, errors, flags)
	if (lexer_comment_flags & (js_lexer.pure_comment_before | js_lexer.no_side_effects_comment_before)) != 0
		&& !p.options.ignore_dcea_nnotations {
		if (lexer_comment_flags & js_lexer.no_side_effects_comment_before) != 0 {
			mut e := expr.data
			match e {
				js_ast.EArrow {
					e.has_no_side_effects_comment = true
				}
				js_ast.EFunction {
					e.fn_.has_no_side_effects_comment = true
				}
			}
		}
		if (lexer_comment_flags & js_lexer.pure_comment_before) != 0 && level < js_ast.lc_all {
			expr = p.parse_suffix(expr, js_ast.lc_all - 1, errors, flags)
			mut e_1 := expr.data
			match e {
				js_ast.ECall {
					e.can_be_unwrapped_if_unused = true
				}
				js_ast.ENew {
					e.can_be_unwrapped_if_unused = true
				}
			}
		}
	}
	return p.parse_suffix(expr, level, errors, flags)
}

fn (p &Parser) parse_suffix(left js_ast.Expr, level js_ast.L, errors &DeferredErrors, flags exprFlag) js_ast.Expr {
	mut optional_chain := js_ast.optional_chain_none
	for {
		if p.lexer.loc() == p.after_arrow_body_loc {
			for {
				match p.lexer.token {
					js_lexer.tc_omma {
						if level >= js_ast.lc_omma {
							return left
						}
						p.lexer.next()
						left = js_ast.Expr{
							loc:  left.loc
							data: &js_ast.EBinary{
								op:    js_ast.bin_op_comma
								left:  left
								right: p.parse_expr(js_ast.lc_omma)
							}
						}
					}
					else {
						return left
					}
				}
			}
		}
		if p.lexer.loc() == p.forbid_suffix_after_as_loc {
			return left
		}
		mut old_optional_chain := optional_chain
		optional_chain = js_ast.optional_chain_none
		match p.lexer.token {
			js_lexer.td_ot {
				p.lexer.next()
				if p.lexer.token == js_lexer.tp_rivate_identifier && p.allow_private_identifiers {
					_, ok := left.data
					if ok {
						p.lexer.expected(js_lexer.ti_dentifier)
					}
					mut name := p.lexer.identifier
					mut name_loc := p.lexer.loc()
					p.report_private_name_usage(name.string)
					p.lexer.next()
					mut ref := p.store_name_in_ref(name)
					left = js_ast.Expr{
						loc:  left.loc
						data: &js_ast.EIndex{
							target:         left
							index:          js_ast.Expr{
								loc:  name_loc
								data: &js_ast.EPrivateIdentifier{
									ref: ref
								}
							}
							optional_chain: old_optional_chain
						}
					}
				}
				else {
					if !p.lexer.is_identifier_or_keyword() {
						p.lexer.expect(js_lexer.ti_dentifier)
					}
					mut name_1 := p.lexer.identifier
					mut name_loc_1 := p.lexer.loc()
					p.lexer.next()
					left = js_ast.Expr{
						loc:  left.loc
						data: p.dot_or_mangled_prop_parse(left, name, name_loc, old_optional_chain,
							was_originally_dot)
					}
				}
				optional_chain = old_optional_chain
			}
			js_lexer.tq_uestion_dot {
				p.lexer.next()
				mut optional_start := js_ast.optional_chain_start
				if p.options.minify_syntax {
					mut is_null_or_undefined, _, ok_1 := js_ast.to_null_or_undefined_with_side_effects(left.data)
					if ok && !is_null_or_undefined {
						optional_start = js_ast.optional_chain_none
					}
				}
				match p.lexer.token {
					js_lexer.to_pen_bracket {
						p.lexer.next()
						mut old_allow_in := p.allow_in
						p.allow_in = true
						mut index := p.parse_expr(js_ast.ll_owest)
						p.allow_in = old_allow_in
						mut close_bracket_loc := p.save_expr_comments_here()
						p.lexer.expect(js_lexer.tc_lose_bracket)
						left = js_ast.Expr{
							loc:  left.loc
							data: &js_ast.EIndex{
								target:            left
								index:             index
								optional_chain:    optional_start
								close_bracket_loc: close_bracket_loc
							}
						}
					}
					js_lexer.to_pen_paren {
						if level >= js_ast.lc_all {
							return left
						}
						mut kind := js_ast.normal_call
						if js_ast.is_property_access(left) {
							kind = js_ast.target_was_originally_property_access
						}
						mut args, close_paren_loc, is_multi_line := p.parse_call_args()
						left = js_ast.Expr{
							loc:  left.loc
							data: &js_ast.ECall{
								target:          left
								args:            args
								close_paren_loc: close_paren_loc
								optional_chain:  optional_start
								is_multi_line:   is_multi_line
								kind:            kind
							}
						}
					}
					js_lexer.tl_ess_than, js_lexer.tl_ess_than_less_than {
						if !p.options.ts.parse {
							p.lexer.expected(js_lexer.ti_dentifier)
						}
						p.skip_type_script_type_arguments(SkipTypeScriptTypeArgumentsOpts{})
						if p.lexer.token != js_lexer.to_pen_paren {
							p.lexer.expected(js_lexer.to_pen_paren)
						}
						if level >= js_ast.lc_all {
							return left
						}
						mut kind_1 := js_ast.normal_call
						if js_ast.is_property_access(left) {
							kind = js_ast.target_was_originally_property_access
						}
						mut args_1, close_paren_loc_1, is_multi_line_1 := p.parse_call_args()
						left = js_ast.Expr{
							loc:  left.loc
							data: &js_ast.ECall{
								target:          left
								args:            args
								close_paren_loc: close_paren_loc
								optional_chain:  optional_start
								is_multi_line:   is_multi_line
								kind:            kind
							}
						}
					}
					else {
						if p.lexer.token == js_lexer.tp_rivate_identifier && p.allow_private_identifiers {
							mut name_2 := p.lexer.identifier
							mut name_loc_2 := p.lexer.loc()
							p.report_private_name_usage(name.string)
							p.lexer.next()
							mut ref_1 := p.store_name_in_ref(name)
							left = js_ast.Expr{
								loc:  left.loc
								data: &js_ast.EIndex{
									target:         left
									index:          js_ast.Expr{
										loc:  name_loc
										data: &js_ast.EPrivateIdentifier{
											ref: ref
										}
									}
									optional_chain: optional_start
								}
							}
						}
						else {
							if !p.lexer.is_identifier_or_keyword() {
								p.lexer.expect(js_lexer.ti_dentifier)
							}
							mut name_3 := p.lexer.identifier
							mut name_loc_3 := p.lexer.loc()
							p.lexer.next()
							left = js_ast.Expr{
								loc:  left.loc
								data: p.dot_or_mangled_prop_parse(left, name, name_loc,
									optional_start, was_originally_dot)
							}
						}
					}
				}
				if optional_start == js_ast.optional_chain_start {
					optional_chain = js_ast.optional_chain_continue
				}
			}
			js_lexer.tn_o_substitution_template_literal {
				if old_optional_chain != js_ast.optional_chain_none {
					p.log.add_error(&p.tracker, p.lexer.range(), 'Template literals cannot have an optional chain as a tag')
				}
				mut head_loc := p.lexer.loc()
				mut head_cooked, head_raw := p.lexer.cooked_and_raw_template_contents()
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.ETemplate{
						tag_or_nil:                         left
						head_loc:                           head_loc
						head_cooked:                        head_cooked
						head_raw:                           head_raw
						tag_was_originally_property_access: js_ast.is_property_access(left)
					}
				}
			}
			js_lexer.tt_emplate_head {
				if old_optional_chain != js_ast.optional_chain_none {
					p.log.add_error(&p.tracker, p.lexer.range(), 'Template literals cannot have an optional chain as a tag')
				}
				mut head_loc_1 := p.lexer.loc()
				mut head_cooked_1, head_raw_1 := p.lexer.cooked_and_raw_template_contents()
				mut parts, _ := p.parse_template_parts(true)
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.ETemplate{
						tag_or_nil:                         left
						head_loc:                           head_loc
						head_cooked:                        head_cooked
						head_raw:                           head_raw
						parts:                              parts
						tag_was_originally_property_access: js_ast.is_property_access(left)
					}
				}
			}
			js_lexer.to_pen_bracket {
				if (flags & expr_flag_decorator) != 0 {
					return left
				}
				p.lexer.next()
				mut old_allow_in_1 := p.allow_in
				p.allow_in = true
				mut index_1 := p.parse_expr(js_ast.ll_owest)
				p.allow_in = old_allow_in
				mut close_bracket_loc_1 := p.save_expr_comments_here()
				p.lexer.expect(js_lexer.tc_lose_bracket)
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EIndex{
						target:            left
						index:             index
						optional_chain:    old_optional_chain
						close_bracket_loc: close_bracket_loc
					}
				}
				optional_chain = old_optional_chain
			}
			js_lexer.to_pen_paren {
				if level >= js_ast.lc_all {
					return left
				}
				mut kind_2 := js_ast.normal_call
				if js_ast.is_property_access(left) {
					kind = js_ast.target_was_originally_property_access
				}
				mut args_2, close_paren_loc_2, is_multi_line_2 := p.parse_call_args()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.ECall{
						target:          left
						args:            args
						close_paren_loc: close_paren_loc
						optional_chain:  old_optional_chain
						is_multi_line:   is_multi_line
						kind:            kind
					}
				}
				optional_chain = old_optional_chain
			}
			js_lexer.tq_uestion {
				if level >= js_ast.lc_onditional {
					return left
				}
				p.lexer.next()
				if p.options.ts.parse && left.loc == p.latest_arrow_arg_loc && (
					p.lexer.token == js_lexer.tc_olon || p.lexer.token == js_lexer.tc_lose_paren
					|| p.lexer.token == js_lexer.tc_omma) {
					if errors == nil {
						p.lexer.unexpected()
					}
					errors.invalid_expr_after_question = p.lexer.range()
					return left
				}
				mut old_allow_in_2 := p.allow_in
				p.allow_in = true
				mut yes := p.parse_expr(js_ast.lc_omma)
				p.allow_in = old_allow_in
				p.lexer.expect(js_lexer.tc_olon)
				mut no := p.parse_expr(js_ast.lc_omma)
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EIf{
						test: left
						yes:  yes
						no:   no
					}
				}
			}
			js_lexer.te_xclamation {
				if p.lexer.has_newline_before {
					return left
				}
				if !p.options.ts.parse {
					p.lexer.unexpected()
				}
				p.lexer.next()
				optional_chain = old_optional_chain
			}
			js_lexer.tm_inus_minus {
				if p.lexer.has_newline_before || level >= js_ast.lp_ostfix {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EUnary{
						op:    js_ast.un_op_post_dec
						value: left
					}
				}
			}
			js_lexer.tp_lus_plus {
				if p.lexer.has_newline_before || level >= js_ast.lp_ostfix {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EUnary{
						op:    js_ast.un_op_post_inc
						value: left
					}
				}
			}
			js_lexer.tc_omma {
				if level >= js_ast.lc_omma {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_comma
						left:  left
						right: p.parse_expr(js_ast.lc_omma)
					}
				}
			}
			js_lexer.tp_lus {
				if level >= js_ast.la_dd {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_add
						left:  left
						right: p.parse_expr(js_ast.la_dd)
					}
				}
			}
			js_lexer.tp_lus_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_add_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.tm_inus {
				if level >= js_ast.la_dd {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_sub
						left:  left
						right: p.parse_expr(js_ast.la_dd)
					}
				}
			}
			js_lexer.tm_inus_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_sub_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.ta_sterisk {
				if level >= js_ast.lm_ultiply {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_mul
						left:  left
						right: p.parse_expr(js_ast.lm_ultiply)
					}
				}
			}
			js_lexer.ta_sterisk_asterisk {
				if level >= js_ast.le_xponentiation {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_pow
						left:  left
						right: p.parse_expr(js_ast.le_xponentiation - 1)
					}
				}
			}
			js_lexer.ta_sterisk_asterisk_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_pow_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.ta_sterisk_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_mul_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.tp_ercent {
				if level >= js_ast.lm_ultiply {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_rem
						left:  left
						right: p.parse_expr(js_ast.lm_ultiply)
					}
				}
			}
			js_lexer.tp_ercent_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_rem_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.ts_lash {
				if level >= js_ast.lm_ultiply {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_div
						left:  left
						right: p.parse_expr(js_ast.lm_ultiply)
					}
				}
			}
			js_lexer.ts_lash_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_div_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.te_quals_equals {
				if level >= js_ast.le_quals {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_loose_eq
						left:  left
						right: p.parse_expr(js_ast.le_quals)
					}
				}
			}
			js_lexer.te_xclamation_equals {
				if level >= js_ast.le_quals {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_loose_ne
						left:  left
						right: p.parse_expr(js_ast.le_quals)
					}
				}
			}
			js_lexer.te_quals_equals_equals {
				if level >= js_ast.le_quals {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_strict_eq
						left:  left
						right: p.parse_expr(js_ast.le_quals)
					}
				}
			}
			js_lexer.te_xclamation_equals_equals {
				if level >= js_ast.le_quals {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_strict_ne
						left:  left
						right: p.parse_expr(js_ast.le_quals)
					}
				}
			}
			js_lexer.tl_ess_than {
				if p.options.ts.parse && p.try_skip_type_arguments_in_expression_with_backtracking() {
					optional_chain = old_optional_chain
					continue
				}
				if level >= js_ast.lc_ompare {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_lt
						left:  left
						right: p.parse_expr(js_ast.lc_ompare)
					}
				}
			}
			js_lexer.tl_ess_than_equals {
				if level >= js_ast.lc_ompare {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_le
						left:  left
						right: p.parse_expr(js_ast.lc_ompare)
					}
				}
			}
			js_lexer.tg_reater_than {
				if level >= js_ast.lc_ompare {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_gt
						left:  left
						right: p.parse_expr(js_ast.lc_ompare)
					}
				}
			}
			js_lexer.tg_reater_than_equals {
				if level >= js_ast.lc_ompare {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_ge
						left:  left
						right: p.parse_expr(js_ast.lc_ompare)
					}
				}
			}
			js_lexer.tl_ess_than_less_than {
				if p.options.ts.parse && p.try_skip_type_arguments_in_expression_with_backtracking() {
					optional_chain = old_optional_chain
					continue
				}
				if level >= js_ast.ls_hift {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_shl
						left:  left
						right: p.parse_expr(js_ast.ls_hift)
					}
				}
			}
			js_lexer.tl_ess_than_less_than_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_shl_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.tg_reater_than_greater_than {
				if level >= js_ast.ls_hift {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_shr
						left:  left
						right: p.parse_expr(js_ast.ls_hift)
					}
				}
			}
			js_lexer.tg_reater_than_greater_than_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_shr_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.tg_reater_than_greater_than_greater_than {
				if level >= js_ast.ls_hift {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_us_hr
						left:  left
						right: p.parse_expr(js_ast.ls_hift)
					}
				}
			}
			js_lexer.tg_reater_than_greater_than_greater_than_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_us_hr_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.tq_uestion_question {
				if level >= js_ast.ln_ullish_coalescing {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_nullish_coalescing
						left:  left
						right: p.parse_expr(js_ast.ln_ullish_coalescing)
					}
				}
			}
			js_lexer.tq_uestion_question_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_nullish_coalescing_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.tb_ar_bar {
				if level >= js_ast.ll_ogical_or {
					return left
				}
				if level == js_ast.ln_ullish_coalescing {
					p.log_nullish_coalescing_error_precedence_error('||')
				}
				p.lexer.next()
				mut right := p.parse_expr(js_ast.ll_ogical_or)
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_logical_or
						left:  left
						right: right
					}
				}
				if level < js_ast.ln_ullish_coalescing {
					left = p.parse_suffix(left, js_ast.ln_ullish_coalescing + 1, nil,
						flags)
					if p.lexer.token == js_lexer.tq_uestion_question {
						p.log_nullish_coalescing_error_precedence_error('||')
					}
				}
			}
			js_lexer.tb_ar_bar_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_logical_or_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.ta_mpersand_ampersand {
				if level >= js_ast.ll_ogical_and {
					return left
				}
				if level == js_ast.ln_ullish_coalescing {
					p.log_nullish_coalescing_error_precedence_error('&&')
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_logical_and
						left:  left
						right: p.parse_expr(js_ast.ll_ogical_and)
					}
				}
				if level < js_ast.ln_ullish_coalescing {
					left = p.parse_suffix(left, js_ast.ln_ullish_coalescing + 1, nil,
						flags)
					if p.lexer.token == js_lexer.tq_uestion_question {
						p.log_nullish_coalescing_error_precedence_error('&&')
					}
				}
			}
			js_lexer.ta_mpersand_ampersand_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_logical_and_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.tb_ar {
				if level >= js_ast.lb_itwise_or {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_bitwise_or
						left:  left
						right: p.parse_expr(js_ast.lb_itwise_or)
					}
				}
			}
			js_lexer.tb_ar_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_bitwise_or_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.ta_mpersand {
				if level >= js_ast.lb_itwise_and {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_bitwise_and
						left:  left
						right: p.parse_expr(js_ast.lb_itwise_and)
					}
				}
			}
			js_lexer.ta_mpersand_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_bitwise_and_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.tc_aret {
				if level >= js_ast.lb_itwise_xor {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_bitwise_xor
						left:  left
						right: p.parse_expr(js_ast.lb_itwise_xor)
					}
				}
			}
			js_lexer.tc_aret_equals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_bitwise_xor_assign
						left:  left
						right: p.parse_expr(js_ast.la_ssign - 1)
					}
				}
			}
			js_lexer.te_quals {
				if level >= js_ast.la_ssign {
					return left
				}
				p.lexer.next()
				left = js_ast.assign(left, p.parse_expr(js_ast.la_ssign - 1))
			}
			js_lexer.ti_n {
				if level >= js_ast.lc_ompare || !p.allow_in {
					return left
				}
				mut kind_3 := logger.warning
				if p.suppress_warnings_about_weird_code {
					kind = logger.debug
				}
				mut e, ok_2 := left.data
				if ok && e.op == js_ast.un_op_not {
					mut r := logger.Range{
						loc: left.loc
						len: p.source.loc_before_whitespace(p.lexer.loc()).start - left.loc.start
					}
					mut data := p.tracker.msg_data(r, 'Suspicious use of the "!" operator inside the "in" operator')
					data.location.suggestion = strconv.v_sprintf('(%s)', p.source.text_for_range(r))
					p.log.add_msg_id(logger.msg_id_js_suspicious_boolean_not, logger.Msg{
						kind:  kind
						data:  data
						notes: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
						]
					})
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_in
						left:  left
						right: p.parse_expr(js_ast.lc_ompare)
					}
				}
			}
			js_lexer.ti_nstanceof {
				if level >= js_ast.lc_ompare {
					return left
				}
				mut kind_4 := logger.warning
				if p.suppress_warnings_about_weird_code {
					kind = logger.debug
				}
				mut e_1, ok_3 := left.data
				if ok && e.op == js_ast.un_op_not {
					mut r_1 := logger.Range{
						loc: left.loc
						len: p.source.loc_before_whitespace(p.lexer.loc()).start - left.loc.start
					}
					mut data_1 := p.tracker.msg_data(r, 'Suspicious use of the "!" operator inside the "instanceof" operator')
					data.location.suggestion = strconv.v_sprintf('(%s)', p.source.text_for_range(r))
					p.log.add_msg_id(logger.msg_id_js_suspicious_boolean_not, logger.Msg{
						kind:  kind
						data:  data
						notes: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
						]
					})
				}
				p.lexer.next()
				left = js_ast.Expr{
					loc:  left.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_instanceof
						left:  left
						right: p.parse_expr(js_ast.lc_ompare)
					}
				}
			}
			else {
				if p.options.ts.parse && level < js_ast.lc_ompare && !p.lexer.has_newline_before
					&& (p.lexer.is_contextual_keyword('as')
					|| p.lexer.is_contextual_keyword('satisfies')) {
					p.lexer.next()
					p.skip_type_script_type(js_ast.ll_owest)
					match p.lexer.token {
						js_lexer.tp_lus_plus, js_lexer.tm_inus_minus,
						js_lexer.tn_o_substitution_template_literal, js_lexer.tt_emplate_head,
						js_lexer.to_pen_paren, js_lexer.to_pen_bracket, js_lexer.tq_uestion_dot {
							p.forbid_suffix_after_as_loc = p.lexer.loc()
							return left
						}
					}
					if p.lexer.token.is_assign() {
						p.forbid_suffix_after_as_loc = p.lexer.loc()
						return left
					}
					continue
				}
				return left
			}
		}
	}
}

fn (p &Parser) parse_expr_or_let_or_using_stmt(opts parseStmtOpts) (js_ast.Expr, js_ast.Stmt, []js_ast.Decl) {
	mut could_be_let := false
	mut could_be_using := false
	mut could_be_await_using := false
	mut token_range := p.lexer.range()
	if p.lexer.token == js_lexer.ti_dentifier {
		mut raw := p.lexer.raw()
		could_be_let = raw == 'let'
		could_be_using = raw == 'using'
		could_be_await_using = raw == 'await' && p.fn_or_arrow_data_parse.await == allow_expr
	}
	if !could_be_let && !could_be_using && !could_be_await_using {
		mut flags := 0
		if opts.is_for_loop_init {
			flags |= expr_flag_for_loop_init
		}
		if opts.is_for_await_loop_init {
			flags |= expr_flag_for_await_loop_init
		}
		return p.parse_expr_common(js_ast.ll_owest, nil, flags), js_ast.Stmt{}, nil
	}
	mut name := p.lexer.identifier
	p.lexer.next()
	if could_be_let {
		mut is_let := opts.is_export
		match p.lexer.token {
			js_lexer.ti_dentifier, js_lexer.to_pen_bracket, js_lexer.to_pen_brace {
				if opts.lexical_decl == lexical_decl_allow_all || !p.lexer.has_newline_before
					|| p.lexer.token == js_lexer.to_pen_bracket {
					is_let = true
				}
			}
		}
		if is_let {
			if opts.lexical_decl != lexical_decl_allow_all {
				p.forbid_lexical_decl(token_range.loc)
			}
			p.mark_syntax_feature(compat.const_and_let, token_range)
			mut decls := p.parse_and_declare_decls(ast.symbol_other, opts)
			return js_ast.Expr{}, js_ast.Stmt{
				loc:  token_range.loc
				data: &js_ast.SLocal{
					kind:      js_ast.local_let
					decls:     decls
					is_export: opts.is_export
				}
			}, decls
		}
	} else if could_be_using && p.lexer.token == js_lexer.ti_dentifier
		&& !p.lexer.has_newline_before && (!opts.is_for_loop_init || p.lexer.raw() != 'of') {
		if opts.lexical_decl != lexical_decl_allow_all {
			p.forbid_lexical_decl(token_range.loc)
		}
		opts.is_using_stmt = true
		mut decls_1 := p.parse_and_declare_decls(ast.symbol_const, opts)
		if !opts.is_for_loop_init {
			p.require_initializers(js_ast.local_using, decls)
		}
		return js_ast.Expr{}, js_ast.Stmt{
			loc:  token_range.loc
			data: &js_ast.SLocal{
				kind:      js_ast.local_using
				decls:     decls
				is_export: opts.is_export
			}
		}, decls
	} else if could_be_await_using {
		if p.fn_or_arrow_data_parse.is_top_level {
			p.top_level_await_keyword = token_range
		}
		mut value := 0
		if p.lexer.token == js_lexer.ti_dentifier && p.lexer.raw() == 'using' {
			mut using_loc := p.save_expr_comments_here()
			mut using_range := p.lexer.range()
			p.lexer.next()
			if p.lexer.token == js_lexer.ti_dentifier && !p.lexer.has_newline_before {
				if opts.lexical_decl != lexical_decl_allow_all {
					p.forbid_lexical_decl(using_range.loc)
				}
				opts.is_using_stmt = true
				mut decls_2 := p.parse_and_declare_decls(ast.symbol_const, opts)
				if !opts.is_for_loop_init {
					p.require_initializers(js_ast.local_await_using, decls)
				}
				return js_ast.Expr{}, js_ast.Stmt{
					loc:  token_range.loc
					data: &js_ast.SLocal{
						kind:      js_ast.local_await_using
						decls:     decls
						is_export: opts.is_export
					}
				}, decls
			}
			value = js_ast.Expr{
				loc:  using_loc
				data: &js_ast.EIdentifier{
					ref: p.store_name_in_ref(js_lexer.MaybeSubstring{
						string: 'using'
					})
				}
			}
		} else {
			value = p.parse_expr(js_ast.lp_refix)
		}
		if p.lexer.token == js_lexer.ta_sterisk_asterisk {
			p.lexer.unexpected()
		}
		value = p.parse_suffix(value, js_ast.lp_refix, nil, 0)
		mut expr := js_ast.Expr{
			loc:  token_range.loc
			data: &js_ast.EAwait{
				value: value
			}
		}
		return p.parse_suffix(expr, js_ast.ll_owest, nil, 0), js_ast.Stmt{}, nil
	}
	mut expr_1 := js_ast.Expr{
		loc:  token_range.loc
		data: &js_ast.EIdentifier{
			ref: p.store_name_in_ref(name)
		}
	}
	return p.parse_suffix(expr, js_ast.ll_owest, nil, 0), js_ast.Stmt{}, nil
}

fn (p &Parser) parse_call_args() ([]js_ast.Expr, logger.Loc, bool) {
	mut old_allow_in := p.allow_in
	p.allow_in = true
	p.lexer.expect(js_lexer.to_pen_paren)
	for p.lexer.token != js_lexer.tc_lose_paren {
		if p.lexer.has_newline_before {
			is_multi_line = true
		}
		mut loc := p.lexer.loc()
		mut is_spread := p.lexer.token == js_lexer.td_ot_dot_dot
		if is_spread {
			p.mark_syntax_feature(compat.rest_argument, p.lexer.range())
			p.lexer.next()
		}
		mut arg := p.parse_expr(js_ast.lc_omma)
		if is_spread {
			arg = js_ast.Expr{
				loc:  loc
				data: &js_ast.ESpread{
					value: arg
				}
			}
		}
		args << arg
		if p.lexer.token != js_lexer.tc_omma {
			break
		}
		if p.lexer.has_newline_before {
			is_multi_line = true
		}
		p.lexer.next()
	}
	if p.lexer.has_newline_before {
		is_multi_line = true
	}
	close_paren_loc = p.save_expr_comments_here()
	p.lexer.expect(js_lexer.tc_lose_paren)
	p.allow_in = old_allow_in
	return
}

fn (p &Parser) parse_jsxn_amespaced_name() (logger.Range, js_lexer.MaybeSubstring) {
	mut name_range := p.lexer.range()
	mut name := p.lexer.identifier
	p.lexer.expect_inside_jsxe_lement(js_lexer.ti_dentifier)
	if p.lexer.token == js_lexer.tc_olon {
		name_range.len = p.lexer.range().end() - name_range.loc.start
		mut ns := name.string + ':'
		p.lexer.next_inside_jsxe_lement()
		if p.lexer.token == js_lexer.ti_dentifier {
			name_range.len = p.lexer.range().end() - name_range.loc.start
			ns += p.lexer.identifier.string
			p.lexer.next_inside_jsxe_lement()
		} else {
			p.log.add_error(&p.tracker, logger.Range{
				loc: logger.Loc{
					start: name_range.end()
				}
			}, strconv.v_sprintf('Expected identifier after %q in namespaced JSX name',
				ns))
			panic(js_lexer.LexerPanic{})
		}
		return name_range, js_lexer.MaybeSubstring{
			string: ns
		}
	}
	return name_range, name
}

fn tag_or_fragment_help_text(tag string) string {
	if tag == '' {
		return 'fragment tag'
	}
	return strconv.v_sprintf('%q tag', tag)
}

fn (p &Parser) parse_jsxt_ag() (logger.Range, string, js_ast.Expr) {
	mut loc := p.lexer.loc()
	if p.lexer.token == js_lexer.tg_reater_than {
		return logger.Range{
			loc: loc
			len: 0
		}, '', js_ast.Expr{}
	}
	mut tag_range, tag_name := p.parse_jsxn_amespaced_name()
	if tag_name.string.contains_any('-:') || p.lexer.token != js_lexer.td_ot
		&& tag_name.string[0] >= `a` && tag_name.string[0] <= `z` {
		return tag_range, tag_name.string, js_ast.Expr{
			loc:  loc
			data: &js_ast.EString{
				value: helpers.string_to_utf_16(tag_name.string)
			}
		}
	}
	mut tag := js_ast.Expr{
		loc:  loc
		data: &js_ast.EIdentifier{
			ref: p.store_name_in_ref(tag_name)
		}
	}
	mut chain := tag_name.string
	for p.lexer.token == js_lexer.td_ot {
		p.lexer.next_inside_jsxe_lement()
		mut member_range := p.lexer.range()
		mut member := p.lexer.identifier
		p.lexer.expect_inside_jsxe_lement(js_lexer.ti_dentifier)
		mut index := member.string.index_byte(`-`)
		if index >= 0 {
			p.log.add_error(&p.tracker, logger.Range{
				loc: logger.Loc{
					start: member_range.loc.start + i32(index)
				}
			}, 'Unexpected "-"')
			panic(js_lexer.LexerPanic{})
		}
		chain += '.' + member.string
		tag = js_ast.Expr{
			loc:  loc
			data: p.dot_or_mangled_prop_parse(tag, member, member_range.loc, js_ast.optional_chain_none,
				was_originally_dot)
		}
		tag_range.len = member_range.loc.start + member_range.len - tag_range.loc.start
	}
	return tag_range, chain, tag
}

fn (p &Parser) parse_jsxe_lement(loc logger.Loc) js_ast.Expr {
	if p.first_jsxe_lement_loc.start == -1 {
		p.first_jsxe_lement_loc = loc
	}
	mut start_range, start_text, start_tag_or_nil := p.parse_jsxt_ag()
	if p.options.ts.parse {
		p.skip_type_script_type_arguments(SkipTypeScriptTypeArgumentsOpts{
			is_inside_jsxe_lement: true
		})
	}
	mut previousStringWithBackslashLoc := 0
	mut properties := []
	{}
	mut is_single_line := true
	if start_tag_or_nil.data != nil {
		// unhandled in stmt: unknown sum type value
		if properties.len > 1 && !p.suppress_warnings_about_weird_code {
			mut keys := map[string]logger.Loc{}
			for _, property in properties {
				if property.kind != js_ast.property_spread {
					mut str, ok := property.key.data
					if ok {
						mut key := helpers.utf_16_to_string(str.value)
						mut prev_loc, ok_1 := keys[key]
						if ok {
							mut r := js_lexer.range_of_identifier(p.source, property.key.loc)
							p.log.add_idw_ith_notes(logger.msg_id_js_duplicate_object_key,
								logger.warning, &p.tracker, r, strconv.v_sprintf('Duplicate %q attribute in JSX element',
								key), [
								p.tracker.msg_data(js_lexer.range_of_identifier(p.source,
									prev_loc), strconv.v_sprintf('The original %q attribute is here:',
									key)),
							])
						}
						keys[key] = property.key.loc
					}
				}
			}
		}
	}
	if p.lexer.token == js_lexer.ts_yntax_error && p.lexer.raw() == '\\' && previous_string_with_backslash_loc.start > 0 {
		mut msg := logger.Msg{
			kind: logger.error
			data: p.tracker.msg_data(p.lexer.range(), 'Unexpected backslash in JSX element')
		}
		mut js_escape := p.source.text_for_range(p.lexer.previous_backslash_quote_in_jsx)
		mut xml_escape := ''
		if js_escape == '\\"' {
			xml_escape = '&quot;'
		} else if js_escape == "\\'" {
			xml_escape = '&apos;'
		}
		if xml_escape != '' {
			mut data := p.tracker.msg_data(p.lexer.previous_backslash_quote_in_jsx, 'Quoted JSX attributes use XML-style escapes instead of JavaScript-style escapes:')
			data.location.suggestion = xml_escape
			msg.notes << data
		}
		mut string_range := p.source.range_of_string(previous_string_with_backslash_loc)
		if string_range.len > 0 {
			mut data_1 := p.tracker.msg_data(string_range, 'Consider using a JavaScript string inside {...} instead of a quoted JSX attribute:')
			data.location.suggestion = strconv.v_sprintf('{%s}', p.source.text_for_range(string_range))
			msg.notes << data
		}
		p.log.add_msg(msg)
		panic(js_lexer.LexerPanic{})
	}
	if p.lexer.token == js_lexer.ts_lash {
		mut close_loc := p.lexer.loc()
		p.lexer.next_inside_jsxe_lement()
		if p.lexer.token != js_lexer.tg_reater_than {
			p.lexer.expected(js_lexer.tg_reater_than)
		}
		return js_ast.Expr{
			loc:  loc
			data: &js_ast.EJSXElement{
				tag_or_nil:         start_tag_or_nil
				properties:         properties
				close_loc:          close_loc
				is_tag_single_line: is_single_line
			}
		}
	}
	if p.options.ts.parse && properties.len == 0 && start_text != '' && p.lexer.token == js_lexer.tg_reater_than && p.source.contents[p.lexer.loc().start..].has_prefix('>(') {
		mut bad_arrow_in_tsxr_ange := p.lexer.bad_arrow_in_tsxr_ange
		mut bad_arrow_in_tsxs_uggestion := p.lexer.bad_arrow_in_tsxs_uggestion
		p.lexer.could_be_bad_arrow_in_tsx++
		p.lexer.bad_arrow_in_tsxr_ange = logger.Range{
			loc: loc
			len: p.lexer.range().end() - loc.start
		}
		p.lexer.bad_arrow_in_tsxs_uggestion = strconv.v_sprintf('<%s,>', start_text)
		defer {
			p.lexer.could_be_bad_arrow_in_tsx--
			p.lexer.bad_arrow_in_tsxr_ange = bad_arrow_in_tsxr_ange
			p.lexer.bad_arrow_in_tsxs_uggestion = bad_arrow_in_tsxs_uggestion
		}
	}
	p.lexer.expect_jsxe_lement_child(js_lexer.tg_reater_than)
	mut nullable_children := []
	{}
	for {
		match p.lexer.token {
			js_lexer.ts_tring_literal {
				if p.options.jsx.preserve {
					nullable_children << js_ast.Expr{
						loc:  p.lexer.loc()
						data: &js_ast.EJSXText{
							raw: p.lexer.raw()
						}
					}
				}
				else {
					mut str_1 := p.lexer.string_literal()
					if str.len > 0 {
						nullable_children << js_ast.Expr{
							loc:  p.lexer.loc()
							data: &js_ast.EString{
								value: str
							}
						}
					}
				}
				p.lexer.next_jsxe_lement_child()
			}
			js_lexer.to_pen_brace {
				p.lexer.next()
				if p.lexer.token == js_lexer.tc_lose_brace {
					nullable_children << js_ast.Expr{
						loc:  p.save_expr_comments_here()
						data: nil
					}
				}
				else {
					if p.lexer.token == js_lexer.td_ot_dot_dot {
						mut item_loc := p.lexer.loc()
						p.mark_syntax_feature(compat.rest_argument, p.lexer.range())
						p.lexer.next()
						nullable_children << js_ast.Expr{
							loc:  item_loc
							data: &js_ast.ESpread{
								value: p.parse_expr(js_ast.ll_owest)
							}
						}
					} else {
						nullable_children << p.parse_expr(js_ast.ll_owest)
					}
				}
				p.lexer.expect_jsxe_lement_child(js_lexer.tc_lose_brace)
			}
			js_lexer.tl_ess_than {
				mut less_than_loc := p.lexer.loc()
				p.lexer.next_inside_jsxe_lement()
				if p.lexer.token != js_lexer.ts_lash {
					nullable_children << p.parse_jsxe_lement(less_than_loc)
					p.lexer.next_jsxe_lement_child()
					continue
				}
				p.lexer.next_inside_jsxe_lement()
				mut end_range, end_text, _ := p.parse_jsxt_ag()
				if start_text != end_text {
					mut start_tag := tag_or_fragment_help_text(start_text)
					mut end_tag := tag_or_fragment_help_text(end_text)
					mut msg_1 := logger.Msg{
						kind:  logger.error
						data:  p.tracker.msg_data(end_range, strconv.v_sprintf('Unexpected closing %s does not match opening %s',
							end_tag, start_tag))
						notes: [
							p.tracker.msg_data(start_range, strconv.v_sprintf('The opening %s is here:',
								start_tag)),
						]
					}
					msg.data.location.suggestion = start_text
					p.log.add_msg(msg)
				}
				if p.lexer.token != js_lexer.tg_reater_than {
					p.lexer.expected(js_lexer.tg_reater_than)
				}
				return js_ast.Expr{
					loc:  loc
					data: &js_ast.EJSXElement{
						tag_or_nil:         start_tag_or_nil
						properties:         properties
						nullable_children:  nullable_children
						close_loc:          less_than_loc
						is_tag_single_line: is_single_line
					}
				}
			}
			js_lexer.te_nd_of_file {
				mut start_tag_1 := tag_or_fragment_help_text(start_text)
				mut msg_2 := logger.Msg{
					kind:  logger.error
					data:  p.tracker.msg_data(p.lexer.range(), strconv.v_sprintf('Unexpected end of file before a closing %s',
						start_tag))
					notes: [
						p.tracker.msg_data(start_range, strconv.v_sprintf('The opening %s is here:',
							start_tag)),
					]
				}
				msg.data.location.suggestion = strconv.v_sprintf('</%s>', start_text)
				p.log.add_msg(msg)
				panic(js_lexer.LexerPanic{})
			}
			else {
				p.lexer.unexpected()
			}
		}
	}
}

fn (p &Parser) parse_template_parts(include_raw bool) ([]js_ast.TemplatePart, logger.Loc) {
	mut old_allow_in := p.allow_in
	p.allow_in = true
	for {
		p.lexer.next()
		mut value := p.parse_expr(js_ast.ll_owest)
		mut tail_loc := p.lexer.loc()
		p.lexer.rescan_close_brace_as_template_token()
		if include_raw {
			mut tail_cooked, tail_raw := p.lexer.cooked_and_raw_template_contents()
			parts << js_ast.TemplatePart{
				value:       value
				tail_loc:    tail_loc
				tail_cooked: tail_cooked
				tail_raw:    tail_raw
			}
		} else {
			parts << js_ast.TemplatePart{
				value:       value
				tail_loc:    tail_loc
				tail_cooked: p.lexer.string_literal()
			}
			if p.lexer.legacy_octal_loc.start > tail_loc.start {
				legacy_octal_loc = p.lexer.legacy_octal_loc
			}
		}
		if p.lexer.token == js_lexer.tt_emplate_tail {
			p.lexer.next()
			break
		}
	}
	p.allow_in = old_allow_in
	return parts, legacy_octal_loc
}

fn (p &Parser) parse_and_declare_decls(kind ast.SymbolKind, opts parseStmtOpts) []js_ast.Decl {
	mut decls := []
	{}
	for {
		if (kind == ast.symbol_other || kind == ast.symbol_const) && p.lexer.is_contextual_keyword('let') {
			p.log.add_error(&p.tracker, p.lexer.range(), 'Cannot use "let" as an identifier here:')
		}
		mut valueOrNil := 0
		mut local := p.parse_binding(ParseBindingOpts{
			is_using_stmt: opts.is_using_stmt
		})
		p.declare_binding(kind, local, opts)
		if p.options.ts.parse {
			mut is_definite_assignment_assertion := p.lexer.token == js_lexer.te_xclamation
				&& !p.lexer.has_newline_before
			if is_definite_assignment_assertion {
				p.lexer.next()
			}
			if is_definite_assignment_assertion || p.lexer.token == js_lexer.tc_olon {
				p.lexer.expect(js_lexer.tc_olon)
				p.skip_type_script_type(js_ast.ll_owest)
			}
		}
		if p.lexer.token == js_lexer.te_quals {
			p.lexer.next()
			value_or_nil = p.parse_expr(js_ast.lc_omma)
			if !p.options.ignore_dcea_nnotations && kind == ast.symbol_const {
				mut e := value_or_nil.data
				match e {
					js_ast.EArrow {
						if opts.has_no_side_effects_comment {
							e.has_no_side_effects_comment = true
						}
						if e.has_no_side_effects_comment && !opts.is_type_script_declare {
							mut b, ok := local.data
							if ok {
								p.symbols[b.ref.inner_index].flags |= ast.call_can_be_unwrapped_if_unused
							}
						}
					}
					js_ast.EFunction {
						if opts.has_no_side_effects_comment {
							e.fn_.has_no_side_effects_comment = true
						}
						if e.fn_.has_no_side_effects_comment && !opts.is_type_script_declare {
							mut b_1, ok_1 := local.data
							if ok {
								p.symbols[b.ref.inner_index].flags |= ast.call_can_be_unwrapped_if_unused
							}
						}
					}
				}
				opts.has_no_side_effects_comment = false
			}
		}
		decls << js_ast.Decl{
			binding:      local
			value_or_nil: value_or_nil
		}
		if p.lexer.token != js_lexer.tc_omma {
			break
		}
		p.lexer.next()
	}
	return decls
}

fn (p &Parser) require_initializers(kind js_ast.LocalKind, decls []js_ast.Decl) {
	for _, d in decls {
		if d.value_or_nil.data == nil {
			mut what := 'constant'
			if kind == js_ast.local_using {
				what = 'declaration'
			}
			mut id, ok := d.binding.data
			if ok {
				mut r := js_lexer.range_of_identifier(p.source, d.binding.loc)
				p.log.add_error(&p.tracker, r, strconv.v_sprintf('The %s %q must be initialized',
					what, p.symbols[id.ref.inner_index].original_name))
			} else {
				p.log.add_error(&p.tracker, logger.Range{
					loc: d.binding.loc
				}, strconv.v_sprintf('This %s must be initialized', what))
			}
		}
	}
}

fn (p &Parser) forbid_initializers(decls []js_ast.Decl, loop_type string, is_var bool) {
	if decls.len > 1 {
		p.log.add_error(&p.tracker, logger.Range{
			loc: decls[0].binding.loc
		}, strconv.v_sprintf('for-%s loops must have a single declaration', loop_type))
	} else if decls.len == 1 && decls[0].value_or_nil.data != nil {
		if is_var {
			_, ok := decls[0].binding.data
			if ok {
				return
			}
		}
		p.log.add_error(&p.tracker, logger.Range{
			loc: decls[0].value_or_nil.loc
		}, strconv.v_sprintf('for-%s loop variables cannot have an initializer', loop_type))
	}
}

fn (p &Parser) parse_clause_alias(kind string) js_lexer.MaybeSubstring {
	mut loc := p.lexer.loc()
	if p.lexer.token == js_lexer.ts_tring_literal {
		mut r := p.source.range_of_string(loc)
		mut alias, problem, ok := helpers.utf_16_to_string_with_validation(p.lexer.string_literal())
		if !ok {
			p.log.add_error(&p.tracker, r, strconv.v_sprintf('This %s alias is invalid because it contains the unpaired Unicode surrogate U+%X',
				kind, problem))
		}
		return js_lexer.MaybeSubstring{
			string: alias
		}
	}
	if !p.lexer.is_identifier_or_keyword() {
		p.lexer.expect(js_lexer.ti_dentifier)
	}
	mut alias_1 := p.lexer.identifier
	p.check_for_unrepresentable_identifier(loc, alias.string)
	return alias
}

fn (p &Parser) parse_import_clause() ([]js_ast.ClauseItem, bool) {
	mut items := []
	{}
	p.lexer.expect(js_lexer.to_pen_brace)
	mut is_single_line := !p.lexer.has_newline_before
	for p.lexer.token != js_lexer.tc_lose_brace {
		mut is_identifier := p.lexer.token == js_lexer.ti_dentifier
		mut alias_loc := p.lexer.loc()
		mut alias := p.parse_clause_alias('import')
		mut name := ast.LocRef{
			loc: alias_loc
			ref: p.store_name_in_ref(alias)
		}
		mut original_name := alias
		p.lexer.next()
		if p.options.ts.parse && alias.string == 'type' && p.lexer.token != js_lexer.tc_omma && p.lexer.token != js_lexer.tc_lose_brace {
			if p.lexer.is_contextual_keyword('as') {
				p.lexer.next()
				if p.lexer.is_contextual_keyword('as') {
					original_name = p.lexer.identifier
					name = ast.LocRef{
						loc: p.lexer.loc()
						ref: p.store_name_in_ref(original_name)
					}
					p.lexer.next()
					if p.lexer.token == js_lexer.ti_dentifier {
						p.lexer.next()
					} else {
						items << js_ast.ClauseItem{
							alias:         alias.string
							alias_loc:     alias_loc
							name:          name
							original_name: original_name.string
						}
					}
				} else if p.lexer.token == js_lexer.ti_dentifier {
					original_name = p.lexer.identifier
					name = ast.LocRef{
						loc: p.lexer.loc()
						ref: p.store_name_in_ref(original_name)
					}
					p.lexer.expect(js_lexer.ti_dentifier)
					if is_eval_or_arguments(original_name.string) {
						mut r := js_lexer.range_of_identifier(p.source, name.loc)
						p.log.add_error(&p.tracker, r, strconv.v_sprintf('Cannot use %q as an identifier here:',
							original_name.string))
					}
					items << js_ast.ClauseItem{
						alias:         alias.string
						alias_loc:     alias_loc
						name:          name
						original_name: original_name.string
					}
				}
			} else {
				mut is_identifier_1 := p.lexer.token == js_lexer.ti_dentifier
				p.parse_clause_alias('import')
				p.lexer.next()
				if p.lexer.is_contextual_keyword('as') {
					p.lexer.next()
					p.lexer.expect(js_lexer.ti_dentifier)
				} else if !is_identifier {
					p.lexer.expected_string('"as"')
				}
			}
		}
		else {
			if p.lexer.is_contextual_keyword('as') {
				p.lexer.next()
				original_name = p.lexer.identifier
				name = ast.LocRef{
					loc: p.lexer.loc()
					ref: p.store_name_in_ref(original_name)
				}
				p.lexer.expect(js_lexer.ti_dentifier)
			} else if !is_identifier {
				p.lexer.expected_string('"as"')
			}
			if is_eval_or_arguments(original_name.string) {
				mut r_1 := js_lexer.range_of_identifier(p.source, name.loc)
				p.log.add_error(&p.tracker, r, strconv.v_sprintf('Cannot use %q as an identifier here:',
					original_name.string))
			}
			items << js_ast.ClauseItem{
				alias:         alias.string
				alias_loc:     alias_loc
				name:          name
				original_name: original_name.string
			}
		}
		if p.lexer.token != js_lexer.tc_omma {
			break
		}
		if p.lexer.has_newline_before {
			is_single_line = false
		}
		p.lexer.next()
		if p.lexer.has_newline_before {
			is_single_line = false
		}
	}
	if p.lexer.has_newline_before {
		is_single_line = false
	}
	p.lexer.expect(js_lexer.tc_lose_brace)
	return items, is_single_line
}

fn (p &Parser) parse_export_clause() ([]js_ast.ClauseItem, bool) {
	mut items := []
	{}
	mut first_non_identifier_loc := logger.Loc{}
	p.lexer.expect(js_lexer.to_pen_brace)
	mut is_single_line := !p.lexer.has_newline_before
	for p.lexer.token != js_lexer.tc_lose_brace {
		mut alias := p.parse_clause_alias('export')
		mut alias_loc := p.lexer.loc()
		mut name := ast.LocRef{
			loc: alias_loc
			ref: p.store_name_in_ref(alias)
		}
		mut original_name := alias
		if p.lexer.token != js_lexer.ti_dentifier && first_non_identifier_loc.start == 0 {
			first_non_identifier_loc = p.lexer.loc()
		}
		p.lexer.next()
		if p.options.ts.parse && alias.string == 'type' && p.lexer.token != js_lexer.tc_omma && p.lexer.token != js_lexer.tc_lose_brace {
			if p.lexer.is_contextual_keyword('as') {
				p.lexer.next()
				if p.lexer.is_contextual_keyword('as') {
					alias = p.parse_clause_alias('export')
					alias_loc = p.lexer.loc()
					p.lexer.next()
					if p.lexer.token != js_lexer.tc_omma && p.lexer.token != js_lexer.tc_lose_brace {
						p.parse_clause_alias('export')
						p.lexer.next()
					} else {
						items << js_ast.ClauseItem{
							alias:         alias.string
							alias_loc:     alias_loc
							name:          name
							original_name: original_name.string
						}
					}
				} else if p.lexer.token != js_lexer.tc_omma && p.lexer.token != js_lexer.tc_lose_brace {
					alias = p.parse_clause_alias('export')
					alias_loc = p.lexer.loc()
					p.lexer.next()
					items << js_ast.ClauseItem{
						alias:         alias.string
						alias_loc:     alias_loc
						name:          name
						original_name: original_name.string
					}
				}
			}
			else {
				if p.lexer.token != js_lexer.ti_dentifier && first_non_identifier_loc.start == 0 {
					first_non_identifier_loc = p.lexer.loc()
				}
				p.parse_clause_alias('export')
				p.lexer.next()
				if p.lexer.is_contextual_keyword('as') {
					p.lexer.next()
					p.parse_clause_alias('export')
					p.lexer.next()
				}
			}
		}
		else {
			if p.lexer.is_contextual_keyword('as') {
				p.lexer.next()
				alias = p.parse_clause_alias('export')
				alias_loc = p.lexer.loc()
				p.lexer.next()
			}
			items << js_ast.ClauseItem{
				alias:         alias.string
				alias_loc:     alias_loc
				name:          name
				original_name: original_name.string
			}
		}
		if p.lexer.token != js_lexer.tc_omma {
			break
		}
		if p.lexer.has_newline_before {
			is_single_line = false
		}
		p.lexer.next()
		if p.lexer.has_newline_before {
			is_single_line = false
		}
	}
	if p.lexer.has_newline_before {
		is_single_line = false
	}
	p.lexer.expect(js_lexer.tc_lose_brace)
	if first_non_identifier_loc.start != 0 && !p.lexer.is_contextual_keyword('from') {
		mut r := js_lexer.range_of_identifier(p.source, first_non_identifier_loc)
		p.log.add_error(&p.tracker, r, strconv.v_sprintf('Expected identifier but found %q',
			p.source.text_for_range(r)))
		panic(js_lexer.LexerPanic{})
	}
	return items, is_single_line
}

struct parseBindingOpts {
pub mut:
	is_using_stmt bool
}

fn (p &Parser) parse_binding(opts parseBindingOpts) js_ast.Binding {
	mut loc := p.lexer.loc()
	match p.lexer.token {
		js_lexer.ti_dentifier {
			mut name := p.lexer.identifier
			if p.fn_or_arrow_data_parse.await != allow_ident && name.string == 'await'
				|| p.fn_or_arrow_data_parse.yield != allow_ident && name.string == 'yield' {
				p.log.add_error(&p.tracker, p.lexer.range(), strconv.v_sprintf('Cannot use %q as an identifier here:',
					name.string))
			}
			mut ref := p.store_name_in_ref(name)
			p.lexer.next()
			return js_ast.Binding{
				loc:  loc
				data: &js_ast.BIdentifier{
					ref: ref
				}
			}
		}
		js_lexer.to_pen_bracket {
			if opts.is_using_stmt {
				break
			}
			p.mark_syntax_feature(compat.destructuring, p.lexer.range())
			p.lexer.next()
			mut is_single_line := !p.lexer.has_newline_before
			mut items := []
			{}
			mut has_spread := false
			mut old_allow_in := p.allow_in
			p.allow_in = true
			for p.lexer.token != js_lexer.tc_lose_bracket {
				mut item_loc := p.save_expr_comments_here()
				if p.lexer.token == js_lexer.tc_omma {
					mut binding := js_ast.Binding{
						loc:  item_loc
						data: js_ast.bm_issing_shared
					}
					items << js_ast.ArrayBinding{
						binding: binding
						loc:     item_loc
					}
				}
				else {
					if p.lexer.token == js_lexer.td_ot_dot_dot {
						p.lexer.next()
						has_spread = true
						if p.lexer.token != js_lexer.ti_dentifier {
							p.mark_syntax_feature(compat.nested_rest_binding, p.lexer.range())
						}
					}
					p.save_expr_comments_here()
					mut binding_1 := p.parse_binding(ParseBindingOpts{})
					mut defaultValueOrNil := 0
					if !has_spread && p.lexer.token == js_lexer.te_quals {
						p.lexer.next()
						default_value_or_nil = p.parse_expr(js_ast.lc_omma)
					}
					items << js_ast.ArrayBinding{
						binding:              binding
						default_value_or_nil: default_value_or_nil
						loc:                  item_loc
					}
					if has_spread && p.lexer.token == js_lexer.tc_omma {
						p.log.add_error(&p.tracker, p.lexer.range(), 'Unexpected "," after rest pattern')
						panic(js_lexer.LexerPanic{})
					}
				}
				if p.lexer.token != js_lexer.tc_omma {
					break
				}
				if p.lexer.has_newline_before {
					is_single_line = false
				}
				p.lexer.next()
				if p.lexer.has_newline_before {
					is_single_line = false
				}
			}
			p.allow_in = old_allow_in
			if p.lexer.has_newline_before {
				is_single_line = false
			}
			mut close_bracket_loc := p.save_expr_comments_here()
			p.lexer.expect(js_lexer.tc_lose_bracket)
			return js_ast.Binding{
				loc:  loc
				data: &js_ast.BArray{
					items:             items
					has_spread:        has_spread
					is_single_line:    is_single_line
					close_bracket_loc: close_bracket_loc
				}
			}
		}
		js_lexer.to_pen_brace {
			if opts.is_using_stmt {
				break
			}
			p.mark_syntax_feature(compat.destructuring, p.lexer.range())
			p.lexer.next()
			mut is_single_line_1 := !p.lexer.has_newline_before
			mut properties := []
			{}
			mut old_allow_in_1 := p.allow_in
			p.allow_in = true
			for p.lexer.token != js_lexer.tc_lose_brace {
				p.save_expr_comments_here()
				mut property := p.parse_property_binding()
				properties << property
				if property.is_spread && p.lexer.token == js_lexer.tc_omma {
					p.log.add_error(&p.tracker, p.lexer.range(), 'Unexpected "," after rest pattern')
					panic(js_lexer.LexerPanic{})
				}
				if p.lexer.token != js_lexer.tc_omma {
					break
				}
				if p.lexer.has_newline_before {
					is_single_line = false
				}
				p.lexer.next()
				if p.lexer.has_newline_before {
					is_single_line = false
				}
			}
			p.allow_in = old_allow_in
			if p.lexer.has_newline_before {
				is_single_line = false
			}
			mut close_brace_loc := p.save_expr_comments_here()
			p.lexer.expect(js_lexer.tc_lose_brace)
			return js_ast.Binding{
				loc:  loc
				data: &js_ast.BObject{
					properties:      properties
					is_single_line:  is_single_line
					close_brace_loc: close_brace_loc
				}
			}
		}
	}
	p.lexer.expect(js_lexer.ti_dentifier)
	return js_ast.Binding{}
}

fn (p &Parser) parse_fn(name &ast.LocRef, class_keyword logger.Range, decorator_context decoratorContextFlags, data fnOrArrowDataParse) (js_ast.Fn, bool) {
	fn_.name = name
	fn_.has_rest_arg = false
	fn_.is_async = data.await == allow_expr
	fn_.is_generator = data.yield == allow_expr
	fn_.arguments_ref = ast.invalid_ref
	fn_.open_paren_loc = p.lexer.loc()
	p.lexer.expect(js_lexer.to_pen_paren)
	mut old_fn_or_arrow_data := p.fn_or_arrow_data_parse
	if data.await == allow_expr {
		p.fn_or_arrow_data_parse.await = forbid_all
	} else {
		p.fn_or_arrow_data_parse.await = allow_ident
	}
	if data.yield == allow_expr {
		p.fn_or_arrow_data_parse.yield = forbid_all
	} else {
		p.fn_or_arrow_data_parse.yield = allow_ident
	}
	p.fn_or_arrow_data_parse.needs_async_loc.start = -1
	p.fn_or_arrow_data_parse.allow_super_call = data.allow_super_call
	p.fn_or_arrow_data_parse.allow_super_property = data.allow_super_property
	for p.lexer.token != js_lexer.tc_lose_paren {
		if p.options.ts.parse && p.lexer.token == js_lexer.tt_his {
			p.lexer.next()
			if p.lexer.token == js_lexer.tc_olon {
				p.lexer.next()
				p.skip_type_script_type(js_ast.ll_owest)
			}
			if p.lexer.token != js_lexer.tc_omma {
				break
			}
			p.lexer.next()
			continue
		}
		mut decorators := []js_ast.Decorator{}
		if data.decorator_scope != nil {
			mut old_await := p.fn_or_arrow_data_parse.await
			mut old_needs_async_loc := p.fn_or_arrow_data_parse.needs_async_loc
			if old_fn_or_arrow_data.await == allow_expr {
				p.fn_or_arrow_data_parse.await = allow_expr
			} else {
				p.fn_or_arrow_data_parse.needs_async_loc = old_fn_or_arrow_data.needs_async_loc
			}
			decorators = p.parse_decorators(data.decorator_scope, class_keyword, decorator_context | decorator_in_fn_args)
			p.fn_or_arrow_data_parse.await = old_await
			p.fn_or_arrow_data_parse.needs_async_loc = old_needs_async_loc
		}
		if !fn_.has_rest_arg && p.lexer.token == js_lexer.td_ot_dot_dot {
			p.mark_syntax_feature(compat.rest_argument, p.lexer.range())
			p.lexer.next()
			fn_.has_rest_arg = true
		}
		mut is_type_script_ctor_field := false
		mut is_identifier := p.lexer.token == js_lexer.ti_dentifier
		mut text := p.lexer.identifier.string
		mut arg := p.parse_binding(ParseBindingOpts{})
		if p.options.ts.parse {
			if is_identifier && data.is_constructor {
				for p.lexer.token == js_lexer.ti_dentifier || p.lexer.token == js_lexer.to_pen_brace
					|| p.lexer.token == js_lexer.to_pen_bracket {
					if text != 'public' && text != 'private' && text != 'protected' && text != 'readonly' && text != 'override' {
						break
					}
					is_type_script_ctor_field = true
					if p.lexer.token != js_lexer.ti_dentifier {
						p.lexer.expect(js_lexer.ti_dentifier)
					}
					text = p.lexer.identifier.string
					arg = p.parse_binding(ParseBindingOpts{})
				}
			}
			if p.lexer.token == js_lexer.tq_uestion {
				p.lexer.next()
			}
			if p.lexer.token == js_lexer.tc_olon {
				p.lexer.next()
				p.skip_type_script_type(js_ast.ll_owest)
			}
		}
		p.declare_binding(ast.symbol_hoisted, arg, ParseStmtOpts{})
		mut defaultValueOrNil := 0
		if !fn_.has_rest_arg && p.lexer.token == js_lexer.te_quals {
			p.mark_syntax_feature(compat.default_argument, p.lexer.range())
			p.lexer.next()
			default_value_or_nil = p.parse_expr(js_ast.lc_omma)
		}
		fn_.args << js_ast.Arg{
			decorators:                decorators
			binding:                   arg
			default_or_nil:            default_value_or_nil
			is_type_script_ctor_field: is_type_script_ctor_field
		}
		if p.lexer.token != js_lexer.tc_omma {
			break
		}
		if fn_.has_rest_arg {
			if data.is_type_script_declare {
				p.lexer.next()
			} else {
				p.lexer.expect(js_lexer.tc_lose_paren)
			}
			break
		}
		p.lexer.next()
	}
	_, ok := p.current_scope.members['arguments']
	if !ok {
		fn_.arguments_ref = p.declare_symbol(ast.symbol_arguments, fn_.open_paren_loc,
			'arguments')
		p.symbols[fn_.arguments_ref.inner_index].flags |= ast.must_not_be_renamed
	}
	p.lexer.expect(js_lexer.tc_lose_paren)
	p.fn_or_arrow_data_parse = old_fn_or_arrow_data
	if p.options.ts.parse && p.lexer.token == js_lexer.tc_olon {
		p.lexer.next()
		p.skip_type_script_return_type()
	}
	if data.allow_missing_body_for_type_script && p.lexer.token != js_lexer.to_pen_brace {
		p.lexer.expect_or_insert_semicolon()
		return
	}
	fn_.body = p.parse_fn_body(data)
	had_body = true
	return
}

type fnKind = u8

enum fnKind {
	fn_stmt
	fn_expr
}

fn (p &Parser) validate_function_name(fn_ js_ast.Fn, kind fnKind) {
	if fn_.name != nil {
		if fn_.is_async && p.symbols[fn_.name.ref.inner_index].original_name == 'await' {
			p.log.add_error(&p.tracker, js_lexer.range_of_identifier(p.source, fn_.name.loc),
				'An async function cannot be named "await"')
		} else if fn_.is_generator && p.symbols[fn_.name.ref.inner_index].original_name == 'yield' && kind == fn_expr {
			p.log.add_error(&p.tracker, js_lexer.range_of_identifier(p.source, fn_.name.loc),
				'A generator function expression cannot be named "yield"')
		}
	}
}

fn (p &Parser) validate_declared_symbol_name(loc logger.Loc, name string) {
	if js_lexer.strict_mode_reserved_words[name] {
		p.mark_strict_mode_feature(reserved_word, js_lexer.range_of_identifier(p.source,
			loc), name)
	} else if is_eval_or_arguments(name) {
		p.mark_strict_mode_feature(eval_or_arguments, js_lexer.range_of_identifier(p.source,
			loc), name)
	}
}

fn (p &Parser) parse_class_stmt(loc logger.Loc, opts parseStmtOpts) js_ast.Stmt {
	mut name := 0
	mut class_keyword := p.lexer.range()
	if p.lexer.token == js_lexer.tc_lass {
		p.mark_syntax_feature(compat.class, class_keyword)
		p.lexer.next()
	} else {
		p.lexer.expected(js_lexer.tc_lass)
	}
	if !opts.is_name_optional || p.lexer.token == js_lexer.ti_dentifier
		&& (!p.options.ts.parse || p.lexer.identifier.string != 'implements') {
		mut name_loc := p.lexer.loc()
		mut name_text := p.lexer.identifier.string
		p.lexer.expect(js_lexer.ti_dentifier)
		if p.fn_or_arrow_data_parse.await != allow_ident && name_text == 'await' {
			p.log.add_error(&p.tracker, js_lexer.range_of_identifier(p.source, name_loc),
				'Cannot use "await" as an identifier here:')
		}
		name = &ast.LocRef{
			loc: name_loc
			ref: ast.invalid_ref
		}
		if !opts.is_type_script_declare {
			name.ref = p.declare_symbol(ast.symbol_class, name_loc, name_text)
		}
	}
	if p.options.ts.parse {
		p.skip_type_script_type_parameters(allow_in_out_variance_annotations | allow_const_modifier)
	}
	mut class_opts := ParseClassOpts{
		is_type_script_declare: opts.is_type_script_declare
	}
	if opts.deferred_decorators != nil {
		class_opts.decorators = opts.deferred_decorators.decorators
	}
	mut scope_index := p.push_scope_for_parse_pass(js_ast.scope_class_name, loc)
	mut class := p.parse_class(class_keyword, name, class_opts)
	if opts.is_type_script_declare {
		p.pop_and_discard_scope(scope_index)
		if opts.is_namespace_scope && opts.is_export {
			p.has_non_local_export_declare_inside_namespace = true
		}
		return js_ast.Stmt{
			loc:  loc
			data: js_ast.st_ype_script_shared_was_declare_class
		}
	}
	p.pop_scope()
	return js_ast.Stmt{
		loc:  loc
		data: &js_ast.SClass{
			class:     class
			is_export: opts.is_export
		}
	}
}

fn (p &Parser) parse_class_expr(decorators []js_ast.Decorator) js_ast.Expr {
	mut class_keyword := p.lexer.range()
	p.mark_syntax_feature(compat.class, class_keyword)
	p.lexer.expect(js_lexer.tc_lass)
	mut name := 0
	mut opts := ParseClassOpts{
		decorators:        decorators
		decorator_context: decorator_in_class_expr
	}
	p.push_scope_for_parse_pass(js_ast.scope_class_name, class_keyword.loc)
	if p.lexer.token == js_lexer.ti_dentifier {
		mut name_text := p.lexer.identifier.string
		if !p.options.ts.parse || name_text != 'implements' {
			if p.fn_or_arrow_data_parse.await != allow_ident && name_text == 'await' {
				p.log.add_error(&p.tracker, p.lexer.range(), 'Cannot use "await" as an identifier here:')
			}
			name = &ast.LocRef{
				loc: p.lexer.loc()
				ref: p.new_symbol(ast.symbol_other, name_text)
			}
			p.lexer.next()
		}
	}
	if p.options.ts.parse {
		p.skip_type_script_type_parameters(allow_in_out_variance_annotations | allow_const_modifier)
	}
	mut class := p.parse_class(class_keyword, name, opts)
	p.pop_scope()
	return js_ast.Expr{
		loc:  class_keyword.loc
		data: &js_ast.EClass{
			class: class
		}
	}
}

struct parseClassOpts {
pub mut:
	decorators             []js_ast.Decorator
	decorator_context      decoratorContextFlags
	is_type_script_declare bool
}

// By the time we call this, the identifier and type parameters have already
// been parsed. We need to start parsing from the "extends" clause.
fn (p &Parser) parse_class(class_keyword logger.Range, name &ast.LocRef, class_opts parseClassOpts) js_ast.Class {
	mut extendsOrNil := 0
	if p.lexer.token == js_lexer.te_xtends {
		p.lexer.next()
		extends_or_nil = p.parse_expr(js_ast.ln_ew)
		if p.options.ts.parse {
			p.skip_type_script_type_arguments(SkipTypeScriptTypeArgumentsOpts{})
		}
	}
	if p.options.ts.parse && p.lexer.is_contextual_keyword('implements') {
		p.lexer.next()
		for {
			p.skip_type_script_type(js_ast.ll_owest)
			if p.lexer.token != js_lexer.tc_omma {
				break
			}
			p.lexer.next()
		}
	}
	mut body_loc := p.lexer.loc()
	p.lexer.expect(js_lexer.to_pen_brace)
	mut properties := []
	{}
	mut has_property_decorator := false
	mut old_allow_in := p.allow_in
	mut old_allow_private_identifiers := p.allow_private_identifiers
	p.allow_in = true
	p.allow_private_identifiers = true
	mut scope_index := p.push_scope_for_parse_pass(js_ast.scope_class_body, body_loc)
	mut opts := PropertyOpts{
		is_class:          true
		decorator_scope:   p.current_scope
		decorator_context: class_opts.decorator_context
		class_has_extends: extends_or_nil.data != nil
		class_keyword:     class_keyword
	}
	mut has_constructor := false
	for p.lexer.token != js_lexer.tc_lose_brace {
		if p.lexer.token == js_lexer.ts_emicolon {
			p.lexer.next()
			continue
		}
		mut first_decorator_loc := p.lexer.loc()
		mut scope_index_1 := p.scopes_in_order.len
		opts.decorators = p.parse_decorators(p.current_scope, class_keyword, opts.decorator_context)
		if opts.decorators.len > 0 {
			has_property_decorator = true
		}
		mut property, ok := p.parse_property(p.save_expr_comments_here(), js_ast.property_field,
			opts, nil)
		if ok {
			properties << property
			mut key, ok_1 := property.key.data
			if ok && helpers.utf_16_equals_string(key.value, 'constructor') {
				if opts.decorators.len > 0 {
					p.log.add_error(&p.tracker, logger.Range{
						loc: first_decorator_loc
					}, 'Decorators are not allowed on class constructors')
				}
				if property.kind.is_method_definition()
					&& !property.flags.has(js_ast.property_is_static)
					&& !property.flags.has(js_ast.property_is_computed) {
					if has_constructor {
						p.log.add_error(&p.tracker, js_lexer.range_of_identifier(p.source,
							property.key.loc), 'Classes cannot contain more than one constructor')
					}
					has_constructor = true
				}
			}
		} else if !class_opts.is_type_script_declare && opts.decorators.len > 0 {
			p.log.add_error(&p.tracker, logger.Range{
				loc: first_decorator_loc
				len: 1
			}, 'Decorators are not valid here')
			p.discard_scopes_up_to(scope_index)
		}
	}
	if class_opts.is_type_script_declare {
		p.pop_and_discard_scope(scope_index)
	} else {
		p.pop_scope()
	}
	p.allow_in = old_allow_in
	p.allow_private_identifiers = old_allow_private_identifiers
	mut close_brace_loc := p.save_expr_comments_here()
	p.lexer.expect(js_lexer.tc_lose_brace)
	mut use_define_for_class_fields := !p.options.ts.parse
		|| p.options.ts.config.use_define_for_class_fields == config.true_
		|| p.options.ts.config.use_define_for_class_fields == config.unspecified
		&& p.options.ts.config.target != config.tst_arget_below_es_2022
	return js_ast.Class{
		class_keyword:                    class_keyword
		decorators:                       class_opts.decorators
		name:                             name
		extends_or_nil:                   extends_or_nil
		body_loc:                         body_loc
		properties:                       properties
		close_brace_loc:                  close_brace_loc
		should_lower_standard_decorators: (class_opts.decorators.len > 0 || has_property_decorator) && (
			!p.options.ts.parse && p.options.unsupported_jsf_eatures.has(compat.decorators)
			|| p.options.ts.parse && p.options.ts.config.experimental_decorators != config.true_
			&& (p.options.unsupported_jsf_eatures.has(compat.decorators)
			|| !use_define_for_class_fields))
		use_define_for_class_fields:      use_define_for_class_fields
	}
}

fn (p &Parser) parse_label_name() &ast.LocRef {
	if p.lexer.token != js_lexer.ti_dentifier || p.lexer.has_newline_before {
		return nil
	}
	mut name := ast.LocRef{
		loc: p.lexer.loc()
		ref: p.store_name_in_ref(p.lexer.identifier)
	}
	p.lexer.next()
	return &name
}

fn (p &Parser) parse_path() (logger.Range, string, &ast.ImportAssertOrWith, ast.ImportRecordFlags) {
	mut flags := 0
	mut path_range := p.lexer.range()
	mut path_text := helpers.utf_16_to_string(p.lexer.string_literal())
	if p.lexer.token == js_lexer.tn_o_substitution_template_literal {
		p.lexer.next()
	} else {
		p.lexer.expect(js_lexer.ts_tring_literal)
	}
	mut assertOrWith := 0
	if p.lexer.token == js_lexer.tw_ith || !p.lexer.has_newline_before
		&& p.lexer.is_contextual_keyword('assert') {
		mut entries := []ast.AssertOrWithEntry{}
		mut duplicates := map[string]logger.Range{}
		mut keyword := ast.with_keyword
		if p.lexer.token != js_lexer.tw_ith {
			keyword = ast.assert_keyword
		}
		mut keyword_loc := p.save_expr_comments_here()
		p.lexer.next()
		mut open_brace_loc := p.save_expr_comments_here()
		p.lexer.expect(js_lexer.to_pen_brace)
		for p.lexer.token != js_lexer.tc_lose_brace {
			mut key_loc := p.save_expr_comments_here()
			mut prefer_quoted_key := false
			mut key := []u16{}
			mut keyText := 0
			if p.lexer.is_identifier_or_keyword() {
				key_text = p.lexer.identifier.string
				key = helpers.string_to_utf_16(key_text)
			} else if p.lexer.token == js_lexer.ts_tring_literal {
				key = p.lexer.string_literal()
				key_text = helpers.utf_16_to_string(key)
				prefer_quoted_key = !p.options.minify_syntax
			} else {
				p.lexer.expect(js_lexer.ti_dentifier)
			}
			mut prev_range, ok := duplicates[key_text]
			if ok {
				mut what := 'attribute'
				if keyword == ast.assert_keyword {
					what = 'assertion'
				}
				p.log.add_error_with_notes(&p.tracker, p.lexer.range(), strconv.v_sprintf('Duplicate import %s %q',
					what, key_text), [
					p.tracker.msg_data(prev_range, strconv.v_sprintf('The first %q was here:',
						key_text)),
				])
			}
			duplicates[key_text] = p.lexer.range()
			p.lexer.next()
			p.lexer.expect(js_lexer.tc_olon)
			mut value_loc := p.save_expr_comments_here()
			mut value := p.lexer.string_literal()
			p.lexer.expect(js_lexer.ts_tring_literal)
			entries << ast.AssertOrWithEntry{
				key:               key
				key_loc:           key_loc
				value:             value
				value_loc:         value_loc
				prefer_quoted_key: prefer_quoted_key
			}
			if keyword == ast.assert_keyword && helpers.utf_16_equals_string(key, 'type') && helpers.utf_16_equals_string(value,
				'json') {
				flags |= ast.assert_type_json
			}
			if p.lexer.token != js_lexer.tc_omma {
				break
			}
			p.lexer.next()
		}
		mut close_brace_loc := p.save_expr_comments_here()
		p.lexer.expect(js_lexer.tc_lose_brace)
		if keyword == ast.assert_keyword {
			p.maybe_warn_about_assert_keyword(keyword_loc)
		}
		assert_or_with = &ast.ImportAssertOrWith{
			entries:               entries
			keyword:               keyword
			keyword_loc:           keyword_loc
			inner_open_brace_loc:  open_brace_loc
			inner_close_brace_loc: close_brace_loc
		}
	}
	return path_range, path_text, assert_or_with, flags
}

// Let people know if they probably should be using "with" instead of "assert"
fn (p &Parser) maybe_warn_about_assert_keyword(loc logger.Loc) {
	if p.options.unsupported_jsf_eatures.has(compat.import_assertions)
		&& !p.options.unsupported_jsf_eatures.has(compat.import_attributes) {
		mut where := config.pretty_print_target_environment(p.options.original_target_env,
			p.options.unsupported_jsf_eature_overrides_mask)
		mut msg := logger.Msg{
			kind:  logger.warning
			data:  p.tracker.msg_data(js_lexer.range_of_identifier(p.source, loc),
				'The "assert" keyword is not supported in ' + where)
			notes: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
			]
		}
		msg.data.location.suggestion = 'with'
		p.log.add_msg_id(logger.msg_id_js_assert_to_with, msg)
	}
}

// This assumes the "function" token has already been parsed
fn (p &Parser) parse_fn_stmt(loc logger.Loc, opts parseStmtOpts, is_async bool, async_range logger.Range) js_ast.Stmt {
	mut is_generator := p.lexer.token == js_lexer.ta_sterisk
	mut has_error := false
	if is_async {
		has_error = p.mark_async_fn(async_range, is_generator)
	}
	if is_generator {
		if !has_error {
			p.mark_syntax_feature(compat.generator, p.lexer.range())
		}
		p.lexer.next()
	}
	match opts.lexical_decl {
		lexical_decl_forbid {
			p.forbid_lexical_decl(loc)
		}
		lexical_decl_allow_fn_inside_if, lexical_decl_allow_fn_inside_label {
			if opts.is_type_script_declare || is_generator || is_async {
				p.forbid_lexical_decl(loc)
			}
		}
	}
	mut name := 0
	mut nameText := 0
	if !opts.is_name_optional || p.lexer.token == js_lexer.ti_dentifier {
		mut name_loc := p.lexer.loc()
		name_text = p.lexer.identifier.string
		if !is_async && p.fn_or_arrow_data_parse.await != allow_ident && name_text == 'await' {
			p.log.add_error(&p.tracker, js_lexer.range_of_identifier(p.source, name_loc),
				'Cannot use "await" as an identifier here:')
		}
		p.lexer.expect(js_lexer.ti_dentifier)
		name = &ast.LocRef{
			loc: name_loc
			ref: ast.invalid_ref
		}
	}
	if p.options.ts.parse {
		p.skip_type_script_type_parameters(allow_const_modifier)
	}
	mut ifStmtScopeIndex := 0
	mut has_if_scope := opts.lexical_decl == lexical_decl_allow_fn_inside_if
	if has_if_scope {
		if_stmt_scope_index = p.push_scope_for_parse_pass(js_ast.scope_block, loc)
	}
	mut scope_index := p.push_scope_for_parse_pass(js_ast.scope_function_args, p.lexer.loc())
	mut await := allow_ident
	mut yield := allow_ident
	if is_async {
		await = allow_expr
	}
	if is_generator {
		yield = allow_expr
	}
	mut fn_, had_body := p.parse_fn(name, logger.Range{}, 0, FnOrArrowDataParse{
		needs_async_loc:                    loc
		async_range:                        async_range
		await:                              await
		yield:                              yield
		is_type_script_declare:             opts.is_type_script_declare
		allow_missing_body_for_type_script: p.options.ts.parse
	})
	if opts.is_type_script_declare || !had_body {
		p.pop_and_discard_scope(scope_index)
		if has_if_scope {
			p.pop_and_discard_scope(if_stmt_scope_index)
		}
		if opts.is_type_script_declare && opts.is_namespace_scope && opts.is_export {
			p.has_non_local_export_declare_inside_namespace = true
		}
		return js_ast.Stmt{
			loc:  loc
			data: js_ast.st_ype_script_shared
		}
	}
	p.pop_scope()
	if name != nil {
		mut kind := ast.symbol_hoisted_function
		if is_generator || is_async {
			kind = ast.symbol_generator_or_async_function
		}
		name.ref = p.declare_symbol(kind, name.loc, name_text)
	}
	if has_if_scope {
		p.pop_scope()
	}
	fn_.has_if_scope = has_if_scope
	p.validate_function_name(fn_, fn_stmt)
	if opts.has_no_side_effects_comment && !p.options.ignore_dcea_nnotations {
		fn_.has_no_side_effects_comment = true
		if name != nil && !opts.is_type_script_declare {
			p.symbols[name.ref.inner_index].flags |= ast.call_can_be_unwrapped_if_unused
		}
	}
	return js_ast.Stmt{
		loc:  loc
		data: &js_ast.SFunction{
			fn_:       fn_
			is_export: opts.is_export
		}
	}
}

struct deferredDecorators {
pub mut:
	decorators []js_ast.Decorator
}

type decoratorContextFlags = u8

const decorator_before_class_expr = 1 << iota
const decorator_in_class_expr = 2 << iota
const decorator_in_fn_args = 3 << iota

fn (p &Parser) parse_decorators(decorator_scope &js_ast.Scope, class_keyword logger.Range, context decoratorContextFlags) []js_ast.Decorator {
	if p.lexer.token == js_lexer.ta_t {
		if p.options.ts.parse {
			if p.options.ts.config.experimental_decorators == config.true_ {
				if (context & decorator_in_class_expr) != 0 {
					p.lexer.add_range_error_with_notes(p.lexer.range(), 'TypeScript experimental decorators can only be used with class declarations',
						[
						p.tracker.msg_data(class_keyword, 'This is a class expression, not a class declaration:'),
					])
				} else if (context & decorator_before_class_expr) != 0 {
					p.log.add_error(&p.tracker, p.lexer.range(), 'TypeScript experimental decorators cannot be used in expression position')
				}
			}
			else {
				if (context & decorator_in_fn_args) != 0 && p.options.ts.config.experimental_decorators != config.true_ {
					p.log.add_error_with_notes(&p.tracker, p.lexer.range(), 'Parameter decorators only work when experimental decorators are enabled',
						[// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
					])
				}
			}
		}
		else {
			if (context & decorator_in_fn_args) != 0 {
				p.log.add_error(&p.tracker, p.lexer.range(), 'Parameter decorators are not allowed in JavaScript')
			}
		}
	}
	mut old_scope := p.current_scope
	p.current_scope = decorator_scope
	for p.lexer.token == js_lexer.ta_t {
		mut at_loc := p.lexer.loc()
		p.lexer.next()
		mut value := 0
		if p.options.ts.parse && p.options.ts.config.experimental_decorators == config.true_ {
			p.parse_experimental_decorator_nesting++
			value = p.parse_expr_with_flags(js_ast.ln_ew, expr_flag_decorator)
			p.parse_experimental_decorator_nesting--
		} else {
			value = p.parse_decorator()
		}
		decorators << js_ast.Decorator{
			value:              value
			at_loc:             at_loc
			omit_newline_after: !p.lexer.has_newline_before
		}
	}
	p.current_scope = old_scope
	return decorators
}

fn (p &Parser) parse_decorator() js_ast.Expr {
	if p.lexer.token == js_lexer.to_pen_paren {
		p.lexer.next()
		mut value := p.parse_expr(js_ast.ll_owest)
		p.lexer.expect(js_lexer.tc_lose_paren)
		return value
	}
	mut name := p.lexer.identifier
	mut name_range := p.lexer.range()
	p.lexer.expect(js_lexer.ti_dentifier)
	if p.fn_or_arrow_data_parse.await != allow_ident && name.string == 'await'
		|| p.fn_or_arrow_data_parse.yield != allow_ident && name.string == 'yield' {
		p.log.add_error(&p.tracker, name_range, strconv.v_sprintf('Cannot use %q as an identifier here:',
			name.string))
	}
	mut member_expr := js_ast.Expr{
		loc:  name_range.loc
		data: &js_ast.EIdentifier{
			ref: p.store_name_in_ref(name)
		}
	}
	mut syntaxError := 0
	mut wrap_range := name_range
	mut wrap_range_1 := name_range
	if syntax_error.location != nil {
		mut notes := []logger.MsgData{}
		mut text := p.source.text_for_range(wrap_range)
		if !text.contains_rune(`\n`) {
			mut note := p.tracker.msg_data(wrap_range, 'Wrap this decorator in parentheses to allow arbitrary expressions:')
			note.location.suggestion = strconv.v_sprintf('(%s)', text)
			notes = [note]
		}
		p.log.add_msg(logger.Msg{
			kind:  logger.error
			data:  syntax_error
			notes: notes
		})
	}
	return member_expr
}

type lexicalDecl = u8

enum lexicalDecl {
	lexical_decl_forbid
	lexical_decl_allow_all
	lexical_decl_allow_fn_inside_if
	lexical_decl_allow_fn_inside_label
}

struct parseStmtOpts {
pub mut:
	deferred_decorators         &DeferredDecorators = unsafe { nil }
	lexical_decl                lexicalDecl
	is_module_scope             bool
	is_namespace_scope          bool
	is_export                   bool
	is_export_default           bool
	is_name_optional            bool
	is_type_script_declare      bool
	is_for_loop_init            bool
	is_for_await_loop_init      bool
	allow_directive_prologue    bool
	has_no_side_effects_comment bool
	is_using_stmt               bool
}

fn (p &Parser) parse_stmt(opts parseStmtOpts) js_ast.Stmt {
	mut loc := p.lexer.loc()
	if (p.lexer.has_comment_before & js_lexer.no_side_effects_comment_before) != 0 {
		opts.has_no_side_effects_comment = true
	}
	p.lexer.comments_before_token = p.lexer.comments_before_token[..0]
	match p.lexer.token {
		js_lexer.ts_emicolon {
			p.lexer.next()
			return js_ast.Stmt{
				loc:  loc
				data: js_ast.se_mpty_shared
			}
		}
		js_lexer.te_xport {
			mut previous_export_keyword := p.esm_export_keyword
			if opts.is_module_scope {
				p.esm_export_keyword = p.lexer.range()
			} else if !opts.is_namespace_scope {
				p.lexer.unexpected()
			}
			p.lexer.next()
			match p.lexer.token {
				js_lexer.tc_lass, js_lexer.tc_onst, js_lexer.tf_unction, js_lexer.tv_ar,
				js_lexer.ta_t {
					opts.is_export = true
					return p.parse_stmt(opts)
				}
				js_lexer.ti_mport {
					if p.options.ts.parse && (opts.is_module_scope || opts.is_namespace_scope) {
						opts.is_export = true
						return p.parse_stmt(opts)
					}
					p.lexer.unexpected()
					return js_ast.Stmt{}
				}
				js_lexer.te_num {
					if !p.options.ts.parse {
						p.lexer.unexpected()
					}
					opts.is_export = true
					return p.parse_stmt(opts)
				}
				js_lexer.ti_dentifier {
					if p.lexer.is_contextual_keyword('let') {
						opts.is_export = true
						return p.parse_stmt(opts)
					}
					if p.lexer.is_contextual_keyword('as') {
						p.lexer.next()
						p.lexer.expect_contextual_keyword('namespace')
						p.lexer.expect(js_lexer.ti_dentifier)
						p.lexer.expect_or_insert_semicolon()
						return js_ast.Stmt{
							loc:  loc
							data: js_ast.st_ype_script_shared
						}
					}
					if p.lexer.is_contextual_keyword('async') {
						mut async_range := p.lexer.range()
						p.lexer.next()
						if p.lexer.has_newline_before {
							p.log.add_error(&p.tracker, logger.Range{
								loc: logger.Loc{
									start: async_range.end()
								}
							}, 'Unexpected newline after "async"')
							panic(js_lexer.LexerPanic{})
						}
						p.lexer.expect(js_lexer.tf_unction)
						opts.is_export = true
						return p.parse_fn_stmt(loc, opts, true, async_range)
					}
					if p.options.ts.parse {
						match p.lexer.identifier.string {
							'type' {
								mut type_range := p.lexer.range()
								p.lexer.next()
								if p.lexer.has_newline_before && p.lexer.token != js_lexer.to_pen_brace && p.lexer.token != js_lexer.ta_sterisk {
									p.log.add_error(&p.tracker, logger.Range{
										loc: logger.Loc{
											start: type_range.end()
										}
									}, 'Unexpected newline after "type"')
									panic(js_lexer.LexerPanic{})
								}
								p.skip_type_script_type_stmt(ParseStmtOpts{
									is_module_scope: opts.is_module_scope
									is_export:       true
								})
								return js_ast.Stmt{
									loc:  loc
									data: js_ast.st_ype_script_shared
								}
							}
							'namespace', 'abstract', 'module', 'interface' {
								opts.is_export = true
								return p.parse_stmt(opts)
							}
							'declare' {
								opts.is_export = true
								opts.lexical_decl = lexical_decl_allow_all
								opts.is_type_script_declare = true
								return p.parse_stmt(opts)
							}
						}
					}
					p.lexer.unexpected()
					return js_ast.Stmt{}
				}
				js_lexer.td_efault {
					if !opts.is_module_scope && (!opts.is_namespace_scope
						|| !opts.is_type_script_declare) {
						p.lexer.unexpected()
					}
					mut default_loc := p.lexer.loc()
					p.lexer.next()
					if (p.lexer.has_comment_before & js_lexer.no_side_effects_comment_before) != 0 {
						opts.has_no_side_effects_comment = true
					}
					mut create_default_name := fn () {
						mut default_name := ast.LocRef{
							loc: default_loc
							ref: p.new_symbol(ast.symbol_other, 'default')
						}
						p.current_scope.generated << default_name.ref
						return default_name
					}

					if p.lexer.is_contextual_keyword('async') {
						mut async_range_1 := p.lexer.range()
						p.lexer.next()
						if p.lexer.token == js_lexer.tf_unction && !p.lexer.has_newline_before {
							p.lexer.next()
							mut stmt := p.parse_fn_stmt(loc, ParseStmtOpts{
								is_name_optional:            true
								lexical_decl:                lexical_decl_allow_all
								has_no_side_effects_comment: opts.has_no_side_effects_comment
							}, true, async_range)
							_, ok := stmt.data
							if ok {
								return stmt
							}
							mut s, ok_1 := stmt.data
							if ok && s.fn_.name != nil {
								default_name = ast.LocRef{
									loc: default_loc
									ref: s.fn_.name.ref
								}
							} else {
								default_name = create_default_name()
							}
							return js_ast.Stmt{
								loc:  loc
								data: &js_ast.SExportDefault{
									default_name: default_name
									value:        stmt
								}
							}
						}
						mut default_name_1 := create_default_name()
						mut expr := p.parse_suffix(p.parse_async_prefix_expr(async_range,
							js_ast.lc_omma, 0), js_ast.lc_omma, nil, 0)
						p.lexer.expect_or_insert_semicolon()
						return js_ast.Stmt{
							loc:  loc
							data: &js_ast.SExportDefault{
								default_name: default_name
								value:        js_ast.Stmt{
									loc:  loc
									data: &js_ast.SExpr{
										value: expr
									}
								}
							}
						}
					}
					if p.lexer.token == js_lexer.tf_unction
						|| p.lexer.token == js_lexer.tc_lass
						|| p.lexer.token == js_lexer.ta_t || p.options.ts.parse
						&& p.lexer.is_contextual_keyword('interface') {
						mut stmt_1 := p.parse_stmt(ParseStmtOpts{
							deferred_decorators:         opts.deferred_decorators
							is_name_optional:            true
							is_export_default:           true
							lexical_decl:                lexical_decl_allow_all
							has_no_side_effects_comment: opts.has_no_side_effects_comment
						})
						mut s_1 := stmt.data
						match s {
							js_ast.STypeScript, js_ast.SExpr {
								return stmt
							}
							js_ast.SFunction {
								if s.fn_.name != nil {
									default_name = ast.LocRef{
										loc: default_loc
										ref: s.fn_.name.ref
									}
								} else {
									default_name = create_default_name()
								}
							}
							js_ast.SClass {
								if s.class.name != nil {
									default_name = ast.LocRef{
										loc: default_loc
										ref: s.class.name.ref
									}
								} else {
									default_name = create_default_name()
								}
							}
							else {
								panic('Internal error')
							}
						}
						return js_ast.Stmt{
							loc:  loc
							data: &js_ast.SExportDefault{
								default_name: default_name
								value:        stmt
							}
						}
					}
					mut is_identifier := p.lexer.token == js_lexer.ti_dentifier
					mut name := p.lexer.identifier.string
					mut expr_1 := p.parse_expr(js_ast.lc_omma)
					if p.options.ts.parse && is_identifier && name == 'abstract'
						&& !p.lexer.has_newline_before {
						_, ok_2 := expr.data
						if ok && p.lexer.token == js_lexer.tc_lass {
							mut stmt_2 := p.parse_class_stmt(loc, ParseStmtOpts{
								deferred_decorators: opts.deferred_decorators
								is_name_optional:    true
							})
							mut s_2, ok_3 := stmt.data
							if ok && s.class.name != nil {
								default_name = ast.LocRef{
									loc: default_loc
									ref: s.class.name.ref
								}
							} else {
								default_name = create_default_name()
							}
							return js_ast.Stmt{
								loc:  loc
								data: &js_ast.SExportDefault{
									default_name: default_name
									value:        stmt
								}
							}
						}
					}
					p.lexer.expect_or_insert_semicolon()
					mut default_name_2 := create_default_name()
					return js_ast.Stmt{
						loc:  loc
						data: &js_ast.SExportDefault{
							default_name: default_name
							value:        js_ast.Stmt{
								loc:  loc
								data: &js_ast.SExpr{
									value: expr
								}
							}
						}
					}
				}
				js_lexer.ta_sterisk {
					if !opts.is_module_scope && (!opts.is_namespace_scope
						|| !opts.is_type_script_declare) {
						p.lexer.unexpected()
					}
					p.lexer.next()
					mut namespaceRef := 0
					mut alias := 0
					mut pathRange := 0
					mut pathText := 0
					mut assertOrWith := 0
					mut flags := 0
					if p.lexer.is_contextual_keyword('as') {
						p.lexer.next()
						mut name_1 := p.parse_clause_alias('export')
						namespace_ref = p.store_name_in_ref(name)
						alias = &js_ast.ExportStarAlias{
							loc:           p.lexer.loc()
							original_name: name.string
						}
						p.lexer.next()
						p.lexer.expect_contextual_keyword('from')
						path_range, path_text, assert_or_with, flags = p.parse_path()
					} else {
						p.lexer.expect_contextual_keyword('from')
						path_range, path_text, assert_or_with, flags = p.parse_path()
						mut name_2 := js_ast.generate_non_unique_name_from_path(path_text) + '_star'
						namespace_ref = p.store_name_in_ref(js_lexer.MaybeSubstring{
							string: name
						})
					}
					mut import_record_index := p.add_import_record(ast.import_stmt, path_range,
						path_text, assert_or_with, flags)
					p.current_scope.is_after_const_local_prefix = true
					p.lexer.expect_or_insert_semicolon()
					return js_ast.Stmt{
						loc:  loc
						data: &js_ast.SExportStar{
							namespace_ref:       namespace_ref
							alias:               alias
							import_record_index: import_record_index
						}
					}
				}
				js_lexer.to_pen_brace {
					if !opts.is_module_scope && (!opts.is_namespace_scope
						|| !opts.is_type_script_declare) {
						p.lexer.unexpected()
					}
					mut items, is_single_line := p.parse_export_clause()
					if p.lexer.is_contextual_keyword('from') {
						p.lexer.next()
						mut path_loc, path_text_1, assert_or_with_1, flags_1 := p.parse_path()
						mut import_record_index_1 := p.add_import_record(ast.import_stmt,
							path_loc, path_text, assert_or_with, flags)
						mut name_3 := 'import_' +
							js_ast.generate_non_unique_name_from_path(path_text)
						mut namespace_ref_1 := p.store_name_in_ref(js_lexer.MaybeSubstring{
							string: name
						})
						p.current_scope.is_after_const_local_prefix = true
						p.lexer.expect_or_insert_semicolon()
						return js_ast.Stmt{
							loc:  loc
							data: &js_ast.SExportFrom{
								items:               items
								namespace_ref:       namespace_ref
								import_record_index: import_record_index
								is_single_line:      is_single_line
							}
						}
					}
					p.lexer.expect_or_insert_semicolon()
					return js_ast.Stmt{
						loc:  loc
						data: &js_ast.SExportClause{
							items:          items
							is_single_line: is_single_line
						}
					}
				}
				js_lexer.te_quals {
					p.esm_export_keyword = previous_export_keyword
					if p.options.ts.parse {
						p.lexer.next()
						mut value := p.parse_expr(js_ast.ll_owest)
						p.lexer.expect_or_insert_semicolon()
						return js_ast.Stmt{
							loc:  loc
							data: &js_ast.SExportEquals{
								value: value
							}
						}
					}
					p.lexer.unexpected()
					return js_ast.Stmt{}
				}
				else {
					p.lexer.unexpected()
					return js_ast.Stmt{}
				}
			}
		}
		js_lexer.tf_unction {
			p.lexer.next()
			return p.parse_fn_stmt(loc, opts, false, logger.Range{})
		}
		js_lexer.te_num {
			if !p.options.ts.parse {
				p.lexer.unexpected()
			}
			return p.parse_type_script_enum_stmt(loc, opts)
		}
		js_lexer.ta_t {
			mut scope_index := p.scopes_in_order.len
			mut decorators := p.parse_decorators(p.current_scope, logger.Range{}, 0)
			if opts.deferred_decorators != nil {
				p.log.add_error(&p.tracker, logger.Range{
					loc: loc
					len: 1
				}, 'Decorators are not valid here')
				p.discard_scopes_up_to(scope_index)
				return p.parse_stmt(opts)
			}
			opts.deferred_decorators = &DeferredDecorators{
				decorators: decorators
			}
			mut stmt_3 := p.parse_stmt(opts)
			mut s_3 := stmt.data
			match s {
				js_ast.SClass {
					return stmt
				}
				js_ast.SExportDefault {
					// append no rhs

					// lhs.len==0
				}
				js_ast.STypeScript {
					if s.was_declare_class {
						p.discard_scopes_up_to(scope_index)
						return stmt
					}
				}
			}
			p.log.add_error(&p.tracker, logger.Range{
				loc: loc
				len: 1
			}, 'Decorators are not valid here')
			stmt.data = js_ast.st_ype_script_shared
			p.discard_scopes_up_to(scope_index)
			return stmt
		}
		js_lexer.tc_lass {
			if opts.lexical_decl != lexical_decl_allow_all {
				p.forbid_lexical_decl(loc)
			}
			return p.parse_class_stmt(loc, opts)
		}
		js_lexer.tv_ar {
			p.lexer.next()
			mut decls := p.parse_and_declare_decls(ast.symbol_hoisted, opts)
			p.lexer.expect_or_insert_semicolon()
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SLocal{
					kind:      js_ast.local_var
					decls:     decls
					is_export: opts.is_export
				}
			}
		}
		js_lexer.tc_onst {
			if opts.lexical_decl != lexical_decl_allow_all {
				p.forbid_lexical_decl(loc)
			}
			p.mark_syntax_feature(compat.const_and_let, p.lexer.range())
			p.lexer.next()
			if p.options.ts.parse && p.lexer.token == js_lexer.te_num {
				return p.parse_type_script_enum_stmt(loc, opts)
			}
			mut decls_1 := p.parse_and_declare_decls(ast.symbol_const, opts)
			p.lexer.expect_or_insert_semicolon()
			if !opts.is_type_script_declare {
				p.require_initializers(js_ast.local_const, decls)
			}
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SLocal{
					kind:      js_ast.local_const
					decls:     decls
					is_export: opts.is_export
				}
			}
		}
		js_lexer.ti_f {
			p.lexer.next()
			p.lexer.expect(js_lexer.to_pen_paren)
			mut test := p.parse_expr(js_ast.ll_owest)
			p.lexer.expect(js_lexer.tc_lose_paren)
			mut is_single_line_yes := !p.lexer.has_newline_before && p.lexer.token != js_lexer.to_pen_brace
			mut yes := p.parse_stmt(ParseStmtOpts{
				lexical_decl: lexical_decl_allow_fn_inside_if
			})
			mut noOrNil := 0
			mut isSingleLineNo := 0
			if p.lexer.token == js_lexer.te_lse {
				p.lexer.next()
				is_single_line_no = !p.lexer.has_newline_before && p.lexer.token != js_lexer.to_pen_brace
				no_or_nil = p.parse_stmt(ParseStmtOpts{
					lexical_decl: lexical_decl_allow_fn_inside_if
				})
			}
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SIf{
					test:               test
					yes:                yes
					no_or_nil:          no_or_nil
					is_single_line_yes: is_single_line_yes
					is_single_line_no:  is_single_line_no
				}
			}
		}
		js_lexer.td_o {
			p.lexer.next()
			mut body := p.parse_stmt(ParseStmtOpts{})
			p.lexer.expect(js_lexer.tw_hile)
			p.lexer.expect(js_lexer.to_pen_paren)
			mut test_1 := p.parse_expr(js_ast.ll_owest)
			p.lexer.expect(js_lexer.tc_lose_paren)
			if p.lexer.token == js_lexer.ts_emicolon {
				p.lexer.next()
			}
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SDoWhile{
					body: body
					test: test
				}
			}
		}
		js_lexer.tw_hile {
			p.lexer.next()
			p.lexer.expect(js_lexer.to_pen_paren)
			mut test_2 := p.parse_expr(js_ast.ll_owest)
			p.lexer.expect(js_lexer.tc_lose_paren)
			mut is_single_line_body := !p.lexer.has_newline_before && p.lexer.token != js_lexer.to_pen_brace
			mut body_1 := p.parse_stmt(ParseStmtOpts{})
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SWhile{
					test:                test
					body:                body
					is_single_line_body: is_single_line_body
				}
			}
		}
		js_lexer.tw_ith {
			p.lexer.next()
			p.lexer.expect(js_lexer.to_pen_paren)
			mut test_3 := p.parse_expr(js_ast.ll_owest)
			mut body_loc := p.lexer.loc()
			p.lexer.expect(js_lexer.tc_lose_paren)
			p.push_scope_for_parse_pass(js_ast.scope_with, body_loc)
			mut is_single_line_body_1 := !p.lexer.has_newline_before && p.lexer.token != js_lexer.to_pen_brace
			mut body_2 := p.parse_stmt(ParseStmtOpts{})
			p.pop_scope()
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SWith{
					value:               test
					body_loc:            body_loc
					body:                body
					is_single_line_body: is_single_line_body
				}
			}
		}
		js_lexer.ts_witch {
			p.lexer.next()
			p.lexer.expect(js_lexer.to_pen_paren)
			mut test_4 := p.parse_expr(js_ast.ll_owest)
			p.lexer.expect(js_lexer.tc_lose_paren)
			mut body_loc_1 := p.lexer.loc()
			p.push_scope_for_parse_pass(js_ast.scope_block, body_loc)
			defer {
				p.pop_scope
			}
			p.lexer.expect(js_lexer.to_pen_brace)
			mut cases := []
			{}
			mut found_default := false
			for p.lexer.token != js_lexer.tc_lose_brace {
				mut body_3 := []
				{}
				mut case_loc := p.save_expr_comments_here()
				if p.lexer.token == js_lexer.td_efault {
					if found_default {
						p.log.add_error(&p.tracker, p.lexer.range(), 'Multiple default clauses are not allowed')
						panic(js_lexer.LexerPanic{})
					}
					found_default = true
					p.lexer.next()
					p.lexer.expect(js_lexer.tc_olon)
				} else {
					p.lexer.expect(js_lexer.tc_ase)
					value = p.parse_expr(js_ast.ll_owest)
					p.lexer.expect(js_lexer.tc_olon)
				}
				if p.lexer.token == js_lexer.td_efault {
					if found_default {
						p.log.add_error(&p.tracker, p.lexer.range(), 'Multiple default clauses are not allowed')
						panic(js_lexer.LexerPanic{})
					}
					found_default = true
					p.lexer.next()
					p.lexer.expect(js_lexer.tc_olon)
				} else {
					p.lexer.expect(js_lexer.tc_ase)
					value = p.parse_expr(js_ast.ll_owest)
					p.lexer.expect(js_lexer.tc_olon)
				}
				cases << js_ast.Case{
					value_or_nil: value
					body:         body
					loc:          case_loc
				}
			}
			mut close_brace_loc := p.lexer.loc()
			p.lexer.expect(js_lexer.tc_lose_brace)
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SSwitch{
					test:            test
					cases:           cases
					body_loc:        body_loc
					close_brace_loc: close_brace_loc
				}
			}
		}
		js_lexer.tt_ry {
			p.lexer.next()
			mut block_loc := p.lexer.loc()
			p.lexer.expect(js_lexer.to_pen_brace)
			p.push_scope_for_parse_pass(js_ast.scope_block, loc)
			mut body_4 := p.parse_stmts_up_to(js_lexer.tc_lose_brace, ParseStmtOpts{})
			p.pop_scope()
			mut close_brace_loc_1 := p.lexer.loc()
			p.lexer.next()
			mut catch := nil
			mut finally := nil
			if p.lexer.token == js_lexer.tc_atch {
				mut catch_loc := p.lexer.loc()
				p.push_scope_for_parse_pass(js_ast.scope_catch_binding, catch_loc)
				p.lexer.next()
				mut bindingOrNil := 0
				if p.lexer.token == js_lexer.to_pen_brace {
					if p.options.unsupported_jsf_eatures.has(compat.optional_catch_binding) {
						mut ref := p.new_symbol(ast.symbol_other, 'e')
						p.current_scope.generated << ref
						binding_or_nil = js_ast.Binding{
							loc:  p.lexer.loc()
							data: &js_ast.BIdentifier{
								ref: ref
							}
						}
					}
				} else {
					p.lexer.expect(js_lexer.to_pen_paren)
					binding_or_nil = p.parse_binding(ParseBindingOpts{})
					if p.options.ts.parse && p.lexer.token == js_lexer.tc_olon {
						p.lexer.expect(js_lexer.tc_olon)
						p.skip_type_script_type(js_ast.ll_owest)
					}
					p.lexer.expect(js_lexer.tc_lose_paren)
					mut kind := ast.symbol_other
					_, ok_4 := binding_or_nil.data
					if ok {
						kind = ast.symbol_catch_identifier
					}
					p.declare_binding(kind, binding_or_nil, ParseStmtOpts{})
				}
				mut block_loc_1 := p.lexer.loc()
				p.lexer.expect(js_lexer.to_pen_brace)
				p.push_scope_for_parse_pass(js_ast.scope_block, block_loc)
				mut stmts := p.parse_stmts_up_to(js_lexer.tc_lose_brace, ParseStmtOpts{})
				p.pop_scope()
				mut close_brace_loc_2 := p.lexer.loc()
				p.lexer.next()
				catch = &js_ast.Catch{
					loc:            catch_loc
					binding_or_nil: binding_or_nil
					block_loc:      block_loc
					block:          js_ast.SBlock{
						stmts:           stmts
						close_brace_loc: close_brace_loc
					}
				}
				p.pop_scope()
			}
			if p.lexer.token == js_lexer.tf_inally || catch == nil {
				mut finally_loc := p.lexer.loc()
				p.push_scope_for_parse_pass(js_ast.scope_block, finally_loc)
				p.lexer.expect(js_lexer.tf_inally)
				p.lexer.expect(js_lexer.to_pen_brace)
				mut stmts_1 := p.parse_stmts_up_to(js_lexer.tc_lose_brace, ParseStmtOpts{})
				mut close_brace_loc_3 := p.lexer.loc()
				p.lexer.next()
				finally = &js_ast.Finally{
					loc:   finally_loc
					block: js_ast.SBlock{
						stmts:           stmts
						close_brace_loc: close_brace_loc
					}
				}
				p.pop_scope()
			}
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.STry{
					block_loc: block_loc
					block:     js_ast.SBlock{
						stmts:           body
						close_brace_loc: close_brace_loc
					}
					catch:     catch
					finally:   finally
				}
			}
		}
		js_lexer.tf_or {
			p.push_scope_for_parse_pass(js_ast.scope_block, loc)
			defer {
				p.pop_scope
			}
			p.lexer.next()
			mut awaitRange := 0
			if p.lexer.is_contextual_keyword('await') {
				await_range = p.lexer.range()
				if p.fn_or_arrow_data_parse.await != allow_expr {
					p.log.add_error(&p.tracker, await_range, 'Cannot use "await" outside an async function')
					await_range = logger.Range{}
				} else {
					mut did_generate_error := false
					if p.fn_or_arrow_data_parse.is_top_level {
						p.top_level_await_keyword = await_range
					}
					if !did_generate_error && p.options.unsupported_jsf_eatures.has(compat.async_await) && p.options.unsupported_jsf_eatures.has(compat.generator) {
						p.mark_syntax_feature(compat.for_await, await_range)
					}
				}
				p.lexer.next()
			}
			p.lexer.expect(js_lexer.to_pen_paren)
			mut initOrNil := 0
			mut testOrNil := 0
			mut updateOrNil := 0
			p.allow_in = false
			mut badLetRange := 0
			if p.lexer.is_contextual_keyword('let') {
				bad_let_range = p.lexer.range()
			}
			mut decls_2 := []
			{}
			mut init_loc := p.lexer.loc()
			mut is_var := false
			match p.lexer.token {
				js_lexer.tv_ar {
					is_var = true
					p.lexer.next()
					decls = p.parse_and_declare_decls(ast.symbol_hoisted, ParseStmtOpts{})
					init_or_nil = js_ast.Stmt{
						loc:  init_loc
						data: &js_ast.SLocal{
							kind:  js_ast.local_var
							decls: decls
						}
					}
				}
				js_lexer.tc_onst {
					p.mark_syntax_feature(compat.const_and_let, p.lexer.range())
					p.lexer.next()
					decls = p.parse_and_declare_decls(ast.symbol_const, ParseStmtOpts{})
					init_or_nil = js_ast.Stmt{
						loc:  init_loc
						data: &js_ast.SLocal{
							kind:  js_ast.local_const
							decls: decls
						}
					}
				}
				js_lexer.ts_emicolon {}
				else {
					expr, stmt, decls = p.parse_expr_or_let_or_using_stmt(ParseStmtOpts{
						lexical_decl:           lexical_decl_allow_all
						is_for_loop_init:       true
						is_for_await_loop_init: await_range.len > 0
					})
					if stmt.data != nil {
						bad_let_range = logger.Range{}
						init_or_nil = stmt
					} else {
						init_or_nil = js_ast.Stmt{
							loc:  expr.loc
							data: &js_ast.SExpr{
								value: expr
							}
						}
					}
				}
			}
			p.allow_in = true
			if p.lexer.is_contextual_keyword('of') || await_range.len > 0 {
				if bad_let_range.len > 0 {
					p.log.add_error(&p.tracker, bad_let_range, '"let" must be wrapped in parentheses to be used as an expression here:')
				}
				if await_range.len > 0 && !p.lexer.is_contextual_keyword('of') {
					if init_or_nil.data != nil {
						p.lexer.expected_string('"of"')
					} else {
						p.lexer.unexpected()
					}
				}
				p.forbid_initializers(decls, 'of', false)
				p.mark_syntax_feature(compat.for_of, p.lexer.range())
				p.lexer.next()
				mut value_1 := p.parse_expr(js_ast.lc_omma)
				p.lexer.expect(js_lexer.tc_lose_paren)
				mut is_single_line_body_2 := !p.lexer.has_newline_before && p.lexer.token != js_lexer.to_pen_brace
				mut body_5 := p.parse_stmt(ParseStmtOpts{})
				return js_ast.Stmt{
					loc:  loc
					data: &js_ast.SForOf{
						await:               await_range
						init:                init_or_nil
						value:               value
						body:                body
						is_single_line_body: is_single_line_body
					}
				}
			}
			if p.lexer.token == js_lexer.ti_n {
				p.forbid_initializers(decls, 'in', is_var)
				if decls.len == 1 {
					mut local, ok_5 := init_or_nil.data
					if ok {
						if local.kind == js_ast.local_using {
							p.log.add_error(&p.tracker, js_lexer.range_of_identifier(p.source,
								init_or_nil.loc), '"using" declarations are not allowed here')
						} else if local.kind == js_ast.local_await_using {
							p.log.add_error(&p.tracker, js_lexer.range_of_identifier(p.source,
								init_or_nil.loc), '"await using" declarations are not allowed here')
						}
					}
				}
				p.lexer.next()
				mut value_2 := p.parse_expr(js_ast.ll_owest)
				p.lexer.expect(js_lexer.tc_lose_paren)
				mut is_single_line_body_3 := !p.lexer.has_newline_before && p.lexer.token != js_lexer.to_pen_brace
				mut body_6 := p.parse_stmt(ParseStmtOpts{})
				return js_ast.Stmt{
					loc:  loc
					data: &js_ast.SForIn{
						init:                init_or_nil
						value:               value
						body:                body
						is_single_line_body: is_single_line_body
					}
				}
			}
			p.lexer.expect(js_lexer.ts_emicolon)
			mut local_1, ok_6 := init_or_nil.data
			if ok && local.kind == js_ast.local_await_using {
				p.log.add_error(&p.tracker, js_lexer.range_of_identifier(p.source, init_or_nil.loc),
					'"await using" declarations are not allowed here')
			}
			mut local_2, ok_7 := init_or_nil.data
			if ok && (local.kind == js_ast.local_const || local.kind == js_ast.local_using) {
				p.require_initializers(local.kind, decls)
			}
			if p.lexer.token != js_lexer.ts_emicolon {
				test_or_nil = p.parse_expr(js_ast.ll_owest)
			}
			p.lexer.expect(js_lexer.ts_emicolon)
			if p.lexer.token != js_lexer.tc_lose_paren {
				update_or_nil = p.parse_expr(js_ast.ll_owest)
			}
			p.lexer.expect(js_lexer.tc_lose_paren)
			mut is_single_line_body_4 := !p.lexer.has_newline_before && p.lexer.token != js_lexer.to_pen_brace
			mut body_7 := p.parse_stmt(ParseStmtOpts{})
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SFor{
					init_or_nil:         init_or_nil
					test_or_nil:         test_or_nil
					update_or_nil:       update_or_nil
					body:                body
					is_single_line_body: is_single_line_body
				}
			}
		}
		js_lexer.ti_mport {
			mut previous_import_statement_keyword := p.esm_import_statement_keyword
			p.esm_import_statement_keyword = p.lexer.range()
			p.lexer.next()
			mut stmt_4 := js_ast.SImport{}
			mut was_originally_bare_import := false
			if (opts.is_export || (opts.is_namespace_scope && !opts.is_type_script_declare)) && p.lexer.token != js_lexer.ti_dentifier {
				p.lexer.expected(js_lexer.ti_dentifier)
			}
			if (opts.is_export || (opts.is_namespace_scope && !opts.is_type_script_declare)) && p.lexer.token != js_lexer.ti_dentifier {
				p.lexer.expected(js_lexer.ti_dentifier)
			}
			mut path_loc_1, path_text_2, assert_or_with_2, flags_2 := p.parse_path()
			p.lexer.expect_or_insert_semicolon()
			if p.options.ts.parse && p.options.ts.config.unused_import_flags() == config.tsu_nused_import_keep_values && stmt.items != nil && &stmt.items.len == 0 {
				if stmt.default_name == nil {
					return js_ast.Stmt{
						loc:  loc
						data: js_ast.st_ype_script_shared
					}
				}
				stmt.items = nil
			}
			if was_originally_bare_import {
				flags |= ast.was_originally_bare_import
			}
			stmt.import_record_index = p.add_import_record(ast.import_stmt, path_loc,
				path_text, assert_or_with, flags)
			if stmt.star_name_loc != nil {
				mut name_4 := p.load_name_from_ref(stmt.namespace_ref)
				stmt.namespace_ref = p.declare_symbol(ast.symbol_import, &stmt.star_name_loc,
					name)
			} else {
				mut name_5 := 'import_' + js_ast.generate_non_unique_name_from_path(path_text)
				stmt.namespace_ref = p.new_symbol(ast.symbol_other, name)
				p.current_scope.generated << stmt.namespace_ref
			}
			mut item_refs := map[string]ast.LocRef{}
			if stmt.default_name != nil {
				mut name_6 := p.load_name_from_ref(stmt.default_name.ref)
				mut ref_1 := p.declare_symbol(ast.symbol_import, stmt.default_name.loc,
					name)
				p.is_import_item[ref] = true
				stmt.default_name.ref = ref
			}
			if stmt.items != nil {
				for i, item in &stmt.items {
					mut name_7 := p.load_name_from_ref(item.name.ref)
					mut ref_2 := p.declare_symbol(ast.symbol_import, item.name.loc, name)
					p.check_for_unrepresentable_identifier(item.alias_loc, item.alias)
					p.is_import_item[ref] = true
					(&stmt.items)[i].name.ref = ref
					item_refs[item.alias] = ast.LocRef{
						loc: item.name.loc
						ref: ref
					}
				}
			}
			p.import_items_for_namespace[stmt.namespace_ref] = NamespaceImportItems{
				entries:             item_refs
				import_record_index: stmt.import_record_index
			}
			p.current_scope.is_after_const_local_prefix = true
			return js_ast.Stmt{
				loc:  loc
				data: &stmt
			}
		}
		js_lexer.tb_reak {
			p.lexer.next()
			mut name_8 := p.parse_label_name()
			p.lexer.expect_or_insert_semicolon()
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SBreak{
					label: name
				}
			}
		}
		js_lexer.tc_ontinue {
			p.lexer.next()
			mut name_9 := p.parse_label_name()
			p.lexer.expect_or_insert_semicolon()
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SContinue{
					label: name
				}
			}
		}
		js_lexer.tr_eturn {
			if p.fn_or_arrow_data_parse.is_return_disallowed {
				p.log.add_error(&p.tracker, p.lexer.range(), 'A return statement cannot be used here:')
			}
			p.lexer.next()
			if p.lexer.token != js_lexer.ts_emicolon && !p.lexer.has_newline_before
				&& p.lexer.token != js_lexer.tc_lose_brace
				&& p.lexer.token != js_lexer.te_nd_of_file {
				value = p.parse_expr(js_ast.ll_owest)
			}
			p.latest_return_had_semicolon = p.lexer.token == js_lexer.ts_emicolon
			p.lexer.expect_or_insert_semicolon()
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SReturn{
					value_or_nil: value
				}
			}
		}
		js_lexer.tt_hrow {
			p.lexer.next()
			if p.lexer.has_newline_before {
				mut end_loc := logger.Loc{
					start: loc.start + 5
				}
				p.log.add_error(&p.tracker, logger.Range{
					loc: end_loc
				}, 'Unexpected newline after "throw"')
				return js_ast.Stmt{
					loc:  loc
					data: &js_ast.SThrow{
						value: js_ast.Expr{
							loc:  end_loc
							data: js_ast.en_ull_shared
						}
					}
				}
			}
			mut expr_2 := p.parse_expr(js_ast.ll_owest)
			p.lexer.expect_or_insert_semicolon()
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SThrow{
					value: expr
				}
			}
		}
		js_lexer.td_ebugger {
			p.lexer.next()
			p.lexer.expect_or_insert_semicolon()
			return js_ast.Stmt{
				loc:  loc
				data: js_ast.sd_ebugger_shared
			}
		}
		js_lexer.to_pen_brace {
			p.push_scope_for_parse_pass(js_ast.scope_block, loc)
			defer {
				p.pop_scope
			}
			p.lexer.next()
			mut stmts_2 := p.parse_stmts_up_to(js_lexer.tc_lose_brace, ParseStmtOpts{})
			mut close_brace_loc_4 := p.lexer.loc()
			p.lexer.next()
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SBlock{
					stmts:           stmts
					close_brace_loc: close_brace_loc
				}
			}
		}
		else {
			mut is_identifier_1 := p.lexer.token == js_lexer.ti_dentifier
			mut name_range := p.lexer.range()
			mut name_10 := p.lexer.identifier.string
			if is_identifier && p.lexer.raw() == 'async' {
				p.lexer.next()
				if p.lexer.token == js_lexer.tf_unction && !p.lexer.has_newline_before {
					p.lexer.next()
					return p.parse_fn_stmt(name_range.loc, opts, true, name_range)
				}
				expr = p.parse_suffix(p.parse_async_prefix_expr(name_range, js_ast.ll_owest,
					0), js_ast.ll_owest, nil, 0)
			} else {
				expr, stmt, _ = p.parse_expr_or_let_or_using_stmt(opts)
				if stmt.data != nil {
					p.lexer.expect_or_insert_semicolon()
					return stmt
				}
			}
			if is_identifier {
				mut ident, ok_8 := expr.data
				if ok {
					if p.lexer.token == js_lexer.tc_olon && opts.deferred_decorators == nil {
						p.push_scope_for_parse_pass(js_ast.scope_label, loc)
						defer {
							p.pop_scope
						}
						p.lexer.next()
						mut name_11 := ast.LocRef{
							loc: expr.loc
							ref: ident.ref
						}
						mut nested_opts := ParseStmtOpts{}
						if opts.lexical_decl == lexical_decl_allow_all
							|| opts.lexical_decl == lexical_decl_allow_fn_inside_label {
							nested_opts.lexical_decl = lexical_decl_allow_fn_inside_label
						}
						mut is_single_line_stmt := !p.lexer.has_newline_before && p.lexer.token != js_lexer.to_pen_brace
						mut stmt_5 := p.parse_stmt(nested_opts)
						return js_ast.Stmt{
							loc:  loc
							data: &js_ast.SLabel{
								name:                name
								stmt:                stmt
								is_single_line_stmt: is_single_line_stmt
							}
						}
					}
					if p.options.ts.parse {
						match name {
							'type' {
								if !p.lexer.has_newline_before && p.lexer.token == js_lexer.ti_dentifier {
									p.skip_type_script_type_stmt(ParseStmtOpts{
										is_module_scope: opts.is_module_scope
									})
									return js_ast.Stmt{
										loc:  loc
										data: js_ast.st_ype_script_shared
									}
								}
							}
							'namespace', 'module' {
								if !p.lexer.has_newline_before && (opts.is_module_scope
									|| opts.is_namespace_scope) && (
									p.lexer.token == js_lexer.ti_dentifier
									|| p.lexer.token == js_lexer.ts_tring_literal
									&& opts.is_type_script_declare) {
									return p.parse_type_script_namespace_stmt(loc, opts)
								}
							}
							'interface' {
								if !p.lexer.has_newline_before || opts.is_export_default {
									p.skip_type_script_interface_stmt(ParseStmtOpts{
										is_module_scope: opts.is_module_scope
									})
									return js_ast.Stmt{
										loc:  loc
										data: js_ast.st_ype_script_shared
									}
								}
								if opts.is_export {
									p.log.add_error(&p.tracker, name_range, 'Unexpected "interface"')
									panic(js_lexer.LexerPanic{})
								}
							}
							'abstract' {
								if !p.lexer.has_newline_before && p.lexer.token == js_lexer.tc_lass {
									return p.parse_class_stmt(loc, opts)
								}
							}
							'global' {
								if opts.is_namespace_scope && opts.is_type_script_declare && p.lexer.token == js_lexer.to_pen_brace {
									p.lexer.next()
									p.parse_stmts_up_to(js_lexer.tc_lose_brace, opts)
									p.lexer.next()
									return js_ast.Stmt{
										loc:  loc
										data: js_ast.st_ype_script_shared
									}
								}
							}
							'declare' {
								if !p.lexer.has_newline_before {
									opts.lexical_decl = lexical_decl_allow_all
									opts.is_type_script_declare = true
									if p.lexer.is_contextual_keyword('global') {
										p.lexer.next()
										p.lexer.expect(js_lexer.to_pen_brace)
										p.parse_stmts_up_to(js_lexer.tc_lose_brace, opts)
										p.lexer.next()
										return js_ast.Stmt{
											loc:  loc
											data: js_ast.st_ype_script_shared
										}
									}
									mut scope_index_1 := p.scopes_in_order.len
									mut old_lexer := p.lexer
									mut stmt_6 := p.parse_stmt(opts)
									mut type_declaration_data := js_ast.st_ype_script_shared
									mut s_4 := stmt.data
									match s {
										js_ast.SEmpty {
											return js_ast.Stmt{
												loc:  loc
												data: &js_ast.SExpr{
													value: expr
												}
											}
										}
										js_ast.STypeScript {
											type_declaration_data = s
										}
										js_ast.SLocal {}
										else {
											p.lexer = old_lexer
											p.lexer.unexpected()
										}
									}
									p.discard_scopes_up_to(scope_index)
									if opts.is_namespace_scope && opts.is_export {
										mut s_5, ok_9 := stmt.data
										if ok {
											js_ast.for_each_identifier_binding_in_decls(s.decls,
												fn (loc logger.Loc, b &js_ast.BIdentifier) {
												decls << js_ast.Decl{
													binding: js_ast.Binding{
														loc:  loc
														data: b
													}
												}
											})
										}
										if decls.len > 0 {
											return js_ast.Stmt{
												loc:  loc
												data: &js_ast.SLocal{
													kind:      js_ast.local_var
													is_export: true
													decls:     decls
												}
											}
										}
									}
									return js_ast.Stmt{
										loc:  loc
										data: type_declaration_data
									}
								}
							}
						}
					}
				}
			}
			p.lexer.expect_or_insert_semicolon()
			return js_ast.Stmt{
				loc:  loc
				data: &js_ast.SExpr{
					value: expr
				}
			}
		}
	}
}

fn (p &Parser) add_import_record(kind ast.ImportKind, path_range logger.Range, text string, assert_or_with &ast.ImportAssertOrWith, flags ast.ImportRecordFlags) u32 {
	mut index := u32(p.import_records.len)
	p.import_records << ast.ImportRecord{
		kind:           kind
		range:          path_range
		path:           logger.Path{
			text: text
		}
		assert_or_with: assert_or_with
		flags:          flags
	}
	return index
}

fn (p &Parser) parse_fn_body(data fnOrArrowDataParse) js_ast.FnBody {
	mut old_fn_or_arrow_data := p.fn_or_arrow_data_parse
	mut old_allow_in := p.allow_in
	p.fn_or_arrow_data_parse = data
	p.allow_in = true
	mut loc := p.lexer.loc()
	p.push_scope_for_parse_pass(js_ast.scope_function_body, loc)
	defer {
		p.pop_scope
	}
	p.lexer.expect(js_lexer.to_pen_brace)
	mut stmts := p.parse_stmts_up_to(js_lexer.tc_lose_brace, ParseStmtOpts{
		allow_directive_prologue: true
	})
	mut close_brace_loc := p.lexer.loc()
	p.lexer.next()
	p.allow_in = old_allow_in
	p.fn_or_arrow_data_parse = old_fn_or_arrow_data
	return js_ast.FnBody{
		loc:   loc
		block: js_ast.SBlock{
			stmts:           stmts
			close_brace_loc: close_brace_loc
		}
	}
}

fn (p &Parser) forbid_lexical_decl(loc logger.Loc) {
	mut r := js_lexer.range_of_identifier(p.source, loc)
	p.log.add_error(&p.tracker, r, 'Cannot use a declaration in a single-statement context')
}

fn (p &Parser) parse_stmts_up_to(end js_lexer.T, opts parseStmtOpts) []js_ast.Stmt {
	mut stmts := []
	{}
	mut return_without_semicolon_start := i32(-1)
	opts.lexical_decl = lexical_decl_allow_all
	mut is_directive_prologue := opts.allow_directive_prologue
	for {
		mut comments := p.lexer.legal_comments_before_token
		if comments.len > 0 {
			for _, comment in comments {
				stmts << js_ast.Stmt{
					loc:  comment.loc
					data: &js_ast.SComment{
						text:             p.source.comment_text_without_indent(comment)
						is_legal_comment: true
					}
				}
			}
		}
		if p.lexer.token == end {
			break
		}
		mut stmt := p.parse_stmt(opts)
		if p.options.ts.parse {
			_, ok := stmt.data
			if ok {
				continue
			}
		}
		if is_directive_prologue {
			is_directive_prologue = false
			mut expr, ok_1 := stmt.data
			if ok {
				mut str, ok_2 := expr.value.data
				if ok && !str.prefer_template {
					stmt.data = &js_ast.SDirective{
						value:            str.value
						legacy_octal_loc: str.legacy_octal_loc
					}
					is_directive_prologue = true
					if helpers.utf_16_equals_string(str.value, 'use strict') {
						p.current_scope.strict_mode = js_ast.explicit_strict_mode
						p.current_scope.use_strict_loc = expr.value.loc
						if p.current_scope.kind == js_ast.scope_function_body && p.current_scope.parent.kind == js_ast.scope_function_args && p.current_scope.parent.strict_mode == js_ast.sloppy_mode {
							p.current_scope.parent.strict_mode = js_ast.explicit_strict_mode
							p.current_scope.parent.use_strict_loc = expr.value.loc
						}
					} else if helpers.utf_16_equals_string(str.value, 'use asm') {
						stmt.data = &js_ast.SEmpty{}
					}
				}
			}
		}
		stmts << stmt
		if !p.suppress_warnings_about_weird_code {
			mut s, ok_3 := stmt.data
			if ok && s.value_or_nil.data == nil && !p.latest_return_had_semicolon {
				return_without_semicolon_start = stmt.loc.start
			}
			else {
				if return_without_semicolon_start != -1 {
					_, ok_4 := stmt.data
					if ok {
						p.log.add_id(logger.msg_id_js_semicolon_after_return, logger.warning,
							&p.tracker, logger.Range{
							loc: logger.Loc{
								start: return_without_semicolon_start + 6
							}
						}, 'The following expression is not returned because of an automatically-inserted semicolon')
					}
				}
				return_without_semicolon_start = -1
			}
		}
	}
	return stmts
}

type generateTempRefArg = u8

enum generateTempRefArg {
	temp_ref_needs_declare
	temp_ref_no_declare
	temp_ref_needs_declare_may_be_captured_inside_loop
}

fn (p &Parser) generate_temp_ref(declare generateTempRefArg, optional_name string) ast.Ref {
	mut scope := p.current_scope
	if declare != temp_ref_needs_declare_may_be_captured_inside_loop {
		for !scope.kind.stops_hoisting() {
			scope = scope.parent
		}
	}
	if optional_name == '' {
		optional_name = '_' + ast.default_name_minifier_js.number_to_minified_name(p.temp_ref_count)
		p.temp_ref_count++
	}
	mut ref := p.new_symbol(ast.symbol_other, optional_name)
	if declare == temp_ref_needs_declare_may_be_captured_inside_loop && !scope.kind.stops_hoisting() {
		p.temp_lets_to_declare << ref
	} else if declare != temp_ref_no_declare {
		p.temp_refs_to_declare << TempRef{
			ref: ref
		}
	}
	scope.generated << ref
	return ref
}

fn (p &Parser) generate_top_level_temp_ref() ast.Ref {
	mut ref := p.new_symbol(ast.symbol_other, '_' +
		ast.default_name_minifier_js.number_to_minified_name(p.top_level_temp_ref_count))
	p.top_level_temp_refs_to_declare << TempRef{
		ref: ref
	}
	p.module_scope.generated << ref
	p.top_level_temp_ref_count++
	return ref
}

fn (p &Parser) push_scope_for_visit_pass(kind js_ast.ScopeKind, loc logger.Loc) {
	mut order := p.scopes_in_order[0]
	if order.loc != loc || order.scope.kind != kind {
		panic(strconv.v_sprintf('Expected scope (%d, %d) in %s, found scope (%d, %d)',
			kind, loc.start, p.source.pretty_path, order.scope.kind, order.loc.start))
	}
	p.scopes_in_order = p.scopes_in_order[1..]
	p.current_scope = order.scope
	p.scopes_for_current_part << order.scope
}

struct findSymbolResult {
pub mut:
	ref                  ast.Ref
	declare_loc          logger.Loc
	is_inside_with_scope bool
}

fn (p &Parser) find_symbol(loc logger.Loc, name string) findSymbolResult {
	mut ref := 0
	mut declareLoc := 0
	mut is_inside_with_scope := false
	mut did_forbid_arguments := false
	mut s := p.current_scope
	for {
		if s.kind == js_ast.scope_with {
			is_inside_with_scope = true
		}
		if s.forbid_arguments && name == 'arguments' && !did_forbid_arguments {
			mut r := js_lexer.range_of_identifier(p.source, loc)
			p.log.add_error(&p.tracker, r, strconv.v_sprintf('Cannot access %q here:',
				name))
			did_forbid_arguments = true
		}
		mut member, ok := s.members[name]
		if ok {
			ref = member.ref
			declare_loc = member.loc
			break
		}
		mut ts_namespace := s.tsn_amespace
		if ts_namespace != nil {
			mut member_1, ok_1 := ts_namespace.exported_members[name]
			if ok && ts_namespace.is_enum_scope == member.is_enum_value {
				mut cache := ts_namespace.lazily_generated_propery_accesses
				if cache == nil {
					cache = map[string]ast.Ref{}
					ts_namespace.lazily_generated_propery_accesses = cache
				}
				ref, ok = cache[name]
				if !ok {
					ref = p.new_symbol(ast.symbol_other, name)
					p.symbols[ref.inner_index].namespace_alias = &ast.NamespaceAlias{
						namespace_ref: ts_namespace.arg_ref
						alias:         name
					}
					cache[name] = ref
				}
				declare_loc = member.loc
				break
			}
		}
		s = s.parent
		if s == nil {
			p.check_for_unrepresentable_identifier(loc, name)
			ref = p.new_symbol(ast.symbol_unbound, name)
			declare_loc = loc
			p.module_scope.members[name] = js_ast.ScopeMember{
				ref: ref
				loc: logger.Loc{
					start: -1
				}
			}
			break
		}
	}
	if is_inside_with_scope {
		p.symbols[ref.inner_index].flags |= ast.must_not_be_renamed
	}
	p.record_usage(ref)
	return FindSymbolResult{ref, declare_loc, is_inside_with_scope}
}

fn (p &Parser) find_label_symbol(loc logger.Loc, name string) (ast.Ref, bool, bool) {
	for s := p.current_scope; s != nil && !s.kind.stops_hoisting(); s = s.parent {
		if s.kind == js_ast.scope_label && name == p.symbols[s.label.ref.inner_index].original_name {
			p.record_usage(s.label.ref)
			ref = s.label.ref
			is_loop = s.label_stmt_is_loop
			ok = true
			return
		}
	}
	mut r := js_lexer.range_of_identifier(p.source, loc)
	p.log.add_error(&p.tracker, r, strconv.v_sprintf('There is no containing label named %q',
		name))
	ref = p.new_symbol(ast.symbol_unbound, name)
	p.record_usage(ref)
	return
}

fn find_identifiers(binding js_ast.Binding, identifiers []js_ast.Decl) []js_ast.Decl {
	mut b := binding.data
	match b {
		js_ast.BIdentifier {
			identifiers << js_ast.Decl{
				binding: binding
			}
		}
		js_ast.BArray {
			for _, item in b.items {
				identifiers = find_identifiers(item.binding, identifiers)
			}
		}
		js_ast.BObject {
			for _, property in b.properties {
				identifiers = find_identifiers(property.value, identifiers)
			}
		}
	}
	return identifiers
}

// If this is in a dead branch, then we want to trim as much dead code as we
// can. Everything can be trimmed except for hoisted declarations ("var" and
// "function"), which affect the parent scope. For example:
//
//	function foo() {
//	  if (false) { var x; }
//	  x = 1;
//	}
//
// We can't trim the entire branch as dead or calling foo() will incorrectly
// assign to a global variable instead.
fn should_keep_stmt_in_dead_control_flow(stmt js_ast.Stmt) bool {
	mut s := stmt.data
	match s {
		js_ast.SEmpty, js_ast.SExpr, js_ast.SThrow, js_ast.SReturn, js_ast.SBreak,
		js_ast.SContinue, js_ast.SClass, js_ast.SDebugger {
			return false
		}
		js_ast.SLocal {
			if s.kind != js_ast.local_var {
				return false
			}
			mut identifiers := []
			{}
			for _, decl in s.decls {
				identifiers = find_identifiers(decl.binding, identifiers)
			}
			if identifiers.len == 0 {
				return false
			}
			s.decls = identifiers
			return true
		}
		js_ast.SBlock {
			for _, child in s.stmts {
				if should_keep_stmt_in_dead_control_flow(child) {
					return true
				}
			}
			return false
		}
		js_ast.SIf {
			return should_keep_stmt_in_dead_control_flow(s.yes)
				|| s.no_or_nil.data != nil && should_keep_stmt_in_dead_control_flow(s.no_or_nil)
		}
		js_ast.SWhile {
			return should_keep_stmt_in_dead_control_flow(s.body)
		}
		js_ast.SDoWhile {
			return should_keep_stmt_in_dead_control_flow(s.body)
		}
		js_ast.SFor {
			return s.init_or_nil.data != nil && should_keep_stmt_in_dead_control_flow(s.init_or_nil)
				|| should_keep_stmt_in_dead_control_flow(s.body)
		}
		js_ast.SForIn {
			return should_keep_stmt_in_dead_control_flow(s.init)
				|| should_keep_stmt_in_dead_control_flow(s.body)
		}
		js_ast.SForOf {
			return should_keep_stmt_in_dead_control_flow(s.init)
				|| should_keep_stmt_in_dead_control_flow(s.body)
		}
		js_ast.SLabel {
			return should_keep_stmt_in_dead_control_flow(s.stmt)
		}
		else {
			return true
		}
	}
}

struct prependTempRefsOpts {
pub mut:
	fn_body_loc &logger.Loc = unsafe { nil }
	kind        stmtsKind
}

fn (p &Parser) visit_stmts_and_prepend_temp_refs(stmts []js_ast.Stmt, opts prependTempRefsOpts) []js_ast.Stmt {
	mut old_temp_refs := p.temp_refs_to_declare
	mut old_temp_ref_count := p.temp_ref_count
	p.temp_refs_to_declare = nil
	p.temp_ref_count = isize(0)
	stmts = p.visit_stmts(stmts, opts.kind)
	if opts.fn_body_loc != nil {
		mut ref := p.fn_only_data_visit.this_capture_ref
		if ref != nil {
			p.temp_refs_to_declare << TempRef{
				ref:          &ref
				value_or_nil: js_ast.Expr{
					loc:  &opts.fn_body_loc
					data: js_ast.et_his_shared
				}
			}
			p.current_scope.generated << &ref
		}
		mut ref_1 := p.fn_only_data_visit.arguments_capture_ref
		if ref != nil {
			p.temp_refs_to_declare << TempRef{
				ref:          &ref
				value_or_nil: js_ast.Expr{
					loc:  &opts.fn_body_loc
					data: &js_ast.EIdentifier{
						ref: &p.fn_only_data_visit.arguments_ref
					}
				}
			}
			p.current_scope.generated << &ref
		}
	}
	if p.current_scope == p.module_scope && p.top_level_temp_refs_to_declare != nil {
		p.temp_refs_to_declare << p.top_level_temp_refs_to_declare
		p.top_level_temp_refs_to_declare = nil
	}
	mut decls := []
	{}
	for _, temp in p.temp_refs_to_declare {
		if p.symbols[temp.ref.inner_index].use_count_estimate > 0 {
			decls << js_ast.Decl{
				binding:      js_ast.Binding{
					data: &js_ast.BIdentifier{
						ref: temp.ref
					}
				}
				value_or_nil: temp.value_or_nil
			}
			p.record_declared_symbol(temp.ref)
		}
	}
	if decls.len > 0 {
		mut split := isize(0)
		for split < stmts.len {
			// append no rhs

			// lhs.len==0
			break
		}
		stmts << stmts[split..]
	}
	p.temp_refs_to_declare = old_temp_refs
	p.temp_ref_count = old_temp_ref_count
	return stmts
}

type stmtsKind = u8

enum stmtsKind {
	stmts_normal
	stmts_switch
	stmts_loop_body
	stmts_fn_body
}

fn (p &Parser) visit_stmts(stmts []js_ast.Stmt, kind stmtsKind) []js_ast.Stmt {
	mut old_is_control_flow_dead := p.is_control_flow_dead
	mut old_temp_lets_to_declare := p.temp_lets_to_declare
	p.temp_lets_to_declare = nil
	mut visited := []js_ast.Stmt{len: 0, cap: stmts.len}
	mut before := []js_ast.Stmt{}
	mut after := []js_ast.Stmt{}
	mut preprocessedEnums := map[isize][]js_ast.Stmt{}
	if p.scopes_in_order_for_enum != nil {
		for i, stmt in stmts {
			_, ok := stmt.data
			if ok {
				if preprocessed_enums == nil {
					preprocessed_enums = map[isize][]js_ast.Stmt{}
				}
				mut old_scopes_in_order := p.scopes_in_order
				p.scopes_in_order = p.scopes_in_order_for_enum[stmt.loc]
				preprocessed_enums[i] = p.visit_and_append_stmt(nil, stmt)
				p.scopes_in_order = old_scopes_in_order
			}
		}
	}
	for i_1, stmt_1 in stmts {
		mut s := stmt.data
		match s {
			js_ast.SExportEquals {
				after = p.visit_and_append_stmt(after, stmt)
				continue
			}
			js_ast.SFunction {
				if !p.current_scope.kind.stops_hoisting() && p.symbols[isize(s.fn_.name.ref.inner_index)].kind == ast.symbol_hoisted_function {
					before = p.visit_and_append_stmt(before, stmt)
					continue
				}
			}
			js_ast.SEnum {
				visited << preprocessed_enums[i]
				p.scopes_in_order = p.scopes_in_order[p.scopes_in_order_for_enum[stmt.loc].len..]
				continue
			}
		}
		visited = p.visit_and_append_stmt(visited, stmt)
	}
	if p.temp_lets_to_declare.len > 0 {
		mut decls := []js_ast.Decl{len: 0, cap: p.temp_lets_to_declare.len}
		for _, ref in p.temp_lets_to_declare {
			decls << js_ast.Decl{
				binding: js_ast.Binding{
					data: &js_ast.BIdentifier{
						ref: ref
					}
				}
			}
		}
		before << js_ast.Stmt{
			data: &js_ast.SLocal{
				kind:  js_ast.local_let
				decls: decls
			}
		}
	}
	p.temp_lets_to_declare = old_temp_lets_to_declare
	if before.len > 0 {
		mut letDecls := []js_ast.Decl{}
		mut varDecls := []js_ast.Decl{}
		mut nonFnStmts := []js_ast.Stmt{}
		mut fn_stmts := map[ast.Ref]isize{}
		for _, stmt_2 in before {
			mut s_1, ok_1 := stmt.data
			if !ok {
				non_fn_stmts << stmt
				continue
			}
			if p.current_scope.contains_direct_eval {
				mut hoisted_ref, ok_2 := p.hoisted_ref_for_sloppy_mode_block_fn[s.fn_.name.ref]
				if ok {
					p.symbols[hoisted_ref.inner_index].link = s.fn_.name.ref
				}
				non_fn_stmts << stmt
				continue
			}
			mut index, ok_3 := fn_stmts[s.fn_.name.ref]
			if !ok {
				index = let_decls.len
				fn_stmts[s.fn_.name.ref] = index
				let_decls << js_ast.Decl{
					binding: js_ast.Binding{
						loc:  s.fn_.name.loc
						data: &js_ast.BIdentifier{
							ref: s.fn_.name.ref
						}
					}
				}
				mut hoisted_ref_1, ok_4 := p.hoisted_ref_for_sloppy_mode_block_fn[s.fn_.name.ref]
				if ok {
					p.record_declared_symbol(hoisted_ref)
					p.record_usage(s.fn_.name.ref)
					var_decls << js_ast.Decl{
						binding:      js_ast.Binding{
							loc:  s.fn_.name.loc
							data: &js_ast.BIdentifier{
								ref: hoisted_ref
							}
						}
						value_or_nil: js_ast.Expr{
							loc:  s.fn_.name.loc
							data: &js_ast.EIdentifier{
								ref: s.fn_.name.ref
							}
						}
					}
				}
			}
			s.fn_.name = nil
			let_decls[index].value_or_nil = js_ast.Expr{
				loc:  stmt.loc
				data: &js_ast.EFunction{
					fn_: s.fn_
				}
			}
		}
		before = before[..0]
		mut kind_1 := js_ast.local_let
		if p.options.unsupported_jsf_eatures.has(compat.const_and_let) {
			kind = js_ast.local_var
		}
		if let_decls.len > 0 {
			before << js_ast.Stmt{
				loc:  let_decls[0].value_or_nil.loc
				data: &js_ast.SLocal{
					kind:  kind
					decls: let_decls
				}
			}
		}
		if var_decls.len > 0 {
			mut assign, ok_5 := p.maybe_relocate_vars_to_top_level(var_decls, relocate_vars_normal)
			if ok {
				if assign.data != nil {
					before << assign
				}
			} else {
				before << js_ast.Stmt{
					loc:  var_decls[0].value_or_nil.loc
					data: &js_ast.SLocal{
						kind:  js_ast.local_var
						decls: var_decls
					}
				}
			}
		}
		before << non_fn_stmts
		visited << visited
	}
	visited << after
	p.is_control_flow_dead = old_is_control_flow_dead
	if kind != stmts_switch && p.should_lower_using_declarations(visited) {
		mut ctx := p.lower_using_declaration_context()
		ctx.scan_stmts(p, visited)
		visited = ctx.finalize(p, visited, p.current_scope.parent == nil)
	}
	if !p.options.minify_syntax {
		return visited
	}
	if p.is_control_flow_dead {
		mut end := isize(0)
		for _, stmt_3 in visited {
			if !should_keep_stmt_in_dead_control_flow(stmt) {
				continue
			}
			mut s_2, ok_6 := stmt.data
			if ok && s.kind == js_ast.local_var && end > 0 {
				mut prev_stmt := visited[end - 1]
				mut prev_s, ok_7 := prev_stmt.data
				if ok && prev_s.kind == js_ast.local_var && s.is_export == prev_s.is_export {
					prev_s.decls << s.decls
					continue
				}
			}
			visited[end] = stmt
			end++
		}
		return visited[..end]
	}
	return p.mangle_stmts(visited, kind)
}

fn (p &Parser) mangle_stmts(stmts []js_ast.Stmt, kind stmtsKind) []js_ast.Stmt {
	if p.current_scope.parent != nil && !p.current_scope.contains_direct_eval {
		for i, stmt in stmts {
			mut s := stmt.data
			match s {
				js_ast.SEmpty, js_ast.SComment, js_ast.SDirective, js_ast.SDebugger,
				js_ast.STypeScript {
					continue
				}
				js_ast.SLocal {
					if !s.is_export {
						mut end := isize(0)
						for _, d in s.decls {
							mut id, ok := d.binding.data
							if ok {
								_, ok_1 := p.const_values[id.ref]
								if ok && p.symbols[id.ref.inner_index].use_count_estimate == 0 {
									continue
								}
							}
							s.decls[end] = d
							end++
						}
						if end == 0 {
							stmts[i].data = js_ast.se_mpty_shared
						} else {
							s.decls = s.decls[..end]
						}
					}
					continue
				}
			}
			break
		}
	}
	mut result := []js_ast.Stmt{len: 0, cap: stmts.len}
	mut is_control_flow_dead := false
	for i_1, stmt_1 in stmts {
		if is_control_flow_dead && !should_keep_stmt_in_dead_control_flow(stmt) {
			continue
		}
		if p.current_scope != p.module_scope && !p.current_scope.contains_direct_eval {
			for result.len > 0 {
				mut prev_s, ok_2 := result[result.len - 1].data
				if ok && prev_s.kind != js_ast.local_var {
					mut last := prev_s.decls[prev_s.decls.len - 1]
					mut id_1, ok_3 := last.binding.data
					if ok {
						mut symbol := p.symbols[id.ref.inner_index]
						if symbol.use_count_estimate == 1 && !symbol.flags.has(ast.did_keep_name) {
							mut replacement := last.value_or_nil
							if replacement.data == nil {
								replacement = js_ast.Expr{
									loc:  last.binding.loc
									data: js_ast.eu_ndefined_shared
								}
							}
							if p.substitute_single_use_symbol_in_stmt(stmt, id.ref, replacement) {
								if prev_s.decls.len == 1 {
									result = result[..result.len - 1]
								} else {
									prev_s.decls = prev_s.decls[..prev_s.decls.len - 1]
								}
								continue
							}
						}
					}
				}
				break
			}
		}
		mut s_1 := stmt.data
		match s {
			js_ast.SEmpty {
				continue
			}
			js_ast.SLocal {
				if result.len > 0 {
					mut prev_stmt := result[result.len - 1]
					mut prev_s_1, ok_4 := prev_stmt.data
					if ok && s.kind == prev_s.kind && s.is_export == prev_s.is_export {
						prev_s.decls << s.decls
						continue
					}
				}
			}
			js_ast.SExpr {
				if result.len > 0 {
					mut prev_stmt_1 := result[result.len - 1]
					mut prev_s_2, ok_5 := prev_stmt.data
					if ok {
						if !s.is_from_class_or_fn_that_can_be_removed_if_unused {
							prev_s.is_from_class_or_fn_that_can_be_removed_if_unused = false
						}
						prev_s.value = js_ast.join_with_comma(prev_s.value, s.value)
						continue
					}
				}
			}
			js_ast.SSwitch {
				if result.len > 0 {
					mut prev_stmt_2 := result[result.len - 1]
					mut prev_s_3, ok_6 := prev_stmt.data
					if ok {
						s.test = js_ast.join_with_comma(prev_s.value, s.test)
						result = result[..result.len - 1]
					}
				}
			}
			js_ast.SIf {
				if result.len > 0 {
					mut prev_stmt_3 := result[result.len - 1]
					mut prev_s_4, ok_7 := prev_stmt.data
					if ok {
						s.test = js_ast.join_with_comma(prev_s.value, s.test)
						result = result[..result.len - 1]
					}
				}
				if is_jump_statement(s.yes.data) {
					mut optimize_implicit_jump := false
					if result.len > 0 {
						mut prev_stmt_4 := result[result.len - 1]
						mut prev_s_5, ok_8 := prev_stmt.data
						if ok && prev_s.no_or_nil.data == nil && jump_stmts_look_the_same(prev_s.yes.data,
							s.yes.data) {
							s.test = js_ast.join_with_left_associative_op(js_ast.bin_op_logical_or,
								prev_s.test, s.test)
							result = result[..result.len - 1]
						}
					}
					if kind == stmts_loop_body {
						mut continue_s, ok_9 := s.yes.data
						if ok && continue_s.label == nil {
							optimize_implicit_jump = true
						}
					}
					if kind == stmts_fn_body {
						mut return_s, ok_10 := s.yes.data
						if ok && return_s.value_or_nil.data == nil {
							optimize_implicit_jump = true
						}
					}
					if optimize_implicit_jump {
						mut body := []js_ast.Stmt{}
						if s.no_or_nil.data != nil {
							body << s.no_or_nil
						}
						body << stmts[i + 1..]
						mut can_move_branch_condition_outside_scope := true
						for _, stmt_2 in body {
							if statement_cares_about_scope(stmt) {
								can_move_branch_condition_outside_scope = false
								break
							}
						}
						if can_move_branch_condition_outside_scope {
							body = p.mangle_stmts(body, kind)
							mut body_loc := s.yes.loc
							if body.len > 0 {
								body_loc = body[0].loc
							}
							return p.mangle_if(result, stmt.loc, &js_ast.SIf{
								test: p.ast_helpers.simplify_boolean_expr(js_ast.not(s.test))
								yes:  stmts_to_single_stmt(body_loc, body, logger.Loc{})
							})
						}
					}
					if s.no_or_nil.data != nil {
						for {
							result << stmt
							stmt = s.no_or_nil
							s.no_or_nil = js_ast.Stmt{}
							s, ok = stmt.data
							if !ok || !is_jump_statement(s.yes.data) || s.no_or_nil.data == nil {
								break
							}
						}
						result = append_if_or_label_body_preserving_scope(result, stmt)
						if is_jump_statement(stmt.data) {
							is_control_flow_dead = true
						}
						continue
					}
				}
			}
			js_ast.SReturn {
				if result.len > 0 && s.value_or_nil.data != nil {
					mut prev_stmt_5 := result[result.len - 1]
					mut prev_s_6, ok_11 := prev_stmt.data
					if ok {
						result[result.len - 1] = js_ast.Stmt{
							loc:  prev_stmt.loc
							data: &js_ast.SReturn{
								value_or_nil: js_ast.join_with_comma(prev_s.value, s.value_or_nil)
							}
						}
						continue
					}
				}
				is_control_flow_dead = true
			}
			js_ast.SThrow {
				if result.len > 0 {
					mut prev_stmt_6 := result[result.len - 1]
					mut prev_s_7, ok_12 := prev_stmt.data
					if ok {
						result[result.len - 1] = js_ast.Stmt{
							loc:  prev_stmt.loc
							data: &js_ast.SThrow{
								value: js_ast.join_with_comma(prev_s.value, s.value)
							}
						}
						continue
					}
				}
				is_control_flow_dead = true
			}
			js_ast.SBreak, js_ast.SContinue {
				is_control_flow_dead = true
			}
			js_ast.SFor {
				if result.len > 0 {
					mut prev_stmt_7 := result[result.len - 1]
					mut prev_s_8, ok_13 := prev_stmt.data
					if ok {
						if s.init_or_nil.data == nil {
							result[result.len - 1] = stmt
							s.init_or_nil = js_ast.Stmt{
								loc:  prev_stmt.loc
								data: &js_ast.SExpr{
									value: prev_s.value
								}
							}
							continue
						}
						else {
							mut s2, ok_14 := s.init_or_nil.data
							if ok {
								result[result.len - 1] = stmt
								s.init_or_nil = js_ast.Stmt{
									loc:  prev_stmt.loc
									data: &js_ast.SExpr{
										value: js_ast.join_with_comma(prev_s.value, s2.value)
									}
								}
								continue
							}
						}
					}
					else {
						if s.init_or_nil.data == nil {
							mut s2_1, ok_15 := prev_stmt.data
							if ok && s2.kind == js_ast.local_var && !s2.is_export {
								result[result.len - 1] = stmt
								s.init_or_nil = prev_stmt
								continue
							}
						}
						else {
							mut s2_2, ok_16 := prev_stmt.data
							if ok && s2.kind == js_ast.local_var && !s2.is_export {
								mut s3, ok_17 := s.init_or_nil.data
								if ok && s3.kind == js_ast.local_var {
									result[result.len - 1] = stmt
									s.init_or_nil.data = &js_ast.SLocal{
										kind:  js_ast.local_var
										decls: append(s2.decls, s3.decls)
									}
									continue
								}
							}
						}
					}
				}
			}
			js_ast.STry {
				if !p.options.unsupported_jsf_eatures.has(compat.optional_catch_binding) && s.catch != nil {
					mut id_2, ok_18 := s.catch.binding_or_nil.data
					if ok {
						mut symbol_1 := p.symbols[id.ref.inner_index]
						if symbol.use_count_estimate == 0 {
							if symbol.link != ast.invalid_ref {
							} else if p.current_scope.contains_direct_eval {
							} else {
								s.catch.binding_or_nil.data = nil
							}
						}
					}
				}
			}
		}
		result << stmt
	}
	if result.len > 0 {
		match kind {
			stmts_loop_body {
				mut continue_s_1, ok_19 := result[result.len - 1].data
				if ok && continue_s.label == nil {
					result = result[..result.len - 1]
				}
			}
			stmts_fn_body {
				mut return_s_1, ok_20 := result[result.len - 1].data
				if ok && return_s.value_or_nil.data == nil {
					result = result[..result.len - 1]
				}
			}
		}
	}
	if result.len >= 2 {
		mut last_stmt := result[result.len - 1]
		mut last_return, ok_21 := last_stmt.data
		if ok {
			// unhandled in stmt: unknown sum type value
		}
		else {
			mut last_throw, ok_22 := last_stmt.data
			if ok {
				// unhandled in stmt: unknown sum type value
			}
		}
	}
	return result
}

fn (p &Parser) substitute_single_use_symbol_in_stmt(stmt js_ast.Stmt, ref ast.Ref, replacement js_ast.Expr) bool {
	mut expr := 0
	mut s := stmt.data
	match s {
		js_ast.SExpr {
			expr = &s.value
		}
		js_ast.SThrow {
			expr = &s.value
		}
		js_ast.SReturn {
			expr = &s.value_or_nil
		}
		js_ast.SIf {
			expr = &s.test
		}
		js_ast.SSwitch {
			expr = &s.test
		}
		js_ast.SLocal {
			mut first := &s.decls[0]
			if first.value_or_nil.data != nil {
				_, ok := first.binding.data
				if ok {
					expr = &first.value_or_nil
				}
			}
		}
	}
	if expr != nil {
		mut replacement_can_be_removed := p.ast_helpers.expr_can_be_removed_if_unused(replacement)
		mut new, status := p.substitute_single_use_symbol_in_expr(&expr, ref, replacement,
			replacement_can_be_removed)
		if status == substitute_success {
			*expr = new
			return true
		}
	}
	return false
}

type substituteStatus = u8

enum substituteStatus {
	substitute_continue
	substitute_success
	substitute_failure
}

fn (p &Parser) substitute_single_use_symbol_in_expr(expr js_ast.Expr, ref ast.Ref, replacement js_ast.Expr, replacement_can_be_removed bool) (js_ast.Expr, substituteStatus) {
	mut e := expr.data
	match e {
		js_ast.EIdentifier {
			if e.ref == ref {
				p.ignore_usage(ref)
				return replacement, substitute_success
			}
		}
		js_ast.ESpread {
			mut value, status := p.substitute_single_use_symbol_in_expr(e.value, ref,
				replacement, replacement_can_be_removed)
			if status != substitute_continue {
				e.value = value
				return expr, status
			}
		}
		js_ast.EAwait {
			mut value_1, status_1 := p.substitute_single_use_symbol_in_expr(e.value, ref,
				replacement, replacement_can_be_removed)
			if status != substitute_continue {
				e.value = value
				return expr, status
			}
		}
		js_ast.EYield {
			if e.value_or_nil.data != nil {
				mut value_2, status_2 := p.substitute_single_use_symbol_in_expr(e.value_or_nil,
					ref, replacement, replacement_can_be_removed)
				if status != substitute_continue {
					e.value_or_nil = value
					return expr, status
				}
			}
		}
		js_ast.EImportCall {
			mut value_3, status_3 := p.substitute_single_use_symbol_in_expr(e.expr, ref,
				replacement, replacement_can_be_removed)
			if status != substitute_continue {
				e.expr = value
				return expr, status
			}
			if replacement_can_be_removed && p.ast_helpers.expr_can_be_removed_if_unused(e.expr) {
				return expr, substitute_continue
			}
		}
		js_ast.EUnary {
			match e.op {
				js_ast.un_op_pre_inc, js_ast.un_op_post_inc, js_ast.un_op_pre_dec,
				js_ast.un_op_post_dec, js_ast.un_op_delete {}
				else {
					mut value_4, status_4 := p.substitute_single_use_symbol_in_expr(e.value,
						ref, replacement, replacement_can_be_removed)
					if status != substitute_continue {
						e.value = value
						return expr, status
					}
				}
			}
		}
		js_ast.EDot {
			mut value_5, status_5 := p.substitute_single_use_symbol_in_expr(e.target,
				ref, replacement, replacement_can_be_removed)
			if status != substitute_continue {
				e.target = value
				return expr, status
			}
		}
		js_ast.EBinary {
			if e.op.binary_assign_target() == js_ast.assign_target_none {
				mut value_6, status_6 := p.substitute_single_use_symbol_in_expr(e.left,
					ref, replacement, replacement_can_be_removed)
				if status != substitute_continue {
					e.left = value
					return expr, status
				}
			} else if !p.ast_helpers.expr_can_be_removed_if_unused(e.left) {
				return expr, substitute_failure
			} else if e.op.binary_assign_target() == js_ast.assign_target_update
				&& !replacement_can_be_removed {
				return expr, substitute_failure
			}
			mut value_7, status_7 := p.substitute_single_use_symbol_in_expr(e.right, ref,
				replacement, replacement_can_be_removed)
			if status != substitute_continue {
				e.right = value
				return expr, status
			}
		}
		js_ast.EIf {
			mut value_8, status_8 := p.substitute_single_use_symbol_in_expr(e.test, ref,
				replacement, replacement_can_be_removed)
			if status != substitute_continue {
				e.test = value
				return expr, status
			}
			if replacement_can_be_removed {
				mut yes_value, yes_status := p.substitute_single_use_symbol_in_expr(e.yes,
					ref, replacement, replacement_can_be_removed)
				if yes_status == substitute_success {
					e.yes = yes_value
					return expr, yes_status
				}
				mut no_value, no_status := p.substitute_single_use_symbol_in_expr(e.no,
					ref, replacement, replacement_can_be_removed)
				if no_status == substitute_success {
					e.no = no_value
					return expr, no_status
				}
				if yes_status != substitute_continue || no_status != substitute_continue {
					return expr, substitute_failure
				}
			}
		}
		js_ast.EIndex {
			mut value_9, status_9 := p.substitute_single_use_symbol_in_expr(e.target,
				ref, replacement, replacement_can_be_removed)
			if status != substitute_continue {
				e.target = value
				return expr, status
			}
			if replacement_can_be_removed || e.optional_chain == js_ast.optional_chain_none {
				mut value_10, status_10 := p.substitute_single_use_symbol_in_expr(e.index,
					ref, replacement, replacement_can_be_removed)
				if status != substitute_continue {
					e.index = value
					return expr, status
				}
			}
		}
		js_ast.ECall {
			_, is_dot := replacement.data
			_, is_index := replacement.data
			if is_dot || is_index {
				mut id, ok := e.target.data
				if ok && id.ref == ref {
					break
				}
			}
			mut value_11, status_11 := p.substitute_single_use_symbol_in_expr(e.target,
				ref, replacement, replacement_can_be_removed)
			if status != substitute_continue {
				e.target = value
				return expr, status
			}
			if replacement_can_be_removed || e.optional_chain == js_ast.optional_chain_none {
				for i, arg in e.args {
					mut value_12, status_12 := p.substitute_single_use_symbol_in_expr(arg,
						ref, replacement, replacement_can_be_removed)
					if status != substitute_continue {
						e.args[i] = value
						return expr, status
					}
				}
			}
		}
		js_ast.EArray {
			for i_1, item in e.items {
				mut value_13, status_13 := p.substitute_single_use_symbol_in_expr(item,
					ref, replacement, replacement_can_be_removed)
				if status != substitute_continue {
					e.items[i] = value
					return expr, status
				}
			}
		}
		js_ast.EObject {
			for i_2, property in e.properties {
				if property.flags.has(js_ast.property_is_computed) {
					mut value_14, status_14 := p.substitute_single_use_symbol_in_expr(property.key,
						ref, replacement, replacement_can_be_removed)
					if status != substitute_continue {
						e.properties[i].key = value
						return expr, status
					}
					return expr, substitute_failure
				}
				if property.value_or_nil.data != nil {
					mut value_15, status_15 := p.substitute_single_use_symbol_in_expr(property.value_or_nil,
						ref, replacement, replacement_can_be_removed)
					if status != substitute_continue {
						e.properties[i].value_or_nil = value
						return expr, status
					}
				}
			}
		}
		js_ast.ETemplate {
			if e.tag_or_nil.data != nil {
				mut value_16, status_16 := p.substitute_single_use_symbol_in_expr(e.tag_or_nil,
					ref, replacement, replacement_can_be_removed)
				if status != substitute_continue {
					e.tag_or_nil = value
					return expr, status
				}
			}
			for i_3, part in e.parts {
				mut value_17, status_17 := p.substitute_single_use_symbol_in_expr(part.value,
					ref, replacement, replacement_can_be_removed)
				if status != substitute_continue {
					e.parts[i].value = value
					if js_ast.is_primitive_literal(value.data) {
						expr = js_ast.inline_primitives_into_template(expr.loc, e)
					}
					return expr, status
				}
			}
		}
	}
	if replacement_can_be_removed && p.ast_helpers.expr_can_be_removed_if_unused(expr) {
		return expr, substitute_continue
	}
	if js_ast.is_primitive_literal(expr.data) || js_ast.is_primitive_literal(replacement.data) {
		return expr, substitute_continue
	}
	return expr, substitute_failure
}

fn (p &Parser) visit_loop_body(stmt js_ast.Stmt) js_ast.Stmt {
	mut old_is_inside_loop := p.fn_or_arrow_data_visit.is_inside_loop
	p.fn_or_arrow_data_visit.is_inside_loop = true
	p.loop_body = stmt.data
	stmt = p.visit_single_stmt(stmt, stmts_loop_body)
	p.fn_or_arrow_data_visit.is_inside_loop = old_is_inside_loop
	return stmt
}

fn (p &Parser) visit_single_stmt(stmt js_ast.Stmt, kind stmtsKind) js_ast.Stmt {
	mut block, ok := stmt.data
	if ok {
		p.push_scope_for_visit_pass(js_ast.scope_block, stmt.loc)
		block.stmts = p.visit_stmts(block.stmts, kind)
		p.pop_scope()
		if p.options.minify_syntax {
			stmt = stmts_to_single_stmt(stmt.loc, block.stmts, block.close_brace_loc)
		}
		return stmt
	}
	mut fn_, ok_1 := stmt.data
	mut has_if_scope := ok && fn_.fn_.has_if_scope
	if has_if_scope {
		p.push_scope_for_visit_pass(js_ast.scope_block, stmt.loc)
		if p.is_strict_mode() {
			p.mark_strict_mode_feature(if_else_function_stmt, js_lexer.range_of_identifier(p.source,
				stmt.loc), '')
		}
	}
	mut stmts := p.visit_stmts([stmt], kind)
	if has_if_scope {
		p.pop_scope()
	}
	return stmts_to_single_stmt(stmt.loc, stmts, logger.Loc{})
}

// One statement could potentially expand to several statements
fn stmts_to_single_stmt(loc logger.Loc, stmts []js_ast.Stmt, close_brace_loc logger.Loc) js_ast.Stmt {
	if stmts.len == 0 {
		return js_ast.Stmt{
			loc:  loc
			data: js_ast.se_mpty_shared
		}
	}
	if stmts.len == 1 && !statement_cares_about_scope(stmts[0]) {
		return stmts[0]
	}
	return js_ast.Stmt{
		loc:  loc
		data: &js_ast.SBlock{
			stmts:           stmts
			close_brace_loc: close_brace_loc
		}
	}
}

fn (p &Parser) visit_for_loop_init(stmt js_ast.Stmt, is_in_or_of bool) js_ast.Stmt {
	mut s := stmt.data
	match s {
		js_ast.SExpr {
			mut assign_target := js_ast.assign_target_none
			if is_in_or_of {
				assign_target = js_ast.assign_target_replace
			}
			p.stmt_expr_value = s.value.data
			s.value, _ = p.visit_expr_in_out(s.value, ExprIn{
				assign_target: assign_target
			})
		}
		js_ast.SLocal {
			for i, _ in s.decls {
				mut d := &s.decls[i]
				p.visit_binding(d.binding, BindingOpts{})
				if d.value_or_nil.data != nil {
					d.value_or_nil = p.visit_expr(d.value_or_nil)
				}
			}
			s.decls = p.lower_object_rest_in_decls(s.decls)
			s.kind = p.select_local_kind(s.kind)
		}
		else {
			panic('Internal error')
		}
	}
	return stmt
}

fn (p &Parser) record_declared_symbol(ref ast.Ref) {
	p.declared_symbols << js_ast.DeclaredSymbol{
		ref:          ref
		is_top_level: p.current_scope == p.module_scope
	}
}

struct bindingOpts {
pub mut:
	duplicate_arg_check map[string]logger.Range
}

fn (p &Parser) visit_binding(binding js_ast.Binding, opts bindingOpts) {
	mut b := binding.data
	match b {
		js_ast.BMissing {}
		js_ast.BIdentifier {
			p.record_declared_symbol(b.ref)
			mut name := p.symbols[b.ref.inner_index].original_name
			p.validate_declared_symbol_name(binding.loc, name)
			if opts.duplicate_arg_check != nil {
				mut r := js_lexer.range_of_identifier(p.source, binding.loc)
				mut first_range := opts.duplicate_arg_check[name]
				if first_range.len > 0 {
					p.log.add_error_with_notes(&p.tracker, r, strconv.v_sprintf('%q cannot be bound multiple times in the same parameter list',
						name), [
						p.tracker.msg_data(first_range, strconv.v_sprintf('The name %q was originally bound here:',
							name)),
					])
				} else {
					opts.duplicate_arg_check[name] = r
				}
			}
		}
		js_ast.BArray {
			for i, _ in b.items {
				mut item := &b.items[i]
				p.visit_binding(item.binding, opts)
				if item.default_value_or_nil.data != nil {
					mut id, ok := item.binding.data
					if ok {
						p.name_to_keep = p.symbols[id.ref.inner_index].original_name
						p.name_to_keep_is_for = item.default_value_or_nil.data
					}
					item.default_value_or_nil = p.visit_expr(item.default_value_or_nil)
				}
			}
		}
		js_ast.BObject {
			for i_1, property in b.properties {
				if !property.is_spread {
					property.key, _ = p.visit_expr_in_out(property.key, ExprIn{
						should_mangle_strings_as_props: true
					})
				}
				p.visit_binding(property.value, opts)
				if property.default_value_or_nil.data != nil {
					mut id_1, ok_1 := property.value.data
					if ok {
						p.name_to_keep = p.symbols[id.ref.inner_index].original_name
						p.name_to_keep_is_for = property.default_value_or_nil.data
					}
					property.default_value_or_nil = p.visit_expr(property.default_value_or_nil)
				}
				b.properties[i] = property
			}
		}
		else {
			panic('Internal error')
		}
	}
}

fn statement_cares_about_scope(stmt js_ast.Stmt) bool {
	mut s := stmt.data
	match s {
		js_ast.SBlock, js_ast.SEmpty, js_ast.SDebugger, js_ast.SExpr, js_ast.SIf, js_ast.SFor,
		js_ast.SForIn, js_ast.SForOf, js_ast.SDoWhile, js_ast.SWhile, js_ast.SWith, js_ast.STry,
		js_ast.SSwitch, js_ast.SReturn, js_ast.SThrow, js_ast.SBreak, js_ast.SContinue,
		js_ast.SDirective, js_ast.SLabel {
			return false
		}
		js_ast.SLocal {
			return s.kind != js_ast.local_var
		}
		else {
			return true
		}
	}
}

fn drop_first_statement(body js_ast.Stmt, replace_or_nil js_ast.Stmt) js_ast.Stmt {
	mut block, ok := body.data
	if ok && block.stmts.len > 0 {
		if replace_or_nil.data != nil {
			block.stmts[0] = replace_or_nil
		} else if block.stmts.len == 2 && !statement_cares_about_scope(block.stmts[1]) {
			return block.stmts[1]
		} else {
			block.stmts = block.stmts[1..]
		}
		return body
	}
	if replace_or_nil.data != nil {
		return replace_or_nil
	}
	return js_ast.Stmt{
		loc:  body.loc
		data: js_ast.se_mpty_shared
	}
}

fn mangle_for(s &js_ast.SFor) {
	mut first := s.body
	mut block, ok := first.data
	if ok && block.stmts.len > 0 {
		first = block.stmts[0]
	}
	mut if_s, ok_1 := first.data
	if ok {
		mut break_s, ok_2 := if_s.yes.data
		if ok && break_s.label == nil {
			mut not := 0
			mut unary, ok_3 := if_s.test.data
			if ok && unary.op == js_ast.un_op_not {
				not = unary.value
			} else {
				not = js_ast.not(if_s.test)
			}
			if s.test_or_nil.data != nil {
				s.test_or_nil = js_ast.Expr{
					loc:  s.test_or_nil.loc
					data: &js_ast.EBinary{
						op:    js_ast.bin_op_logical_and
						left:  s.test_or_nil
						right: not
					}
				}
			} else {
				s.test_or_nil = not
			}
			s.body = drop_first_statement(s.body, if_s.no_or_nil)
			return
		}
		if if_s.no_or_nil.data != nil {
			mut break_s_1, ok_4 := if_s.no_or_nil.data
			if ok && break_s.label == nil {
				if s.test_or_nil.data != nil {
					s.test_or_nil = js_ast.Expr{
						loc:  s.test_or_nil.loc
						data: &js_ast.EBinary{
							op:    js_ast.bin_op_logical_and
							left:  s.test_or_nil
							right: if_s.test
						}
					}
				} else {
					s.test_or_nil = if_s.test
				}
				s.body = drop_first_statement(s.body, if_s.yes)
				return
			}
		}
	}
}

fn append_if_or_label_body_preserving_scope(stmts []js_ast.Stmt, body js_ast.Stmt) []js_ast.Stmt {
	mut block, ok := body.data
	if ok {
		mut keep_block := false
		for _, stmt in block.stmts {
			if statement_cares_about_scope(stmt) {
				keep_block = true
				break
			}
		}
		if !keep_block {
			return append(stmts, block.stmts)
		}
	}
	if statement_cares_about_scope(body) {
		return append(stmts, js_ast.Stmt{
			loc:  body.loc
			data: &js_ast.SBlock{
				stmts: [body]
			}
		})
	}
	return append(stmts, body)
}

fn (p &Parser) mangle_if(stmts []js_ast.Stmt, loc logger.Loc, s &js_ast.SIf) []js_ast.Stmt {
	mut boolean, side_effects, ok := js_ast.to_boolean_with_side_effects(s.test.data)
	if ok {
		if boolean {
			if s.no_or_nil.data == nil || !should_keep_stmt_in_dead_control_flow(s.no_or_nil) {
				if side_effects == js_ast.could_have_side_effects {
					mut test := p.ast_helpers.simplify_unused_expr(s.test, p.options.unsupported_jsf_eatures)
					if test.data != nil {
						stmts << js_ast.Stmt{
							loc:  s.test.loc
							data: &js_ast.SExpr{
								value: test
							}
						}
					}
				}
				return append_if_or_label_body_preserving_scope(stmts, s.yes)
			} else {
			}
		}
		else {
			if !should_keep_stmt_in_dead_control_flow(s.yes) {
				if side_effects == js_ast.could_have_side_effects {
					mut test_1 := p.ast_helpers.simplify_unused_expr(s.test, p.options.unsupported_jsf_eatures)
					if test.data != nil {
						stmts << js_ast.Stmt{
							loc:  s.test.loc
							data: &js_ast.SExpr{
								value: test
							}
						}
					}
				}
				if s.no_or_nil.data == nil {
					return stmts
				}
				return append_if_or_label_body_preserving_scope(stmts, s.no_or_nil)
			} else {
			}
		}
		if side_effects == js_ast.no_side_effects {
			if boolean {
				s.test.data = &js_ast.ENumber{
					value: 1
				}
			} else {
				s.test.data = &js_ast.ENumber{
					value: 0
				}
			}
		}
	}
	mut expr := 0
	mut yes, ok_1 := s.yes.data
	if ok {
		if s.no_or_nil.data == nil {
			mut not, ok_2 := s.test.data
			if ok && not.op == js_ast.un_op_not {
				expr = js_ast.join_with_left_associative_op(js_ast.bin_op_logical_or,
					not.value, yes.value)
			} else {
				expr = js_ast.join_with_left_associative_op(js_ast.bin_op_logical_and,
					s.test, yes.value)
			}
		} else {
			// LOOL0
			mut no, ok_3 := s.no_or_nil.data
			if ok {
				expr = p.ast_helpers.mangle_if_expr(loc, &js_ast.EIf{
					test: s.test
					yes:  yes.value
					no:   no.value
				}, p.options.unsupported_jsf_eatures)
			}
		}
	} else {
		// LOOL0
		_, ok_4 := s.yes.data
		if ok {
			if s.no_or_nil.data == nil {
				if p.ast_helpers.expr_can_be_removed_if_unused(s.test) {
					return stmts
				} else {
					expr = s.test
				}
			} else {
				// LOOL0
				mut no_1, ok_5 := s.no_or_nil.data
				if ok {
					mut not_1, ok_6 := s.test.data
					if ok && not.op == js_ast.un_op_not {
						expr = js_ast.join_with_left_associative_op(js_ast.bin_op_logical_and,
							not.value, no.value)
					} else {
						expr = js_ast.join_with_left_associative_op(js_ast.bin_op_logical_or,
							s.test, no.value)
					}
				}
				else {
					mut not_2, ok_7 := s.test.data
					if ok && not.op == js_ast.un_op_not {
						s.test = not.value
						s.yes = s.no_or_nil
						s.no_or_nil = js_ast.Stmt{}
					} else {
						s.test = js_ast.not(s.test)
						s.yes = s.no_or_nil
						s.no_or_nil = js_ast.Stmt{}
					}
				}
			}
		}
		else {
			if s.no_or_nil.data != nil {
				mut not_3, ok_8 := s.test.data
				if ok && not.op == js_ast.un_op_not {
					s.test = not.value
					s.yes, s.no_or_nil = s.no_or_nil, s.yes
				}
			}
			else {
				mut s2, ok_9 := s.yes.data
				if ok && s2.no_or_nil.data == nil {
					s.test = js_ast.join_with_left_associative_op(js_ast.bin_op_logical_and,
						s.test, s2.test)
					s.yes = s2.yes
				}
			}
		}
	}
	if expr.data != nil {
		expr = p.ast_helpers.simplify_unused_expr(expr, p.options.unsupported_jsf_eatures)
		return append(stmts, js_ast.Stmt{
			loc:  loc
			data: &js_ast.SExpr{
				value: expr
			}
		})
	}
	return append(stmts, js_ast.Stmt{
		loc:  loc
		data: s
	})
}

fn (p &Parser) keep_expr_symbol_name(value js_ast.Expr, name string) js_ast.Expr {
	value = p.call_runtime(value.loc, '__name', [value, // UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
	])
	value.data.can_be_unwrapped_if_unused = true
	return value
}

fn (p &Parser) keep_class_or_fn_symbol_name(loc logger.Loc, expr js_ast.Expr, name string) js_ast.Stmt {
	return js_ast.Stmt{
		loc:  loc
		data: &js_ast.SExpr{
			value:                                             p.call_runtime(loc, '__name',
				[expr, // UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
			])
			is_from_class_or_fn_that_can_be_removed_if_unused: true
		}
	}
}

fn (p &Parser) visit_and_append_stmt(stmts []js_ast.Stmt, stmt js_ast.Stmt) []js_ast.Stmt {
	mut was_after_after_const_local_prefix := p.current_scope.is_after_const_local_prefix
	p.current_scope.is_after_const_local_prefix = true
	mut s := stmt.data
	match s {
		js_ast.SEmpty, js_ast.SComment {
			p.current_scope.is_after_const_local_prefix = was_after_after_const_local_prefix
		}
		js_ast.SDebugger {
			p.current_scope.is_after_const_local_prefix = was_after_after_const_local_prefix
			if p.options.drop_debugger {
				return stmts
			}
		}
		js_ast.STypeScript {
			p.current_scope.is_after_const_local_prefix = was_after_after_const_local_prefix
			return stmts
		}
		js_ast.SDirective {
			p.current_scope.is_after_const_local_prefix = was_after_after_const_local_prefix
			if p.is_strict_mode() && s.legacy_octal_loc.start > 0 {
				p.mark_strict_mode_feature(legacy_octal_escape, p.source.range_of_legacy_octal_escape(s.legacy_octal_loc),
					'')
			}
		}
		js_ast.SImport {
			p.record_declared_symbol(s.namespace_ref)
			if s.default_name != nil {
				p.record_declared_symbol(s.default_name.ref)
			}
			if s.items != nil {
				for _, item in &s.items {
					p.record_declared_symbol(item.name.ref)
				}
			}
		}
		js_ast.SExportClause {
			mut end := isize(0)
			for _, item_1 in s.items {
				mut name := p.load_name_from_ref(item.name.ref)
				mut ref := p.find_symbol(item.alias_loc, name).ref
				if p.symbols[ref.inner_index].kind == ast.symbol_unbound {
					if !p.options.ts.parse {
						mut r := js_lexer.range_of_identifier(p.source, item.name.loc)
						p.log.add_error(&p.tracker, r, strconv.v_sprintf('%q is not declared in this file',
							name))
					}
					continue
				}
				item.name.ref = ref
				s.items[end] = item
				end++
			}
			s.items = s.items[..end]
		}
		js_ast.SExportFrom {
			mut name_1 := p.load_name_from_ref(s.namespace_ref)
			s.namespace_ref = p.new_symbol(ast.symbol_other, name)
			p.current_scope.generated << s.namespace_ref
			p.record_declared_symbol(s.namespace_ref)
			for i, item_2 in s.items {
				mut name_2 := p.load_name_from_ref(item.name.ref)
				mut ref_1 := p.new_symbol(ast.symbol_other, name)
				p.current_scope.generated << ref
				p.record_declared_symbol(ref)
				s.items[i].name.ref = ref
			}
		}
		js_ast.SExportStar {
			mut name_3 := p.load_name_from_ref(s.namespace_ref)
			s.namespace_ref = p.new_symbol(ast.symbol_other, name)
			p.current_scope.generated << s.namespace_ref
			p.record_declared_symbol(s.namespace_ref)
			if s.alias != nil {
				if p.options.unsupported_jsf_eatures.has(compat.export_star_as) {
					p.record_usage(s.namespace_ref)
					return append(stmts, js_ast.Stmt{
						loc:  stmt.loc
						data: &js_ast.SImport{
							namespace_ref:       s.namespace_ref
							star_name_loc:       &s.alias.loc
							import_record_index: s.import_record_index
						}
					}, js_ast.Stmt{
						loc:  stmt.loc
						data: &js_ast.SExportClause{
							items:          [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
							]
							is_single_line: true
						}
					})
				}
			}
		}
		js_ast.SExportDefault {
			p.record_declared_symbol(s.default_name.ref)
			mut s2 := s.value.data
			match s2 {
				js_ast.SExpr {
					p.name_to_keep = 'default'
					p.name_to_keep_is_for = s2.value.data
					s2.value = p.visit_expr(s2.value)
					if p.options.ts.parse {
						mut id, ok := s2.value.data
						if ok {
							mut symbol := p.symbols[id.ref.inner_index]
							if symbol.kind == ast.symbol_unbound && p.local_type_names[symbol.original_name] {
								return stmts
							}
						}
					}
					if p.current_scope.parent == nil && p.will_wrap_module_in_try_catch_for_using {
						stmts << [
							js_ast.Stmt{
								loc:  stmt.loc
								data: &js_ast.SLocal{
									decls: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
									]
								}
							},
							js_ast.Stmt{
								loc:  stmt.loc
								data: &js_ast.SExportClause{
									items: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
									]
								}
							},
						]
						break
					}
					stmts << stmt
				}
				js_ast.SFunction {
					if p.options.keep_names {
						if s2.fn_.name == nil {
							mut clone := s.default_name
							s2.fn_.name = &clone
							name = 'default'
						} else {
							name = p.symbols[s2.fn_.name.ref.inner_index].original_name
						}
					}
					p.visit_fn(&s2.fn_, s2.fn_.open_paren_loc, VisitFnOpts{})
					stmts << stmt
					if p.options.keep_names {
						p.symbols[s2.fn_.name.ref.inner_index].flags |= ast.did_keep_name
						mut fn_ := js_ast.Expr{
							loc:  s2.fn_.name.loc
							data: &js_ast.EIdentifier{
								ref: s2.fn_.name.ref
							}
						}
						stmts << p.keep_class_or_fn_symbol_name(s2.fn_.name.loc, fn_,
							name)
					}
				}
				js_ast.SClass {
					mut result := p.visit_class(s.value.loc, &s2.class, s.default_name.ref,
						'default')
					mut class_stmts, _ := p.lower_class(stmt, js_ast.Expr{}, result, '')
					if result.can_be_removed_if_unused {
						for _, class_stmt in class_stmts {
							mut s2_1, ok_1 := class_stmt.data
							if ok {
								s2.is_from_class_or_fn_that_can_be_removed_if_unused = true
							}
						}
					}
					stmts << class_stmts
				}
				else {
					panic('Internal error')
				}
			}
			if p.symbols[s.default_name.ref.inner_index].original_name == 'default' {
				p.symbols[s.default_name.ref.inner_index].original_name =
					p.source.identifier_name + '_default'
			}
			return stmts
		}
		js_ast.SExportEquals {
			stmts << js_ast.assign_stmt(js_ast.Expr{
				loc:  stmt.loc
				data: &js_ast.EDot{
					target:   js_ast.Expr{
						loc:  stmt.loc
						data: &js_ast.EIdentifier{
							ref: p.module_ref
						}
					}
					name:     'exports'
					name_loc: stmt.loc
				}
			}, p.visit_expr(s.value))
			p.record_usage(p.module_ref)
			return stmts
		}
		js_ast.SBreak {
			if s.label != nil {
				mut name_4 := p.load_name_from_ref(s.label.ref)
				s.label.ref, _, _ = p.find_label_symbol(s.label.loc, name)
			} else if !p.fn_or_arrow_data_visit.is_inside_loop
				&& !p.fn_or_arrow_data_visit.is_inside_switch {
				mut r_1 := js_lexer.range_of_identifier(p.source, stmt.loc)
				p.log.add_error(&p.tracker, r, 'Cannot use "break" here:')
			}
		}
		js_ast.SContinue {
			if s.label != nil {
				mut name_5 := p.load_name_from_ref(s.label.ref)
				mut isLoop := 0
				s.label.ref, is_loop, ok = p.find_label_symbol(s.label.loc, name)
				if ok && !is_loop {
					mut r_2 := js_lexer.range_of_identifier(p.source, s.label.loc)
					p.log.add_error(&p.tracker, r, strconv.v_sprintf('Cannot continue to label "%s"',
						name))
				}
			} else if !p.fn_or_arrow_data_visit.is_inside_loop {
				mut r_3 := js_lexer.range_of_identifier(p.source, stmt.loc)
				p.log.add_error(&p.tracker, r, 'Cannot use "continue" here:')
			}
		}
		js_ast.SLabel {
			if p.is_strict_mode() {
				_, ok_2 := s.stmt.data
				if ok {
					p.mark_strict_mode_feature(label_function_stmt, js_lexer.range_of_identifier(p.source,
						s.stmt.loc), '')
				}
			}
			p.push_scope_for_visit_pass(js_ast.scope_label, stmt.loc)
			mut name_6 := p.load_name_from_ref(s.name.ref)
			if js_lexer.strict_mode_reserved_words[name] {
				p.mark_strict_mode_feature(reserved_word, js_lexer.range_of_identifier(p.source,
					s.name.loc), name)
			}
			mut ref_2 := p.new_symbol(ast.symbol_label, name)
			s.name.ref = ref
			for scope := p.current_scope.parent; scope != nil; scope = scope.parent {
				if scope.label.ref != ast.invalid_ref && name == p.symbols[scope.label.ref.inner_index].original_name {
					p.log.add_error_with_notes(&p.tracker, js_lexer.range_of_identifier(p.source,
						s.name.loc), strconv.v_sprintf('Duplicate label %q', name), [
						p.tracker.msg_data(js_lexer.range_of_identifier(p.source, scope.label.loc),
							strconv.v_sprintf('The original label %q is here:', name)),
					])
					break
				}
				if scope.kind == js_ast.scope_function_body {
					break
				}
			}
			p.current_scope.label = ast.LocRef{
				loc: s.name.loc
				ref: ref
			}
			// append no rhs

			// lhs.len==0
			_, should_drop_label := p.drop_labels_map[name]
			mut old := p.is_control_flow_dead
			if should_drop_label {
				p.is_control_flow_dead = true
			}
			s.stmt = p.visit_single_stmt(s.stmt, stmts_normal)
			p.pop_scope()
			if should_drop_label {
				p.is_control_flow_dead = old
				return stmts
			}
			if p.options.minify_syntax {
				mut child, ok_3 := s.stmt.data
				if ok && child.label != nil && child.label.ref == s.name.ref {
					return stmts
				}
				if p.symbols[ref.inner_index].use_count_estimate == 0 {
					return append_if_or_label_body_preserving_scope(stmts, s.stmt)
				}
			}
			mut try, ok_4 := s.stmt.data
			if ok && try.block.stmts.len > 0 {
				_, ok_5 := try.block.stmts[0].data
				if ok {
					try.block.stmts[0] = js_ast.Stmt{
						loc:  stmt.loc
						data: &js_ast.SLabel{
							stmt:                try.block.stmts[0]
							name:                s.name
							is_single_line_stmt: s.is_single_line_stmt
						}
					}
					return append(stmts, s.stmt)
				}
			}
		}
		js_ast.SLocal {
			if s.kind == js_ast.local_await_using && p.fn_or_arrow_data_visit.is_outside_fn_or_arrow {
				if p.is_control_flow_dead && (
					p.options.unsupported_jsf_eatures.has(compat.top_level_await)
					|| !p.options.output_format.keep_esmi_mport_export_syntax()) {
					s.kind = js_ast.local_using
				} else {
					p.live_top_level_await_keyword = logger.Range{
						loc: stmt.loc
						len: 5
					}
					p.mark_syntax_feature(compat.top_level_await, logger.Range{
						loc: stmt.loc
						len: 5
					})
				}
			}
			p.current_scope.is_after_const_local_prefix = was_after_after_const_local_prefix
			for i_1, _ in s.decls {
				mut d := &s.decls[i]
				p.visit_binding(d.binding, BindingOpts{})
				if d.value_or_nil.data != nil {
					mut old_should_fold_type_script_constant_expressions := p.should_fold_type_script_constant_expressions
					p.should_fold_type_script_constant_expressions = p.options.minify_syntax
						&& !p.current_scope.is_after_const_local_prefix
					mut id_1, ok_6 := d.binding.data
					if ok {
						p.name_to_keep = p.symbols[id.ref.inner_index].original_name
						p.name_to_keep_is_for = d.value_or_nil.data
					}
					d.value_or_nil = p.visit_expr(d.value_or_nil)
					p.should_fold_type_script_constant_expressions = old_should_fold_type_script_constant_expressions
					if p.options.minify_syntax && s.kind == js_ast.local_let {
						_, ok_7 := d.binding.data
						if ok {
							_, ok_8 := d.value_or_nil.data
							if ok {
								d.value_or_nil = js_ast.Expr{}
							}
						}
					}
					if p.options.decode_hydrate_runtime_state_yarn_pn_p {
						mut str, ok_9 := d.value_or_nil.data
						if ok {
							mut id_2, ok_10 := d.binding.data
							if ok {
								if p.string_locals_for_yarn_pn_p == nil {
									p.string_locals_for_yarn_pn_p = map[ast.Ref]StringLocalForYarnPnP{}
								}
								p.string_locals_for_yarn_pn_p[id.ref] = StringLocalForYarnPnP{
									value: str.value
									loc:   d.value_or_nil.loc
								}
							}
						}
					}
				}
				if p.options.minify_syntax && !p.current_scope.is_after_const_local_prefix {
					mut id_3, ok_11 := d.binding.data
					if ok {
						if s.kind == js_ast.local_const && d.value_or_nil.data != nil {
							mut value := js_ast.expr_to_const_value(d.value_or_nil)
							if value.kind != js_ast.const_value_none {
								if p.const_values == nil {
									p.const_values = map[ast.Ref]js_ast.ConstValue{}
								}
								p.const_values[id.ref] = value
								continue
							}
						}
						if d.value_or_nil.data != nil
							&& !is_safe_for_const_local_prefix(d.value_or_nil) {
							p.current_scope.is_after_const_local_prefix = true
						}
					} else {
						p.current_scope.is_after_const_local_prefix = true
					}
				}
			}
			if s.is_export && p.enclosing_namespace_arg_ref != nil {
				mut wrap_identifier := fn (loc logger.Loc, ref ast.Ref) {
					p.record_usage(&p.enclosing_namespace_arg_ref)
					return js_ast.Expr{
						loc:  loc
						data: p.dot_or_mangled_prop_visit(js_ast.Expr{
							loc:  loc
							data: &js_ast.EIdentifier{
								ref: &p.enclosing_namespace_arg_ref
							}
						}, p.symbols[ref.inner_index].original_name, loc)
					}
				}

				for _, decl in s.decls {
					if decl.value_or_nil.data != nil {
						mut target := js_ast.convert_binding_to_expr(decl.binding, wrap_identifier)
						mut result_1, ok_12 := p.lower_assign(target, decl.value_or_nil,
							obj_rest_return_value_is_unused)
						if ok {
							target = result
						} else {
							target = js_ast.assign(target, decl.value_or_nil)
						}
						stmts << js_ast.Stmt{
							loc:  stmt.loc
							data: &js_ast.SExpr{
								value: target
							}
						}
					}
				}
				return stmts
			}
			s.decls = p.lower_object_rest_in_decls(s.decls)
			if p.options.minify_syntax && s.kind == js_ast.local_using {
				s.kind = js_ast.local_const
				for _, decl_1 in s.decls {
					mut t := js_ast.known_primitive_type(decl.value_or_nil.data)
					if t != js_ast.primitive_null && t != js_ast.primitive_undefined {
						s.kind = js_ast.local_using
						break
					}
				}
			}
			s.kind = p.select_local_kind(s.kind)
			if s.kind == js_ast.local_var {
				mut assign, ok_13 := p.maybe_relocate_vars_to_top_level(s.decls, relocate_vars_normal)
				if ok {
					if assign.data != nil {
						stmts << assign
					}
					return stmts
				}
			}
		}
		js_ast.SExpr {
			mut should_trim_unsightly_primitives := !p.options.minify_syntax
				&& !is_unsightly_primitive(s.value.data)
			p.stmt_expr_value = s.value.data
			s.value = p.visit_expr(s.value)
			if should_trim_unsightly_primitives && is_unsightly_primitive(s.value.data) {
				return stmts
			}
			if p.options.minify_syntax {
				s.value = p.ast_helpers.simplify_unused_expr(s.value, p.options.unsupported_jsf_eatures)
				if s.value.data == nil {
					return stmts
				}
			}
		}
		js_ast.SThrow {
			s.value = p.visit_expr(s.value)
		}
		js_ast.SReturn {
			if p.fn_or_arrow_data_visit.is_outside_fn_or_arrow {
				if p.is_file_considered_esm {
					_, notes := p.why_esm_odule()
					p.log.add_error_with_notes(&p.tracker, js_lexer.range_of_identifier(p.source,
						stmt.loc), 'Top-level return cannot be used inside an ECMAScript module',
						notes)
				} else {
					p.has_top_level_return = true
				}
			}
			if s.value_or_nil.data != nil {
				s.value_or_nil = p.visit_expr(s.value_or_nil)
				if p.options.minify_syntax && (!p.fn_or_arrow_data_visit.is_async
					|| !p.fn_or_arrow_data_visit.is_generator) {
					_, ok_14 := s.value_or_nil.data
					if ok {
						s.value_or_nil = js_ast.Expr{}
					}
				}
			}
		}
		js_ast.SBlock {
			p.push_scope_for_visit_pass(js_ast.scope_block, stmt.loc)
			if p.loop_body == s {
				s.stmts = p.visit_stmts(s.stmts, stmts_loop_body)
			} else {
				s.stmts = p.visit_stmts(s.stmts, stmts_normal)
			}
			p.pop_scope()
			if p.options.minify_syntax {
				if s.stmts.len == 1 && !statement_cares_about_scope(s.stmts[0]) {
					stmt = s.stmts[0]
				} else if s.stmts.len == 0 {
					stmt = js_ast.Stmt{
						loc:  stmt.loc
						data: js_ast.se_mpty_shared
					}
				}
			}
		}
		js_ast.SWith {
			p.mark_strict_mode_feature(with_statement, js_lexer.range_of_identifier(p.source,
				stmt.loc), '')
			s.value = p.visit_expr(s.value)
			p.push_scope_for_visit_pass(js_ast.scope_with, s.body_loc)
			s.body = p.visit_single_stmt(s.body, stmts_normal)
			p.pop_scope()
		}
		js_ast.SWhile {
			s.test = p.visit_expr(s.test)
			s.body = p.visit_loop_body(s.body)
			if p.options.minify_syntax {
				s.test = p.ast_helpers.simplify_boolean_expr(s.test)
				mut test_or_nil := s.test
				mut boolean, side_effects, ok_15 := js_ast.to_boolean_with_side_effects(s.test.data)
				if ok && boolean && side_effects == js_ast.no_side_effects {
					test_or_nil = js_ast.Expr{}
				}
				mut for_s := &js_ast.SFor{
					test_or_nil:         test_or_nil
					body:                s.body
					is_single_line_body: s.is_single_line_body
				}
				mangle_for(for_s)
				stmt = js_ast.Stmt{
					loc:  stmt.loc
					data: for_s
				}
			}
		}
		js_ast.SDoWhile {
			s.body = p.visit_loop_body(s.body)
			s.test = p.visit_expr(s.test)
			if p.options.minify_syntax {
				s.test = p.ast_helpers.simplify_boolean_expr(s.test)
			}
		}
		js_ast.SIf {
			s.test = p.visit_expr(s.test)
			if p.options.minify_syntax {
				s.test = p.ast_helpers.simplify_boolean_expr(s.test)
			}
			mut boolean_1, _, ok_16 := js_ast.to_boolean_with_side_effects(s.test.data)
			if ok && !boolean {
				mut old_1 := p.is_control_flow_dead
				p.is_control_flow_dead = true
				s.yes = p.visit_single_stmt(s.yes, stmts_normal)
				p.is_control_flow_dead = old
			} else {
				s.yes = p.visit_single_stmt(s.yes, stmts_normal)
			}
			if s.no_or_nil.data != nil {
				if ok && boolean {
					mut old_2 := p.is_control_flow_dead
					p.is_control_flow_dead = true
					s.no_or_nil = p.visit_single_stmt(s.no_or_nil, stmts_normal)
					p.is_control_flow_dead = old
				} else {
					s.no_or_nil = p.visit_single_stmt(s.no_or_nil, stmts_normal)
				}
				if p.options.minify_syntax {
					_, ok_17 := s.no_or_nil.data
					if ok {
						s.no_or_nil = js_ast.Stmt{}
					}
				}
			}
			if p.options.minify_syntax {
				return p.mangle_if(stmts, stmt.loc, s)
			}
		}
		js_ast.SFor {
			p.push_scope_for_visit_pass(js_ast.scope_block, stmt.loc)
			if s.init_or_nil.data != nil {
				p.visit_for_loop_init(s.init_or_nil, false)
			}
			if s.test_or_nil.data != nil {
				s.test_or_nil = p.visit_expr(s.test_or_nil)
				if p.options.minify_syntax {
					s.test_or_nil = p.ast_helpers.simplify_boolean_expr(s.test_or_nil)
					mut boolean_2, side_effects_1, ok_18 := js_ast.to_boolean_with_side_effects(s.test_or_nil.data)
					if ok && boolean && side_effects == js_ast.no_side_effects {
						s.test_or_nil = js_ast.Expr{}
					}
				}
			}
			if s.update_or_nil.data != nil {
				s.update_or_nil = p.visit_expr(s.update_or_nil)
			}
			s.body = p.visit_loop_body(s.body)
			if s.init_or_nil.data != nil {
				mut init, ok_19 := s.init_or_nil.data
				if ok && init.kind == js_ast.local_var {
					mut assign_1, ok_20 := p.maybe_relocate_vars_to_top_level(init.decls,
						relocate_vars_normal)
					if ok {
						if assign.data != nil {
							s.init_or_nil = assign
						} else {
							s.init_or_nil = js_ast.Stmt{}
						}
					}
				}
			}
			p.pop_scope()
			if p.options.minify_syntax {
				mangle_for(s)
			}
		}
		js_ast.SForIn {
			p.push_scope_for_visit_pass(js_ast.scope_block, stmt.loc)
			p.visit_for_loop_init(s.init, true)
			s.value = p.visit_expr(s.value)
			s.body = p.visit_loop_body(s.body)
			mut local, ok_21 := s.init.data
			if ok && local.kind == js_ast.local_var && local.decls.len == 1 {
				mut decl_2 := &local.decls[0]
				mut id_4, ok_22 := decl.binding.data
				if ok && decl.value_or_nil.data != nil {
					p.mark_strict_mode_feature(for_in_var_init, p.source.range_of_operator_before(decl.value_or_nil.loc,
						'='), '')
					stmts << js_ast.Stmt{
						loc:  stmt.loc
						data: &js_ast.SExpr{
							value: js_ast.assign(js_ast.Expr{
								loc:  decl.binding.loc
								data: &js_ast.EIdentifier{
									ref: id.ref
								}
							}, decl.value_or_nil)
						}
					}
					decl.value_or_nil = js_ast.Expr{}
				}
			}
			mut init_1, ok_23 := s.init.data
			if ok && init.kind == js_ast.local_var {
				mut replacement, ok_24 := p.maybe_relocate_vars_to_top_level(init.decls,
					relocate_vars_for_in_or_for_of)
				if ok {
					s.init = replacement
				}
			}
			p.pop_scope()
			p.lower_object_rest_in_for_loop_init(s.init, &s.body)
		}
		js_ast.SForOf {
			if s.await.len > 0 && p.fn_or_arrow_data_visit.is_outside_fn_or_arrow {
				if p.is_control_flow_dead && (
					p.options.unsupported_jsf_eatures.has(compat.top_level_await)
					|| !p.options.output_format.keep_esmi_mport_export_syntax()) {
					s.await = logger.Range{}
				} else {
					p.live_top_level_await_keyword = s.await
					p.mark_syntax_feature(compat.top_level_await, s.await)
				}
			}
			p.push_scope_for_visit_pass(js_ast.scope_block, stmt.loc)
			p.visit_for_loop_init(s.init, true)
			s.value = p.visit_expr(s.value)
			s.body = p.visit_loop_body(s.body)
			mut init_2, ok_25 := s.init.data
			if ok && init.kind == js_ast.local_var {
				mut replacement_1, ok_26 := p.maybe_relocate_vars_to_top_level(init.decls,
					relocate_vars_for_in_or_for_of)
				if ok {
					s.init = replacement
				}
			}
			mut local_1, ok_27 := s.init.data
			if ok {
				if local.kind == js_ast.local_using && p.options.unsupported_jsf_eatures.has(compat.using) {
					p.lower_using_declaration_in_for_of(s.init.loc, local, &s.body)
				} else if local.kind == js_ast.local_await_using {
					if p.fn_or_arrow_data_visit.is_outside_fn_or_arrow {
						if p.is_control_flow_dead && (
							p.options.unsupported_jsf_eatures.has(compat.top_level_await)
							|| !p.options.output_format.keep_esmi_mport_export_syntax()) {
							local.kind = js_ast.local_using
						} else {
							p.live_top_level_await_keyword = logger.Range{
								loc: s.init.loc
								len: 5
							}
							p.mark_syntax_feature(compat.top_level_await, p.live_top_level_await_keyword)
						}
						if p.options.unsupported_jsf_eatures.has(compat.using) {
							p.lower_using_declaration_in_for_of(s.init.loc, local, &s.body)
						}
					} else if p.options.unsupported_jsf_eatures.has(compat.using)
						|| p.options.unsupported_jsf_eatures.has(compat.async_await)
						|| p.options.unsupported_jsf_eatures.has(compat.async_generator)
						&& p.fn_or_arrow_data_visit.is_generator {
						p.lower_using_declaration_in_for_of(s.init.loc, local, &s.body)
					}
				}
			}
			p.pop_scope()
			p.lower_object_rest_in_for_loop_init(s.init, &s.body)
			if s.await.len > 0 && (p.options.unsupported_jsf_eatures.has(compat.for_await)
				|| p.options.unsupported_jsf_eatures.has(compat.async_generator)
				&& p.fn_or_arrow_data_visit.is_generator) {
				return p.lower_for_await_loop(stmt.loc, s, stmts)
			}
		}
		js_ast.STry {
			p.push_scope_for_visit_pass(js_ast.scope_block, stmt.loc)
			if p.fn_or_arrow_data_visit.try_body_count == 0 {
				if s.catch != nil {
					p.fn_or_arrow_data_visit.try_catch_loc = s.catch.loc
				} else {
					p.fn_or_arrow_data_visit.try_catch_loc = stmt.loc
				}
			}
			p.fn_or_arrow_data_visit.try_body_count++
			s.block.stmts = p.visit_stmts(s.block.stmts, stmts_normal)
			p.fn_or_arrow_data_visit.try_body_count--
			p.pop_scope()
			if s.catch != nil {
				p.push_scope_for_visit_pass(js_ast.scope_catch_binding, s.catch.loc)
				if s.catch.binding_or_nil.data != nil {
					p.visit_binding(s.catch.binding_or_nil, BindingOpts{})
				}
				p.push_scope_for_visit_pass(js_ast.scope_block, s.catch.block_loc)
				s.catch.block.stmts = p.visit_stmts(s.catch.block.stmts, stmts_normal)
				p.pop_scope()
				p.lower_object_rest_in_catch_binding(s.catch)
				p.pop_scope()
			}
			if s.finally != nil {
				p.push_scope_for_visit_pass(js_ast.scope_block, s.finally.loc)
				s.finally.block.stmts = p.visit_stmts(s.finally.block.stmts, stmts_normal)
				p.pop_scope()
			}
		}
		js_ast.SSwitch {
			s.test = p.visit_expr(s.test)
			p.push_scope_for_visit_pass(js_ast.scope_block, s.body_loc)
			mut old_is_inside_switch := p.fn_or_arrow_data_visit.is_inside_switch
			p.fn_or_arrow_data_visit.is_inside_switch = true
			for i_2, c in s.cases {
				if c.value_or_nil.data != nil {
					c.value_or_nil = p.visit_expr(c.value_or_nil)
					p.warn_about_equality_check('case', c.value_or_nil, c.value_or_nil.loc)
					p.warn_about_typeof_and_string(s.test, c.value_or_nil, only_check_original_order)
				}
				c.body = p.visit_stmts(c.body, stmts_switch)
				s.cases[i] = c
			}
			p.fn_or_arrow_data_visit.is_inside_switch = old_is_inside_switch
			p.pop_scope()
			p.duplicate_case_checker.reset()
			for _, c_1 in s.cases {
				if c.value_or_nil.data != nil {
					p.duplicate_case_checker.check(p, c.value_or_nil)
				}
			}
			if p.options.minify_syntax && p.is_control_flow_dead {
				for _, c_2 in s.cases {
					stmts << c.body
				}
				return stmts
			}
			mut lowered := p.maybe_lower_using_declarations_in_switch(stmt.loc, s)
			if lowered != nil {
				return append(stmts, lowered)
			}
		}
		js_ast.SFunction {
			p.visit_fn(&s.fn_, s.fn_.open_paren_loc, VisitFnOpts{})
			if p.symbols[s.fn_.name.ref.inner_index].flags.has(ast.remove_overwritten_function_declaration)
				&& !s.is_export {
				return stmts
			}
			if p.options.minify_syntax && !s.fn_.is_generator && !s.fn_.is_async
				&& !s.fn_.has_rest_arg && s.fn_.name != nil {
				if s.fn_.body.block.stmts.len == 0 {
					mut has_side_effect_free_arguments := true
					for _, arg in s.fn_.args {
						_, ok_28 := arg.binding.data
						if !ok {
							has_side_effect_free_arguments = false
							break
						}
					}
					if has_side_effect_free_arguments {
						p.symbols[s.fn_.name.ref.inner_index].flags |= ast.is_empty_function
					}
				} else if s.fn_.args.len == 1 && s.fn_.body.block.stmts.len == 1 {
					mut arg_1 := s.fn_.args[0]
					if arg.default_or_nil.data == nil {
						mut id_5, ok_29 := arg.binding.data
						if ok {
							mut ret, ok_30 := s.fn_.body.block.stmts[0].data
							if ok {
								mut ret_id, ok_31 := ret.value_or_nil.data
								if ok && id.ref == ret_id.ref {
									p.symbols[s.fn_.name.ref.inner_index].flags |= ast.is_identity_function
								}
							}
						}
					}
				}
			}
			if s.is_export && p.enclosing_namespace_arg_ref != nil {
				s.is_export = false
				stmts << [stmt,
					js_ast.assign_stmt(js_ast.Expr{
						loc:  stmt.loc
						data: p.dot_or_mangled_prop_visit(js_ast.Expr{
							loc:  stmt.loc
							data: &js_ast.EIdentifier{
								ref: &p.enclosing_namespace_arg_ref
							}
						}, p.symbols[s.fn_.name.ref.inner_index].original_name, s.fn_.name.loc)
					}, js_ast.Expr{
						loc:  s.fn_.name.loc
						data: &js_ast.EIdentifier{
							ref: s.fn_.name.ref
						}
					})]
			} else {
				stmts << stmt
			}
			if p.options.keep_names {
				mut symbol_1 := &p.symbols[s.fn_.name.ref.inner_index]
				symbol.flags |= ast.did_keep_name
				mut fn_1 := js_ast.Expr{
					loc:  s.fn_.name.loc
					data: &js_ast.EIdentifier{
						ref: s.fn_.name.ref
					}
				}
				stmts << p.keep_class_or_fn_symbol_name(s.fn_.name.loc, fn_, symbol.original_name)
			}
			return stmts
		}
		js_ast.SClass {
			mut result_2 := p.visit_class(stmt.loc, &s.class, ast.invalid_ref, '')
			mut nameToExport := 0
			mut was_export_inside_namespace := s.is_export && p.enclosing_namespace_arg_ref != nil
			if was_export_inside_namespace {
				name_to_export = p.symbols[s.class.name.ref.inner_index].original_name
				s.is_export = false
			}
			mut class_stmts_1, _ := p.lower_class(stmt, js_ast.Expr{}, result, '')
			if result.can_be_removed_if_unused {
				for _, class_stmt_1 in class_stmts {
					mut s2_2, ok_32 := class_stmt.data
					if ok {
						s2.is_from_class_or_fn_that_can_be_removed_if_unused = true
					}
				}
			}
			stmts << class_stmts
			if was_export_inside_namespace {
				stmts << js_ast.assign_stmt(js_ast.Expr{
					loc:  stmt.loc
					data: p.dot_or_mangled_prop_visit(js_ast.Expr{
						loc:  stmt.loc
						data: &js_ast.EIdentifier{
							ref: &p.enclosing_namespace_arg_ref
						}
					}, name_to_export, s.class.name.loc)
				}, js_ast.Expr{
					loc:  s.class.name.loc
					data: &js_ast.EIdentifier{
						ref: s.class.name.ref
					}
				})
			}
			return stmts
		}
		js_ast.SEnum {
			p.current_scope.is_after_const_local_prefix = was_after_after_const_local_prefix
			mut tsTopLevelEnumValues := map[string]js_ast.TSEnumValue{}
			if p.current_scope == p.module_scope && p.options.mode == config.mode_bundle {
				ts_top_level_enum_values = map[string]js_ast.TSEnumValue{}
			}
			p.record_declared_symbol(s.name.ref)
			p.push_scope_for_visit_pass(js_ast.scope_entry, stmt.loc)
			p.record_declared_symbol(s.arg)
			for _, value_1 in s.values {
				if value.ref != ast.invalid_ref {
					p.is_exported_inside_namespace[value.ref] = s.arg
				}
			}
			mut next_numeric_value := f64(0)
			mut has_numeric_value := true
			mut value_exprs := []
			{}
			mut all_values_are_pure := true
			mut exported_members := p.current_scope.tsn_amespace.exported_members
			mut old_should_fold_type_script_constant_expressions_1 := p.should_fold_type_script_constant_expressions
			p.should_fold_type_script_constant_expressions = true
			for _, value_2 in s.values {
				mut name_7 := helpers.utf_16_to_string(value.name)
				mut assignTarget := 0
				mut has_string_value := false
				if value.value_or_nil.data != nil {
					value.value_or_nil = p.visit_expr(value.value_or_nil)
					has_numeric_value = false
					mut underlying_value := value.value_or_nil
					mut inlined, ok_33 := value.value_or_nil.data
					if ok {
						underlying_value = inlined.value
					}
					mut e := underlying_value.data
					match e {
						js_ast.ENumber {
							if ts_top_level_enum_values != nil {
								ts_top_level_enum_values[name] = js_ast.TSEnumValue{
									number: e.value
								}
							}
							mut member := exported_members[name]
							member.data = &js_ast.TSNamespaceMemberEnumNumber{
								value: e.value
							}
							exported_members[name] = member
							p.ref_to_tsn_amespace_member_data[value.ref] = member.data
							has_numeric_value = true
							next_numeric_value = e.value + 1
						}
						js_ast.EString {
							if ts_top_level_enum_values != nil {
								ts_top_level_enum_values[name] = js_ast.TSEnumValue{
									string: e.value
								}
							}
							mut member_1 := exported_members[name]
							member.data = &js_ast.TSNamespaceMemberEnumString{
								value: e.value
							}
							exported_members[name] = member
							p.ref_to_tsn_amespace_member_data[value.ref] = member.data
							has_string_value = true
						}
						else {
							if js_ast.known_primitive_type(underlying_value.data) == js_ast.primitive_string {
								has_string_value = true
							}
							if !p.ast_helpers.expr_can_be_removed_if_unused(underlying_value) {
								all_values_are_pure = false
							}
						}
					}
				} else if has_numeric_value {
					if ts_top_level_enum_values != nil {
						ts_top_level_enum_values[name] = js_ast.TSEnumValue{
							number: next_numeric_value
						}
					}
					mut member_2 := exported_members[name]
					member.data = &js_ast.TSNamespaceMemberEnumNumber{
						value: next_numeric_value
					}
					exported_members[name] = member
					p.ref_to_tsn_amespace_member_data[value.ref] = member.data
					value.value_or_nil = js_ast.Expr{
						loc:  value.loc
						data: &js_ast.ENumber{
							value: next_numeric_value
						}
					}
					next_numeric_value++
				} else {
					value.value_or_nil = js_ast.Expr{
						loc:  value.loc
						data: js_ast.eu_ndefined_shared
					}
				}
				if p.options.minify_syntax && js_ast.is_identifier(name) {
					assign_target = js_ast.assign(js_ast.Expr{
						loc:  value.loc
						data: &js_ast.EDot{
							target:   js_ast.Expr{
								loc:  value.loc
								data: &js_ast.EIdentifier{
									ref: s.arg
								}
							}
							name:     name
							name_loc: value.loc
						}
					}, value.value_or_nil)
				} else {
					assign_target = js_ast.assign(js_ast.Expr{
						loc:  value.loc
						data: &js_ast.EIndex{
							target: js_ast.Expr{
								loc:  value.loc
								data: &js_ast.EIdentifier{
									ref: s.arg
								}
							}
							index:  js_ast.Expr{
								loc:  value.loc
								data: &js_ast.EString{
									value: value.name
								}
							}
						}
					}, value.value_or_nil)
				}
				p.record_usage(s.arg)
				if has_string_value {
					value_exprs << assign_target
				} else {
					value_exprs << js_ast.assign(js_ast.Expr{
						loc:  value.loc
						data: &js_ast.EIndex{
							target: js_ast.Expr{
								loc:  value.loc
								data: &js_ast.EIdentifier{
									ref: s.arg
								}
							}
							index:  assign_target
						}
					}, js_ast.Expr{
						loc:  value.loc
						data: &js_ast.EString{
							value: value.name
						}
					})
					p.record_usage(s.arg)
				}
			}
			p.pop_scope()
			p.should_fold_type_script_constant_expressions = old_should_fold_type_script_constant_expressions
			if ts_top_level_enum_values != nil {
				if p.ts_enums == nil {
					p.ts_enums = map[ast.Ref]map[string]js_ast.TSEnumValue{}
				}
				p.ts_enums[s.name.ref] = ts_top_level_enum_values
			}
			stmts = p.generate_closure_for_type_script_enum(stmts, stmt.loc, s.is_export,
				s.name.loc, s.name.ref, s.arg, value_exprs, all_values_are_pure)
			return stmts
		}
		js_ast.SNamespace {
			p.record_declared_symbol(s.name.ref)
			for _, child_stmt in s.stmts {
				mut local_2, ok_34 := child_stmt.data
				if ok {
					if local.is_export {
						js_ast.for_each_identifier_binding_in_decls(local.decls, fn (loc logger.Loc, b &js_ast.BIdentifier) {
							p.is_exported_inside_namespace[b.ref] = s.arg
						})
					}
				}
			}
			mut old_enclosing_namespace_arg_ref := p.enclosing_namespace_arg_ref
			p.enclosing_namespace_arg_ref = &s.arg
			p.push_scope_for_visit_pass(js_ast.scope_entry, stmt.loc)
			p.record_declared_symbol(s.arg)
			mut stmts_inside_namespace := p.visit_stmts_and_prepend_temp_refs(s.stmts,
				PrependTempRefsOpts{
				kind: stmts_fn_body
			})
			p.pop_scope()
			p.enclosing_namespace_arg_ref = old_enclosing_namespace_arg_ref
			stmts = p.generate_closure_for_type_script_namespace_or_enum(stmts, stmt.loc,
				s.is_export, s.name.loc, s.name.ref, s.arg, stmts_inside_namespace)
			return stmts
		}
		else {
			panic('Internal error')
		}
	}
	stmts << stmt
	return stmts
}

fn is_unsightly_primitive(data js_ast.E) bool {
	// append no rhs

	// lhs.len==0
	return false
}

// If we encounter a variable initializer that could possibly trigger access to
// a constant declared later on, then we need to end the const local prefix.
// We want to avoid situations like this:
//
//	const x = y; // This is supposed to throw due to TDZ
//	const y = 1;
//
// or this:
//
//	const x = 1;
//	const y = foo(); // This is supposed to throw due to TDZ
//	const z = 2;
//	const foo = () => z;
//
// But a situation like this is ok:
//
//	const x = 1;
//	const y = [() => x + z];
//	const z = 2;
fn is_safe_for_const_local_prefix(expr js_ast.Expr) bool {
	mut e := expr.data
	match e {
		js_ast.EMissing, js_ast.EString, js_ast.ERegExp, js_ast.EBigInt, js_ast.EFunction,
		js_ast.EArrow {
			return true
		}
		js_ast.EArray {
			for _, item in e.items {
				if !is_safe_for_const_local_prefix(item) {
					return false
				}
			}
			return true
		}
		js_ast.EObject {
			return e.properties.len == 0
		}
	}
	return false
}

type relocateVarsMode = u8

enum relocateVarsMode {
	relocate_vars_normal
	relocate_vars_for_in_or_for_of
}

// If we are currently in a hoisted child of the module scope, relocate these
// declarations to the top level and return an equivalent assignment statement.
// Make sure to check that the declaration kind is "var" before calling this.
// And make sure to check that the returned statement is not the zero value.
//
// This is done to make it easier to traverse top-level declarations in the linker
// during bundling. Now it is sufficient to just scan the top-level statements
// instead of having to traverse recursively into the statement tree.
fn (p &Parser) maybe_relocate_vars_to_top_level(decls []js_ast.Decl, mode relocateVarsMode) (js_ast.Stmt, bool) {
	if p.options.mode != config.mode_bundle || p.current_scope == p.module_scope {
		return js_ast.Stmt{}, false
	}
	mut scope := p.current_scope
	for !scope.kind.stops_hoisting() {
		scope = scope.parent
	}
	if scope != p.module_scope {
		return js_ast.Stmt{}, false
	}
	mut wrap_identifier := fn (loc logger.Loc, ref ast.Ref) {
		p.relocated_top_level_vars << ast.LocRef{
			loc: loc
			ref: ref
		}
		p.record_usage(ref)
		return js_ast.Expr{
			loc:  loc
			data: &js_ast.EIdentifier{
				ref: ref
			}
		}
	}

	mut value := 0
	for _, decl in decls {
		mut binding := js_ast.convert_binding_to_expr(decl.binding, wrap_identifier)
		if decl.value_or_nil.data != nil {
			value = js_ast.join_with_comma(value, js_ast.assign(binding, decl.value_or_nil))
		} else if mode == relocate_vars_for_in_or_for_of {
			value = js_ast.join_with_comma(value, binding)
		}
	}
	if value.data == nil {
		return js_ast.Stmt{}, true
	}
	return js_ast.Stmt{
		loc:  value.loc
		data: &js_ast.SExpr{
			value: value
		}
	}, true
}

fn (p &Parser) mark_expr_as_parenthesized(value js_ast.Expr, open_paren_loc logger.Loc, is_async bool) {
	if !is_async {
		mut comments, ok := p.expr_comments[open_paren_loc]
		if ok {
			p.expr_comments.delete(open_paren_loc)
			p.expr_comments[value.loc] << p.expr_comments[value.loc]
		}
	}
	mut e := value.data
	match e {
		js_ast.EArray {
			e.is_parenthesized = true
		}
		js_ast.EObject {
			e.is_parenthesized = true
		}
	}
}

fn (p &Parser) maybe_transpose_if_expr_chain(expr js_ast.Expr, visit fn (_ js_ast.Expr) js_ast.Expr) js_ast.Expr {
	mut e, ok := expr.data
	if ok {
		e.yes = p.maybe_transpose_if_expr_chain(e.yes, visit)
		e.no = p.maybe_transpose_if_expr_chain(e.no, visit)
		return expr
	}
	return visit(expr)
}

fn (p &Parser) iife_can_be_removed_if_unused(args []js_ast.Arg, body js_ast.FnBody) bool {
	for _, arg in args {
		if arg.default_or_nil.data != nil
			&& !p.ast_helpers.expr_can_be_removed_if_unused(arg.default_or_nil) {
			return false
		}
		_, ok := arg.binding.data
		if !ok {
			return false
		}
	}
	return p.ast_helpers.stmts_can_be_removed_if_unused(body.block.stmts, js_ast.return_can_be_removed_if_unused)
}

type captureValueMode = u8

enum captureValueMode {
	value_definitely_not_mutated
	value_could_be_mutated
}

// This is a helper function to use when you need to capture a value that may
// have side effects so you can use it multiple times. It guarantees that the
// side effects take place exactly once.
//
// Example usage:
//
//	// "value" => "value + value"
//	// "value()" => "(_a = value(), _a + _a)"
//	valueFunc, wrapFunc := p.captureValueWithPossibleSideEffects(loc, 2, value)
//	return wrapFunc(js_ast.Expr{Loc: loc, Data: &js_ast.EBinary{
//	  Op: js_ast.BinOpAdd,
//	  Left: valueFunc(),
//	  Right: valueFunc(),
//	}})
//
// This returns a function for generating references instead of a raw reference
// because AST nodes are supposed to be unique in memory, not aliases of other
// AST nodes. That way you can mutate one during lowering without having to
// worry about messing up other nodes.
fn (p &Parser) capture_value_with_possible_side_effects(loc logger.Loc, count isize, value js_ast.Expr, mode captureValueMode) (fn () js_ast.Expr, fn (_ js_ast.Expr) js_ast.Expr) {
	mut wrap_func := fn (expr js_ast.Expr) {
		if expr.data == nil {
			return value
		}
		return expr
	}

	mut valueFunc := 0
	mut e := value.data
	match e {
		js_ast.ENull {
			value_func = fn () {
				return js_ast.Expr{
					loc:  loc
					data: js_ast.en_ull_shared
				}
			}
		}
		js_ast.EUndefined {
			value_func = fn () {
				return js_ast.Expr{
					loc:  loc
					data: js_ast.eu_ndefined_shared
				}
			}
		}
		js_ast.EThis {
			value_func = fn () {
				return js_ast.Expr{
					loc:  loc
					data: js_ast.et_his_shared
				}
			}
		}
		js_ast.EBoolean {
			value_func = fn () {
				return js_ast.Expr{
					loc:  loc
					data: &js_ast.EBoolean{
						value: e.value
					}
				}
			}
		}
		js_ast.ENumber {
			value_func = fn () {
				return js_ast.Expr{
					loc:  loc
					data: &js_ast.ENumber{
						value: e.value
					}
				}
			}
		}
		js_ast.EBigInt {
			value_func = fn () {
				return js_ast.Expr{
					loc:  loc
					data: &js_ast.EBigInt{
						value: e.value
					}
				}
			}
		}
		js_ast.EString {
			value_func = fn () {
				return js_ast.Expr{
					loc:  loc
					data: &js_ast.EString{
						value: e.value
					}
				}
			}
		}
		js_ast.EPrivateIdentifier {
			value_func = fn () {
				return js_ast.Expr{
					loc:  loc
					data: &js_ast.EPrivateIdentifier{
						ref: e.ref
					}
				}
			}
		}
		js_ast.EIdentifier {
			if mode == value_definitely_not_mutated {
				value_func = fn () {
					p.record_usage(e.ref)
					return js_ast.Expr{
						loc:  loc
						data: &js_ast.EIdentifier{
							ref: e.ref
						}
					}
				}
			}
		}
	}
	if value_func != nil {
		return value_func, wrap_func
	}
	if count < 2 {
		return fn () {
			return value
		}, wrap_func
	}
	mut temp_ref := ast.invalid_ref
	if p.current_scope.kind == js_ast.scope_function_args {
		return fn () {
			if temp_ref == ast.invalid_ref {
				temp_ref = p.generate_temp_ref(temp_ref_no_declare, '')
				p.record_usage(temp_ref)
				return js_ast.assign(js_ast.Expr{
					loc:  loc
					data: &js_ast.EIdentifier{
						ref: temp_ref
					}
				}, value)
			}
			p.record_usage(temp_ref)
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EIdentifier{
					ref: temp_ref
				}
			}
		}, fn (expr js_ast.Expr) {
			if expr.data == nil {
				return value
			}
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.ECall{
					target: js_ast.Expr{
						loc:  loc
						data: &js_ast.EArrow{
							args:        [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
							]
							prefer_expr: true
							body:        js_ast.FnBody{
								loc:   loc
								block: js_ast.SBlock{
									stmts: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
									]
								}
							}
						}
					}
				}
			}
		}
	}
	return fn () {
		if temp_ref == ast.invalid_ref {
			temp_ref = p.generate_temp_ref(temp_ref_needs_declare, '')
			p.record_usage(temp_ref)
			return js_ast.assign(js_ast.Expr{
				loc:  loc
				data: &js_ast.EIdentifier{
					ref: temp_ref
				}
			}, value)
		}
		p.record_usage(temp_ref)
		return js_ast.Expr{
			loc:  loc
			data: &js_ast.EIdentifier{
				ref: temp_ref
			}
		}
	}, wrap_func
}

fn (p &Parser) visit_decorators(decorators []js_ast.Decorator, decorator_scope &js_ast.Scope) []js_ast.Decorator {
	if decorators != nil {
		mut old_scope := p.current_scope
		p.current_scope = decorator_scope
		for i, decorator in decorators {
			decorators[i].value = p.visit_expr(decorator.value)
		}
		p.current_scope = old_scope
	}
	return decorators
}

struct visitClassResult {
pub mut:
	body_scope           &js_ast.Scope = unsafe { nil }
	inner_class_name_ref ast.Ref
	super_ctor_ref       ast.Ref
	// If true, the class was determined to be safe to remove if the class is
	// never used (i.e. the class definition is side-effect free). This is
	// determined after visiting but before lowering since lowering may generate
	// class mutations that cannot be automatically analyzed as side-effect free.
	can_be_removed_if_unused bool
}

fn (p &Parser) visit_class(name_scope_loc logger.Loc, class &js_ast.Class, default_name_ref ast.Ref, name_to_keep string) visitClassResult {
	class.decorators = p.visit_decorators(class.decorators, p.current_scope)
	if class.name != nil {
		p.record_declared_symbol(class.name.ref)
		if p.options.keep_names {
			name_to_keep = p.symbols[class.name.ref.inner_index].original_name
		}
	}
	mut class_lowering_info := p.compute_class_lowering_info(class)
	mut recompute_class_lowering_info := false
	if class_lowering_info.lower_all_static_fields {
		for _, prop in class.properties {
			mut private, ok := prop.key.data
			if ok {
				p.symbols[private.ref.inner_index].flags |= ast.private_symbol_must_be_lowered
				recompute_class_lowering_info = true
			}
		}
	}
	if p.lower_all_of_these_private_names != nil {
		for _, prop_1 in class.properties {
			mut private_1, ok_1 := prop.key.data
			if ok {
				mut symbol := &p.symbols[private.ref.inner_index]
				if p.lower_all_of_these_private_names[symbol.original_name] {
					symbol.flags |= ast.private_symbol_must_be_lowered
					recompute_class_lowering_info = true
				}
			}
		}
	}
	if recompute_class_lowering_info {
		class_lowering_info = p.compute_class_lowering_info(class)
	}
	p.push_scope_for_visit_pass(js_ast.scope_class_name, name_scope_loc)
	mut old_enclosing_class_keyword := p.enclosing_class_keyword
	p.enclosing_class_keyword = class.class_keyword
	p.current_scope.recursive_set_strict_mode(js_ast.implicit_strict_mode_class)
	if class.name != nil {
		p.validate_declared_symbol_name(class.name.loc, p.symbols[class.name.ref.inner_index].original_name)
	}
	result.super_ctor_ref = ast.invalid_ref
	if class_lowering_info.shim_super_ctor_calls {
		result.super_ctor_ref = p.new_symbol(ast.symbol_other, '__super')
		p.current_scope.generated << result.super_ctor_ref
		p.record_declared_symbol(result.super_ctor_ref)
	}
	mut old_super_ctor_ref := p.super_ctor_ref
	p.super_ctor_ref = result.super_ctor_ref
	if class.name != nil {
		mut name := p.symbols[class.name.ref.inner_index].original_name
		result.inner_class_name_ref = p.new_symbol(ast.symbol_const, '_' + name)
		p.current_scope.members[name] = js_ast.ScopeMember{
			loc: class.name.loc
			ref: result.inner_class_name_ref
		}
	} else {
		mut name_1 := '_this'
		if default_name_ref != ast.invalid_ref {
			name = '_' + p.source.identifier_name + '_default'
		}
		result.inner_class_name_ref = p.new_symbol(ast.symbol_const, name)
	}
	p.record_declared_symbol(result.inner_class_name_ref)
	if class.extends_or_nil.data != nil {
		class.extends_or_nil = p.visit_expr(class.extends_or_nil)
	}
	p.push_scope_for_visit_pass(js_ast.scope_class_body, class.body_loc)
	result.body_scope = p.current_scope
	for i, _ in class.properties {
		mut property := &class.properties[i]
		if property.kind == js_ast.property_class_static_block {
			mut old_fn_or_arrow_data := p.fn_or_arrow_data_visit
			mut old_fn_only_data_visit := p.fn_only_data_visit
			p.fn_or_arrow_data_visit = FnOrArrowDataVisit{}
			p.fn_only_data_visit = FnOnlyDataVisit{
				is_this_nested:             true
				is_new_target_allowed:      true
				is_in_static_class_context: true
				inner_class_name_ref:       &result.inner_class_name_ref
			}
			if class_lowering_info.lower_all_static_fields {
				p.fn_only_data_visit.should_replace_this_with_inner_class_name_ref = true
				p.fn_or_arrow_data_visit.should_lower_super_property_access = true
			}
			p.push_scope_for_visit_pass(js_ast.scope_class_static_init, property.class_static_block.loc)
			p.current_scope.forbid_arguments = true
			property.class_static_block.block.stmts = p.visit_stmts(property.class_static_block.block.stmts,
				stmts_fn_body)
			p.pop_scope()
			p.fn_or_arrow_data_visit = old_fn_or_arrow_data
			p.fn_only_data_visit = old_fn_only_data_visit
			continue
		}
		property.decorators = p.visit_decorators(property.decorators, result.body_scope)
		mut private_2, ok_2 := property.key.data
		if ok {
			p.record_declared_symbol(private.ref)
		}
		else {
			if property.flags.has(js_ast.property_is_computed) && class.name != nil {
				p.symbols[result.inner_class_name_ref.inner_index].kind = ast.symbol_class_in_computed_property_key
			}
			mut key, _ := p.visit_expr_in_out(property.key, ExprIn{
				should_mangle_strings_as_props: true
			})
			property.key = key
			if property.flags.has(js_ast.property_is_computed) && class.name != nil {
				p.symbols[result.inner_class_name_ref.inner_index].kind = ast.symbol_const
			}
			if p.options.minify_syntax {
				mut inlined, ok_3 := key.data
				if ok {
					// append no rhs

					// lhs.len==0
				}
				mut k := key.data
				match k {
					js_ast.ENumber, js_ast.ENameOfSymbol {
						property.flags &= ~js_ast.property_is_computed
					}
					js_ast.EString {
						mut number_value, ok_4 := js_ast.string_to_equivalent_number_value(k.value)
						if ok && number_value >= 0 {
							property.key.data = &js_ast.ENumber{
								value: number_value
							}
							property.flags &= ~js_ast.property_is_computed
						} else if property.flags.has(js_ast.property_is_computed) {
							mut is_invalid_constructor := false
							if helpers.utf_16_equals_string(k.value, 'constructor') {
								if !property.kind.is_method_definition() {
									is_invalid_constructor = true
								} else if !property.flags.has(js_ast.property_is_static) {
									is_invalid_constructor = true
								}
							}
							mut is_invalid_prototype := property.flags.has(js_ast.property_is_static) && helpers.utf_16_equals_string(k.value,
								'prototype')
							if !is_invalid_constructor && !is_invalid_prototype {
								property.flags &= ~js_ast.property_is_computed
							}
						}
					}
				}
			}
		}
		p.current_scope.forbid_arguments = true
		mut old_fn_only_data_visit_1 := p.fn_only_data_visit
		mut old_should_lower_super_property_access := p.fn_or_arrow_data_visit.should_lower_super_property_access
		p.fn_or_arrow_data_visit.should_lower_super_property_access = false
		p.fn_only_data_visit.should_replace_this_with_inner_class_name_ref = false
		p.fn_only_data_visit.is_this_nested = true
		p.fn_only_data_visit.is_new_target_allowed = true
		p.fn_only_data_visit.is_in_static_class_context = property.flags.has(js_ast.property_is_static)
		p.fn_only_data_visit.inner_class_name_ref = &result.inner_class_name_ref
		mut name_to_keep_1 := ''
		mut is_lowered_private_method := false
		mut private_3, ok_5 := property.key.data
		if ok {
			if !property.kind.is_method_definition()
				|| p.private_symbol_needs_to_be_lowered(private) {
				name_to_keep = p.symbols[private.ref.inner_index].original_name
			}
			if property.kind.is_method_definition() && p.private_symbol_needs_to_be_lowered(private) {
				is_lowered_private_method = true
			}
		} else if !property.kind.is_method_definition()
			&& !property.flags.has(js_ast.property_is_computed) {
			mut str, ok_6 := property.key.data
			if ok {
				name_to_keep = helpers.utf_16_to_string(str.value)
			}
		}
		if property.value_or_nil.data != nil {
			p.prop_method_decorator_scope = result.body_scope
			if name_to_keep != '' {
				p.name_to_keep = name_to_keep
				p.name_to_keep_is_for = property.value_or_nil.data
			}
			if class.extends_or_nil.data != nil && !property.flags.has(js_ast.property_is_computed) {
				mut str_1, ok_7 := property.key.data
				if ok && helpers.utf_16_equals_string(str.value, 'constructor') {
					p.prop_derived_ctor_value = property.value_or_nil.data
				}
			}
			property.value_or_nil, _ = p.visit_expr_in_out(property.value_or_nil, ExprIn{
				is_method:                 true
				is_lowered_private_method: is_lowered_private_method
			})
		}
		if property.initializer_or_nil.data != nil {
			if property.flags.has(js_ast.property_is_static) && class_lowering_info.lower_all_static_fields {
				p.fn_only_data_visit.should_replace_this_with_inner_class_name_ref = true
				p.fn_or_arrow_data_visit.should_lower_super_property_access = true
			}
			if name_to_keep != '' {
				p.name_to_keep = name_to_keep
				p.name_to_keep_is_for = property.initializer_or_nil.data
			}
			property.initializer_or_nil = p.visit_expr(property.initializer_or_nil)
		}
		p.fn_only_data_visit = old_fn_only_data_visit
		p.fn_or_arrow_data_visit.should_lower_super_property_access = old_should_lower_super_property_access
		p.current_scope.forbid_arguments = false
	}
	if !p.suppress_warnings_about_weird_code {
		p.warn_about_duplicate_properties(class.properties, duplicate_properties_in_class)
	}
	result.can_be_removed_if_unused = p.ast_helpers.class_can_be_removed_if_unused(&class)
	if p.options.keep_names && name_to_keep != '' {
		mut property_prevents_keep_names := false
		for _, prop_2 in class.properties {
			if prop.flags.has(js_ast.property_is_static) {
				mut str_2, ok_8 := prop.key.data
				if ok && helpers.utf_16_equals_string(str.value, 'name') {
					property_prevents_keep_names = true
					break
				}
			}
		}
		if !property_prevents_keep_names {
			mut this := 0
			if class_lowering_info.lower_all_static_fields {
				p.record_usage(result.inner_class_name_ref)
				this = js_ast.Expr{
					loc:  class.body_loc
					data: &js_ast.EIdentifier{
						ref: result.inner_class_name_ref
					}
				}
			} else {
				this = js_ast.Expr{
					loc:  class.body_loc
					data: js_ast.et_his_shared
				}
			}
			mut properties := []js_ast.Property{len: 0, cap: 1 + class.properties.len}
			properties << js_ast.Property{
				kind:               js_ast.property_class_static_block
				class_static_block: &js_ast.ClassStaticBlock{
					loc:   class.body_loc
					block: js_ast.SBlock{
						stmts: [
							p.keep_class_or_fn_symbol_name(class.body_loc, this, name_to_keep),
						]
					}
				}
			}
			class.properties << class.properties
		}
	}
	p.enclosing_class_keyword = old_enclosing_class_keyword
	p.super_ctor_ref = old_super_ctor_ref
	p.pop_scope()
	if p.symbols[result.inner_class_name_ref.inner_index].use_count_estimate == 0 {
		result.inner_class_name_ref = ast.invalid_ref
	} else if class.name == nil {
		mut class_name_ref := default_name_ref
		if class_name_ref == ast.invalid_ref {
			class_name_ref = p.new_symbol(ast.symbol_other, '_this')
			p.current_scope.generated << class_name_ref
			p.record_declared_symbol(class_name_ref)
		}
		class.name = &ast.LocRef{
			loc: name_scope_loc
			ref: class_name_ref
		}
	}
	p.pop_scope()
	if class_lowering_info != p.compute_class_lowering_info(class) {
		panic('Internal error')
	}
	return
}

fn is_simple_parameter_list(args []js_ast.Arg, has_rest_arg bool) bool {
	if has_rest_arg {
		return false
	}
	for _, arg in args {
		_, ok := arg.binding.data
		if !ok || arg.default_or_nil.data != nil {
			return false
		}
	}
	return true
}

fn fn_body_contains_use_strict(body []js_ast.Stmt) (logger.Loc, bool) {
	for _, stmt in body {
		mut s := stmt.data
		match s {
			js_ast.SComment {
				continue
			}
			js_ast.SDirective {
				if helpers.utf_16_equals_string(s.value, 'use strict') {
					return stmt.loc, true
				}
			}
			else {
				return logger.Loc{}, false
			}
		}
	}
	return logger.Loc{}, false
}

struct visitArgsOpts {
pub mut:
	body            []js_ast.Stmt
	decorator_scope &js_ast.Scope = unsafe { nil }
	has_rest_arg    bool
	// This is true if the function is an arrow function or a method
	is_unique_formal_parameters bool
}

fn (p &Parser) visit_args(args []js_ast.Arg, opts visitArgsOpts) {
	mut duplicateArgCheck := map[string]logger.Range{}
	mut use_strict_loc, has_use_strict := fn_body_contains_use_strict(opts.body)
	mut has_simple_args := is_simple_parameter_list(args, opts.has_rest_arg)
	if has_use_strict && !has_simple_args {
		p.log.add_error(&p.tracker, p.source.range_of_string(use_strict_loc), 'Cannot use a "use strict" directive in a function with a non-simple parameter list')
	}
	if opts.is_unique_formal_parameters || has_use_strict || !has_simple_args || p.is_strict_mode() {
		duplicate_arg_check = map[string]logger.Range{}
	}
	for i, _ in args {
		mut arg := &args[i]
		arg.decorators = p.visit_decorators(arg.decorators, opts.decorator_scope)
		p.visit_binding(arg.binding, BindingOpts{
			duplicate_arg_check: duplicate_arg_check
		})
		if arg.default_or_nil.data != nil {
			arg.default_or_nil = p.visit_expr(arg.default_or_nil)
		}
	}
}

fn (p &Parser) is_dot_or_index_define_match(expr js_ast.Expr, parts []string) bool {
	mut e := expr.data
	match e {
		js_ast.EDot {
			if parts.len > 1 {
				mut last := parts.len - 1
				return parts[last] == e.name && p.is_dot_or_index_define_match(e.target,
					parts[..last])
			}
		}
		js_ast.EIndex {
			if parts.len > 1 {
				mut str, ok := e.index.data
				if ok {
					mut last_1 := parts.len - 1
					return parts[last] == helpers.utf_16_to_string(str.value) && p.is_dot_or_index_define_match(e.target,
						parts[..last])
				}
			}
		}
		js_ast.EThis {
			if !p.fn_only_data_visit.is_this_nested {
				return parts.len == 1 && parts[0] == 'this'
			}
		}
		js_ast.EImportMeta {
			return parts.len == 2 && parts[0] == 'import' && parts[1] == 'meta'
		}
		js_ast.EIdentifier {
			if parts.len == 1 {
				mut name := p.load_name_from_ref(e.ref)
				if name != parts[0] {
					return false
				}
				mut result := p.find_symbol(expr.loc, name)
				p.ignore_usage(result.ref)
				if result.is_inside_with_scope {
					return false
				}
				return p.symbols[result.ref.inner_index].kind.is_unbound_or_injected()
			}
		}
	}
	return false
}

fn (p &Parser) instantiate_define_expr(loc logger.Loc, expr config.DefineExpr, opts identifierOpts) js_ast.Expr {
	if expr.constant != nil {
		return js_ast.Expr{
			loc:  loc
			data: expr.constant
		}
	}
	if expr.injected_define_index.is_valid() {
		mut ref := p.injected_define_symbols[expr.injected_define_index.get_index()]
		p.record_usage(ref)
		return js_ast.Expr{
			loc:  loc
			data: &js_ast.EIdentifier{
				ref: ref
			}
		}
	}
	mut parts := expr.parts
	if parts.len == 0 {
		return js_ast.Expr{}
	}
	if opts.match_against_defines {
		opts.match_against_defines = false
		mut defines, ok := p.options.defines.dot_defines[parts[parts.len - 1]]
		if ok {
			for _, define in defines {
				if define.data.define_expr != nil && helpers.string_arrays_equal(define.parts,
					parts) {
					return p.instantiate_define_expr(loc, &define.data.define_expr, opts)
				}
			}
		}
	}
	mut names, ok_1 := p.injected_dot_names[parts[parts.len - 1]]
	if ok {
		for _, name in names {
			if helpers.string_arrays_equal(name.parts, parts) {
				return p.instantiate_inject_dot_name(loc, name, opts.assign_target)
			}
		}
	}
	mut value := 0
	mut first_part := parts[0]
	parts = parts[1..]
	match first_part {
		'NaN' {
			value = js_ast.Expr{
				loc:  loc
				data: &js_ast.ENumber{
					value: math.na_n()
				}
			}
		}
		'Infinity' {
			value = js_ast.Expr{
				loc:  loc
				data: &js_ast.ENumber{
					value: math.inf(1)
				}
			}
		}
		'null' {
			value = js_ast.Expr{
				loc:  loc
				data: js_ast.en_ull_shared
			}
		}
		'undefined' {
			value = js_ast.Expr{
				loc:  loc
				data: js_ast.eu_ndefined_shared
			}
		}
		'this' {
			mut this_value, ok_2 := p.value_for_this(loc, false, js_ast.assign_target_none,
				false, false)
			if ok {
				value = this_value
			} else {
				value = js_ast.Expr{
					loc:  loc
					data: js_ast.et_his_shared
				}
			}
		}
		else {
			if first_part == 'import' && parts.len > 0 && parts[0] == 'meta' {
				mut import_meta, ok_3 := p.value_for_import_meta(loc)
				if ok {
					value = import_meta
				} else {
					value = js_ast.Expr{
						loc:  loc
						data: &js_ast.EImportMeta{}
					}
				}
				parts = parts[1..]
				break
			}
			mut result := p.find_symbol(loc, first_part)
			value = p.handle_identifier(loc, &js_ast.EIdentifier{
				ref:                        result.ref
				must_keep_due_to_with_stmt: result.is_inside_with_scope
				can_be_removed_if_unused:   true
			}, opts)
		}
	}
	for _, part in parts {
		mut expr_1, ok_4 := p.maybe_rewrite_property_access(loc, js_ast.assign_target_none,
			false, value, part, loc, false, false, false)
		if ok {
			value = expr
		} else if p.is_mangled_prop(part) {
			value = js_ast.Expr{
				loc:  loc
				data: &js_ast.EIndex{
					target: value
					index:  js_ast.Expr{
						loc:  loc
						data: &js_ast.ENameOfSymbol{
							ref: p.symbol_for_mangled_prop(part)
						}
					}
				}
			}
		} else {
			value = js_ast.Expr{
				loc:  loc
				data: &js_ast.EDot{
					target:                   value
					name:                     part
					name_loc:                 loc
					can_be_removed_if_unused: true
				}
			}
		}
	}
	return value
}

fn (p &Parser) instantiate_inject_dot_name(loc logger.Loc, name injectedDotName, assign_target js_ast.AssignTarget) js_ast.Expr {
	mut ref := p.injected_define_symbols[name.injected_define_index]
	p.record_usage(ref)
	if assign_target != js_ast.assign_target_none {
		mut where, ok := p.injected_symbol_sources[ref]
		if ok {
			mut r := js_lexer.range_of_identifier(p.source, loc)
			mut tracker := logger.make_line_column_tracker(&where.source)
			mut joined := name.parts.join('.')
			p.log.add_error_with_notes(&p.tracker, r, strconv.v_sprintf("Cannot assign to %q because it's an import from an injected file",
				joined), [
				tracker.msg_data(js_lexer.range_of_identifier(where.source, where.loc),
					strconv.v_sprintf('The symbol %q was exported from %q here:', joined,
					where.source.pretty_path)),
			])
		}
	}
	return js_ast.Expr{
		loc:  loc
		data: &js_ast.EIdentifier{
			ref: ref
		}
	}
}

fn (p &Parser) check_for_unrepresentable_identifier(loc logger.Loc, name string) {
	if p.options.ascii_only && p.options.unsupported_jsf_eatures.has(compat.unicode_escapes) && helpers.contains_non_bmpc_ode_point(name) {
		if p.unrepresentable_identifiers == nil {
			p.unrepresentable_identifiers = map[string]Bool{}
		}
		if !p.unrepresentable_identifiers[name] {
			p.unrepresentable_identifiers[name] = true
			mut where := config.pretty_print_target_environment(p.options.original_target_env,
				p.options.unsupported_jsf_eature_overrides_mask)
			mut r := js_lexer.range_of_identifier(p.source, loc)
			p.log.add_error(&p.tracker, r, strconv.v_sprintf(
				'%q cannot be escaped in %s but you ' +
				'can set the charset to "utf8" to allow unescaped Unicode characters',
				name, where))
		}
	}
}

type typeofStringOrder = u8

enum typeofStringOrder {
	only_check_original_order
	check_both_orders
}

fn (p &Parser) warn_about_typeof_and_string(a js_ast.Expr, b js_ast.Expr, order typeofStringOrder) {
	if order == check_both_orders {
		_, ok := a.data
		if ok {
			a, b = b, a
		}
	}
}

fn (p &Parser) warn_about_equality_check(op string, value js_ast.Expr, after_op_loc logger.Loc) bool {
	mut e := value.data
	match e {
		js_ast.ENumber {
			if e.value == 0 && math.signbit(e.value) {
				mut r := logger.Range{
					loc: value.loc
					len: 0
				}
				if isize(r.loc.start) < p.source.contents.len && p.source.contents[r.loc.start] == `-` {
					mut zero_range := p.source.range_of_number(logger.Loc{
						start: r.loc.start + 1
					})
					r.len = zero_range.len + 1
				}
				mut text := strconv.v_sprintf('Comparison with -0 using the %q operator will also match 0',
					op)
				if op == 'case' {
					text = 'Comparison with -0 using a case clause will also match 0'
				}
				mut kind := logger.warning
				if p.suppress_warnings_about_weird_code {
					kind = logger.debug
				}
				p.log.add_idw_ith_notes(logger.msg_id_js_equals_negative_zero, kind, &p.tracker,
					r, text, [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				])
				return true
			}
			if math.is_na_n(e.value) {
				mut text_1 := strconv.v_sprintf('Comparison with NaN using the %q operator here is always %v',
					op, op[0] == `!`)
				if op == 'case' {
					text = 'This case clause will never be evaluated because equality with NaN is always false'
				}
				mut r_1 := p.source.range_of_operator_before(after_op_loc, op)
				mut kind_1 := logger.warning
				if p.suppress_warnings_about_weird_code {
					kind = logger.debug
				}
				p.log.add_idw_ith_notes(logger.msg_id_js_equals_na_n, kind, &p.tracker,
					r, text, [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				])
				return true
			}
		}
		js_ast.EArray, js_ast.EArrow, js_ast.EClass, js_ast.EFunction, js_ast.EObject,
		js_ast.ERegExp {
			if op.len > 2 {
				mut text_2 := strconv.v_sprintf('Comparison using the %q operator here is always %v',
					op, op[0] == `!`)
				if op == 'case' {
					text = 'This case clause will never be evaluated because the comparison is always false'
				}
				mut r_2 := p.source.range_of_operator_before(after_op_loc, op)
				mut kind_2 := logger.warning
				if p.suppress_warnings_about_weird_code {
					kind = logger.debug
				}
				p.log.add_idw_ith_notes(logger.msg_id_js_equals_new_object, kind, &p.tracker,
					r, text, [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				])
				return true
			}
		}
	}
	return false
}

// EDot nodes represent a property access. This function may return an
// expression to replace the property access with. It assumes that the
// target of the EDot expression has already been visited.
fn (p &Parser) maybe_rewrite_property_access(loc logger.Loc, assign_target js_ast.AssignTarget, is_delete_target bool, target js_ast.Expr, name string, name_loc logger.Loc, is_call_target bool, is_template_tag bool, prefer_quoted_key bool) (js_ast.Expr, bool) {
	mut id, ok := target.data
	if ok {
		if p.options.mode == config.mode_bundle {
			mut import_items, ok_1 := p.import_items_for_namespace[id.ref]
			if ok {
				mut item, ok_2 := import_items.entries[name]
				if !ok {
					mut record := &p.import_records[import_items.import_record_index]
					if (record.flags & ast.assert_type_json) != 0 && name != 'default' {
						mut kind := logger.warning
						if p.suppress_warnings_about_weird_code {
							kind = logger.debug
						}
						p.log.add_idw_ith_notes(logger.msg_id_js_assert_type_json, kind,
							&p.tracker, js_lexer.range_of_identifier(p.source, name_loc),
							strconv.v_sprintf('Non-default import %q is undefined with a JSON import assertion',
							name), p.notes_for_assert_type_json(record, name))
						p.ignore_usage(id.ref)
						return js_ast.Expr{
							loc:  loc
							data: js_ast.eu_ndefined_shared
						}, true
					}
					item = ast.LocRef{
						loc: name_loc
						ref: p.new_symbol(ast.symbol_import, name)
					}
					p.module_scope.generated << item.ref
					import_items.entries[name] = item
					p.is_import_item[item.ref] = true
					mut symbol := &p.symbols[item.ref.inner_index]
					if p.options.mode == config.mode_pass_through {
						symbol.namespace_alias = &ast.NamespaceAlias{
							namespace_ref: id.ref
							alias:         name
						}
					} else {
						symbol.import_item_status = ast.import_item_generated
					}
				}
				p.ignore_usage(id.ref)
				p.record_usage(item.ref)
				return p.handle_identifier(name_loc, &js_ast.EIdentifier{
					ref: item.ref
				}, IdentifierOpts{
					assign_target:             assign_target
					is_call_target:            is_call_target
					is_delete_target:          is_delete_target
					prefer_quoted_key:         prefer_quoted_key
					was_originally_identifier: false
				}), true
			}
			if is_call_target && id.ref == p.module_ref && name == 'require' {
				p.ignore_usage(p.module_ref)
				p.record_usage(p.require_ref)
				return js_ast.Expr{
					loc:  name_loc
					data: &js_ast.EIdentifier{
						ref: p.require_ref
					}
				}, true
			}
		}
	}
	if !is_call_target && !is_template_tag && p.options.minify_syntax
		&& assign_target == js_ast.assign_target_none {
		mut object, ok_3 := target.data
		if ok {
			mut replace := 0
			mut has_proto_null := false
			mut is_unsafe := false
			for _, prop in object.properties {
				if prop.kind == js_ast.property_spread
					|| prop.flags.has(js_ast.property_is_computed)
					|| prop.kind.is_method_definition() {
					is_unsafe = true
					break
				}
				mut key, ok_4 := prop.key.data
				if !ok {
					is_unsafe = true
					break
				}
				if helpers.utf_16_equals_string(key.value, '__proto__') {
					_, ok_5 := prop.value_or_nil.data
					if ok {
						has_proto_null = true
					}
				}
				if !p.ast_helpers.expr_can_be_removed_if_unused(prop.value_or_nil) {
					is_unsafe = true
					break
				}
				if helpers.utf_16_equals_string(key.value, name) {
					replace = prop.value_or_nil
				}
			}
			if !is_unsafe {
				if replace.data != nil && name != '__proto__' {
					return replace, true
				}
				if has_proto_null {
					return js_ast.Expr{
						loc:  target.loc
						data: js_ast.eu_ndefined_shared
					}, true
				}
			}
		}
	}
	if target.data == p.ts_namespace_target && assign_target == js_ast.assign_target_none
		&& !is_delete_target {
		mut ns, ok_6 := p.ts_namespace_member_data
		if ok {
			mut member, ok_7 := ns.exported_members[name]
			if ok {
				mut m := member.data
				match m {
					js_ast.TSNamespaceMemberEnumNumber {
						p.ignore_usage_of_identifier_in_dot_chain(target)
						return p.wrap_inlined_enum(js_ast.Expr{
							loc:  loc
							data: &js_ast.ENumber{
								value: m.value
							}
						}, name), true
					}
					js_ast.TSNamespaceMemberEnumString {
						p.ignore_usage_of_identifier_in_dot_chain(target)
						return p.wrap_inlined_enum(js_ast.Expr{
							loc:  loc
							data: &js_ast.EString{
								value: m.value
							}
						}, name), true
					}
					js_ast.TSNamespaceMemberNamespace {
						if prefer_quoted_key || !js_ast.is_identifier(name) {
							p.ts_namespace_target = &js_ast.EIndex{
								target: target
								index:  js_ast.Expr{
									loc:  name_loc
									data: &js_ast.EString{
										value: helpers.string_to_utf_16(name)
									}
								}
							}
						} else {
							p.ts_namespace_target = p.dot_or_mangled_prop_visit(target,
								name, name_loc)
						}
						p.ts_namespace_member_data = member.data
						return js_ast.Expr{
							loc:  loc
							data: p.ts_namespace_target
						}, true
					}
				}
			}
		}
	}
	if p.options.mode == config.mode_bundle && !p.is_control_flow_dead {
		mut id_1, ok_8 := target.data
		if ok {
			mut use := p.symbol_uses[id.ref]
			use.count_estimate--
			if use.count_estimate == 0 {
				p.symbol_uses.delete(id.ref)
			} else {
				p.symbol_uses[id.ref] = use
			}
			if p.import_symbol_property_uses == nil {
				p.import_symbol_property_uses = map[ast.Ref]map[string]js_ast.SymbolUse{}
			}
			mut properties := p.import_symbol_property_uses[id.ref]
			if properties == nil {
				properties = map[string]js_ast.SymbolUse{}
				p.import_symbol_property_uses[id.ref] = properties
			}
			use = properties[name]
			use.count_estimate++
			properties[name] = use
		}
	}
	if p.options.minify_syntax && assign_target == js_ast.assign_target_none {
		mut t := target.data
		match t {
			js_ast.EString {
				if name == 'length' {
					return js_ast.Expr{
						loc:  loc
						data: &js_ast.ENumber{
							value: f64(t.value.len)
						}
					}, true
				}
			}
			js_ast.EInlinedEnum {
				mut s, ok_9 := t.value.data
				if ok && name == 'length' {
					return js_ast.Expr{
						loc:  loc
						data: &js_ast.ENumber{
							value: f64(s.value.len)
						}
					}, true
				}
			}
		}
	}
	return js_ast.Expr{}, false
}

struct exprIn {
pub mut:
	is_method                 bool
	is_lowered_private_method bool
	// This tells us if there are optional chain expressions (EDot, EIndex, or
	// ECall) that are chained on to this expression. Because of the way the AST
	// works, chaining expressions on to this expression means they are our
	// parent expressions.
	//
	// Some examples:
	//
	//   a?.b.c  // EDot
	//   a?.b[c] // EIndex
	//   a?.b()  // ECall
	//
	// Note that this is false if our parent is a node with a OptionalChain
	// value of OptionalChainStart. That means it's the start of a new chain, so
	// it's not considered part of this one.
	//
	// Some examples:
	//
	//   a?.b?.c   // EDot
	//   a?.b?.[c] // EIndex
	//   a?.b?.()  // ECall
	//
	// Also note that this is false if our parent is a node with a OptionalChain
	// value of OptionalChainNone. That means it's outside parentheses, which
	// means it's no longer part of the chain.
	//
	// Some examples:
	//
	//   (a?.b).c  // EDot
	//   (a?.b)[c] // EIndex
	//   (a?.b)()  // ECall
	//
	has_chain_parent bool
	// If our parent is an ECall node with an OptionalChain value of
	// OptionalChainStart, then we will need to store the value for the "this" of
	// that call somewhere if the current expression is an optional chain that
	// ends in a property access. That's because the value for "this" will be
	// used twice: once for the inner optional chain and once for the outer
	// optional chain.
	//
	// Example:
	//
	//   // Original
	//   a?.b?.();
	//
	//   // Lowered
	//   var _a;
	//   (_a = a == null ? void 0 : a.b) == null ? void 0 : _a.call(a);
	//
	// In the example above we need to store "a" as the value for "this" so we
	// can substitute it back in when we call "_a" if "_a" is indeed present.
	// See also "thisArgFunc" and "thisArgWrapFunc" in "exprOut".
	store_this_arg_for_parent_optional_chain bool
	// If true, string literals that match the current property mangling pattern
	// should be turned into ENameOfSymbol expressions, which will cause us to
	// rename them in the linker.
	should_mangle_strings_as_props bool
	// Certain substitutions of identifiers are disallowed for assignment targets.
	// For example, we shouldn't transform "undefined = 1" into "void 0 = 1". This
	// isn't something real-world code would do but it matters for conformance
	// tests.
	assign_target js_ast.AssignTarget
}

struct exprOut {
pub mut:
	// If our parent is an ECall node with an OptionalChain value of
	// OptionalChainContinue, then we may need to return the value for "this"
	// from this node or one of this node's children so that the parent that is
	// the end of the optional chain can use it.
	//
	// Example:
	//
	//   // Original
	//   a?.b?.().c();
	//
	//   // Lowered
	//   var _a;
	//   (_a = a == null ? void 0 : a.b) == null ? void 0 : _a.call(a).c();
	//
	// The value "_a" for "this" must be passed all the way up to the call to
	// ".c()" which is where the optional chain is lowered. From there it must
	// be substituted as the value for "this" in the call to ".b?.()". See also
	// "storeThisArgForParentOptionalChain" in "exprIn".
	this_arg_func      fn () js_ast.Expr              = unsafe { nil }
	this_arg_wrap_func fn (_ js_ast.Expr) js_ast.Expr = unsafe { nil }
	// True if the child node is an optional chain node (EDot, EIndex, or ECall
	// with an IsOptionalChain value of true)
	child_contains_optional_chain bool
	// If true and this is used as a call target, the whole call expression
	// must be replaced with undefined.
	method_call_must_be_replaced_with_undefined bool
}

fn (p &Parser) visit_expr(expr js_ast.Expr) js_ast.Expr {
	expr, _ = p.visit_expr_in_out(expr, ExprIn{})
	return expr
}

fn (p &Parser) value_for_this(loc logger.Loc, should_log bool, assign_target js_ast.AssignTarget, is_call_target bool, is_delete_target bool) (js_ast.Expr, bool) {
	if p.fn_only_data_visit.should_replace_this_with_inner_class_name_ref {
		p.record_usage(&p.fn_only_data_visit.inner_class_name_ref)
		return js_ast.Expr{
			loc:  loc
			data: &js_ast.EIdentifier{
				ref: &p.fn_only_data_visit.inner_class_name_ref
			}
		}, true
	}
	if !p.fn_only_data_visit.is_this_nested {
		mut data, ok := p.options.defines.identifier_defines['this']
		if ok {
			if data.define_expr != nil {
				return p.instantiate_define_expr(loc, &data.define_expr, IdentifierOpts{
					assign_target:    assign_target
					is_call_target:   is_call_target
					is_delete_target: is_delete_target
				}), true
			}
		}
		if p.is_file_considered_to_have_esme_xports {
			if should_log && !p.message_about_this_is_undefined
				&& !p.fn_only_data_visit.silence_message_about_this_being_undefined {
				p.message_about_this_is_undefined = true
				mut kind := logger.debug
				mut data_1 := p.tracker.msg_data(js_lexer.range_of_identifier(p.source,
					loc), 'Top-level "this" will be replaced with undefined since this file is an ECMAScript module')
				data.location.suggestion = 'undefined'
				_, notes := p.why_esm_odule()
				p.log.add_msg_id(logger.msg_id_js_this_is_undefined_in_esm, logger.Msg{
					kind:  kind
					data:  data
					notes: notes
				})
			}
			return js_ast.Expr{
				loc:  loc
				data: js_ast.eu_ndefined_shared
			}, true
		} else if p.options.mode != config.mode_pass_through {
			p.record_usage(p.exports_ref)
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EIdentifier{
					ref: p.exports_ref
				}
			}, true
		}
	}
	return js_ast.Expr{}, false
}

fn (p &Parser) value_for_import_meta(loc logger.Loc) (js_ast.Expr, bool) {
	if p.options.unsupported_jsf_eatures.has(compat.import_meta)
		|| (p.options.mode != config.mode_pass_through
		&& !p.options.output_format.keep_esmi_mport_export_syntax()) {
		if p.import_meta_ref == ast.invalid_ref {
			p.import_meta_ref = p.new_symbol(ast.symbol_other, 'import_meta')
			p.module_scope.generated << p.import_meta_ref
		}
		p.record_usage(p.import_meta_ref)
		return js_ast.Expr{
			loc:  loc
			data: &js_ast.EIdentifier{
				ref: p.import_meta_ref
			}
		}, true
	}
	return js_ast.Expr{}, false
}

fn loc_after_op(e &js_ast.EBinary) logger.Loc {
	if e.left.loc.start < e.right.loc.start {
		return e.right.loc
	} else {
		return e.left.loc
	}
}

// This function exists to tie all of these checks together in one place
fn is_eval_or_arguments(name string) bool {
	return name == 'eval' || name == 'arguments'
}

fn (p &Parser) report_private_name_usage(name string) {
	if p.parse_experimental_decorator_nesting > 0 {
		if p.lower_all_of_these_private_names == nil {
			p.lower_all_of_these_private_names = map[string]Bool{}
		}
		p.lower_all_of_these_private_names[name] = true
	}
}

fn (p &Parser) is_valid_assignment_target(expr js_ast.Expr) bool {
	mut e := expr.data
	match e {
		js_ast.EIdentifier {
			if p.is_strict_mode() {
				mut name := p.load_name_from_ref(e.ref)
				if is_eval_or_arguments(name) {
					return false
				}
			}
			return true
		}
		js_ast.EDot {
			return e.optional_chain == js_ast.optional_chain_none
		}
		js_ast.EIndex {
			return e.optional_chain == js_ast.optional_chain_none
		}
		js_ast.EObject {
			return !e.is_parenthesized
		}
		js_ast.EArray {
			return !e.is_parenthesized
		}
	}
	return false
}

fn contains_closing_script_tag(text string) bool {
	for {
		mut i := text.index('</')
		if i < 0 {
			break
		}
		text = text[i + 2..]
		if text.len >= 6 && text[..6].equal_fold('script') {
			return true
		}
	}
	return false
}

fn (p &Parser) is_unsupported_regular_expression(loc logger.Loc, value string) (string, string, bool) {
	mut what := 0
	mut r := 0
	mut end := value.last_index_byte(`/`)
	pattern = value[1..end]
	flags = value[end + 1..]
	mut is_unicode := flags.index_byte(`u`) >= 0
	mut paren_depth := isize(0)
	mut i := isize(0)
	mut i_1 := isize(0)
	if !is_unsupported {
		for i_2, c in flags {
			match c {
				`g`, `i`, `m` {
					continue
				}
				`s` {
					if !p.options.unsupported_jsf_eatures.has(compat.regexp_dot_all_flag) {
						continue
					}
				}
				`y`, `u` {
					if !p.options.unsupported_jsf_eatures.has(compat.regexp_sticky_and_unicode_flags) {
						continue
					}
				}
				`d` {
					if !p.options.unsupported_jsf_eatures.has(compat.regexp_match_indices) {
						continue
					}
				}
				`v` {
					if !p.options.unsupported_jsf_eatures.has(compat.regexp_set_notation) {
						continue
					}
				}
				else {}
			}
			r = logger.Range{
				loc: logger.Loc{
					start: loc.start + i32(end + 1) + i32(i)
				}
				len: 1
			}
			what = strconv.v_sprintf('The regular expression flag "%c" is not available',
				c)
			is_unsupported = true
			break
		}
	}
	if is_unsupported {
		mut where := config.pretty_print_target_environment(p.options.original_target_env,
			p.options.unsupported_jsf_eature_overrides_mask)
		p.log.add_idw_ith_notes(logger.msg_id_js_unsupported_reg_exp, logger.debug, &p.tracker,
			r, strconv.v_sprintf('%s in %s', what, where), [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
		])
	}
	return
}

// This function takes "exprIn" as input from the caller and produces "exprOut"
// for the caller to pass along extra data. This is mostly for optional chaining.
fn (p &Parser) visit_expr_in_out(expr js_ast.Expr, in_ exprIn) (js_ast.Expr, exprOut) {
	if in_.assign_target != js_ast.assign_target_none && !p.is_valid_assignment_target(expr) {
		p.log.add_error(&p.tracker, logger.Range{
			loc: expr.loc
		}, 'Invalid assignment target')
	}
	mut e := expr.data
	match e {
		js_ast.ENull, js_ast.ESuper, js_ast.EBoolean, js_ast.EBigInt, js_ast.EUndefined,
		js_ast.EJSXText {}
		js_ast.ENameOfSymbol {
			e.ref = p.symbol_for_mangled_prop(p.load_name_from_ref(e.ref))
		}
		js_ast.ERegExp {
			mut pattern, flags, ok := p.is_unsupported_regular_expression(expr.loc, e.value)
			if ok {
				mut args := [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				]
				if flags != '' {
					args << js_ast.Expr{
						loc:  logger.Loc{
							start: expr.loc.start + i32(pattern.len) + 2
						}
						data: &js_ast.EString{
							value: helpers.string_to_utf_16(flags)
						}
					}
				}
				mut reg_exp_ref := p.make_reg_exp_ref()
				p.record_usage(reg_exp_ref)
				return js_ast.Expr{
					loc:  expr.loc
					data: &js_ast.ENew{
						target:          js_ast.Expr{
							loc:  expr.loc
							data: &js_ast.EIdentifier{
								ref: reg_exp_ref
							}
						}
						args:            args
						close_paren_loc: logger.Loc{
							start: expr.loc.start + i32(e.value.len)
						}
					}
				}, ExprOut{}
			}
		}
		js_ast.ENewTarget {
			if !p.fn_only_data_visit.is_new_target_allowed {
				p.log.add_error(&p.tracker, e.range, 'Cannot use "new.target" here:')
			}
		}
		js_ast.EString {
			if e.legacy_octal_loc.start > 0 {
				if e.prefer_template {
					p.log.add_error(&p.tracker, p.source.range_of_legacy_octal_escape(e.legacy_octal_loc),
						'Legacy octal escape sequences cannot be used in template literals')
				} else if p.is_strict_mode() {
					p.mark_strict_mode_feature(legacy_octal_escape, p.source.range_of_legacy_octal_escape(e.legacy_octal_loc),
						'')
				}
			}
			if in_.should_mangle_strings_as_props && p.options.mangle_quoted && !e.prefer_template {
				mut name := helpers.utf_16_to_string(e.value)
				if p.is_mangled_prop(name) {
					return js_ast.Expr{
						loc:  expr.loc
						data: &js_ast.ENameOfSymbol{
							ref: p.symbol_for_mangled_prop(name)
						}
					}, ExprOut{}
				}
			}
		}
		js_ast.ENumber {
			if p.legacy_octal_literals != nil && p.is_strict_mode() {
				mut r, ok_1 := p.legacy_octal_literals[expr.data]
				if ok {
					p.mark_strict_mode_feature(legacy_octal_literal, r, '')
				}
			}
		}
		js_ast.EThis {
			mut is_delete_target := e == p.delete_target
			mut is_call_target := e == p.call_target
			mut value, ok_2 := p.value_for_this(expr.loc, true, in_.assign_target, is_delete_target,
				is_call_target)
			if ok {
				return value, ExprOut{}
			}
			if p.fn_or_arrow_data_visit.is_arrow && p.options.unsupported_jsf_eatures.has(compat.arrow) && p.fn_only_data_visit.is_this_nested {
				return js_ast.Expr{
					loc:  expr.loc
					data: &js_ast.EIdentifier{
						ref: p.capture_this()
					}
				}, ExprOut{}
			}
		}
		js_ast.EImportMeta {
			mut is_delete_target_1 := e == p.delete_target
			mut is_call_target_1 := e == p.call_target
			mut defines, ok_3 := p.options.defines.dot_defines['meta']
			if ok {
				for _, define in defines {
					if p.is_dot_or_index_define_match(expr, define.parts) {
						if define.data.define_expr != nil {
							return p.instantiate_define_expr(expr.loc, &define.data.define_expr,
								IdentifierOpts{
								assign_target:    in_.assign_target
								is_call_target:   is_call_target
								is_delete_target: is_delete_target
							}), ExprOut{}
						}
					}
				}
			}
			mut names, ok_4 := p.injected_dot_names['meta']
			if ok {
				for _, name_1 in names {
					if p.is_dot_or_index_define_match(expr, name.parts) {
						return p.instantiate_inject_dot_name(expr.loc, name, in_.assign_target), ExprOut{}
					}
				}
			}
			if p.options.unsupported_jsf_eatures.has(compat.import_meta) {
				mut r_1 := logger.Range{
					loc: expr.loc
					len: e.range_len
				}
				p.mark_syntax_feature(compat.import_meta, r)
			} else if p.options.mode != config.mode_pass_through
				&& !p.options.output_format.keep_esmi_mport_export_syntax() {
				mut r_2 := logger.Range{
					loc: expr.loc
					len: e.range_len
				}
				mut kind := logger.warning
				if p.suppress_warnings_about_weird_code
					|| p.fn_or_arrow_data_visit.try_body_count > 0 {
					kind = logger.debug
				}
				p.log.add_idw_ith_notes(logger.msg_id_js_empty_import_meta, kind, &p.tracker,
					r, strconv.v_sprintf('"import.meta" is not available with the %q output format and will be empty',
					p.options.output_format.string()), [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				])
			}
			mut import_meta, ok_5 := p.value_for_import_meta(expr.loc)
			if ok {
				return import_meta, ExprOut{}
			}
		}
		js_ast.ESpread {
			e.value = p.visit_expr(e.value)
		}
		js_ast.EIdentifier {
			mut is_call_target_2 := e == p.call_target
			mut is_delete_target_2 := e == p.delete_target
			mut name_2 := p.load_name_from_ref(e.ref)
			if p.is_strict_mode() && js_lexer.strict_mode_reserved_words[name] {
				p.mark_strict_mode_feature(reserved_word, js_lexer.range_of_identifier(p.source,
					expr.loc), name)
			}
			mut result := p.find_symbol(expr.loc, name)
			e.must_keep_due_to_with_stmt = result.is_inside_with_scope
			e.ref = result.ref
			if p.symbols[result.ref.inner_index].kind == ast.symbol_class_in_computed_property_key {
				p.log.add_id(logger.msg_id_js_class_name_will_throw, logger.warning, &p.tracker,
					js_lexer.range_of_identifier(p.source, expr.loc), strconv.v_sprintf('Accessing class %q before initialization will throw',
					name))
				return p.call_runtime(expr.loc, '__earlyAccess', [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				]), ExprOut{}
			}
			if in_.assign_target != js_ast.assign_target_none {
				match p.symbols[result.ref.inner_index].kind {
					ast.symbol_const {
						mut r_3 := js_lexer.range_of_identifier(p.source, expr.loc)
						mut notes := [
							p.tracker.msg_data(js_lexer.range_of_identifier(p.source,
								result.declare_loc), strconv.v_sprintf('The symbol %q was declared a constant here:',
								name)),
						]
						_, is_inlined_constant := p.const_values[result.ref]
						if is_inlined_constant
							|| p.options.mode == config.mode_bundle
							|| p.current_scope.parent == nil
							&& p.will_wrap_module_in_try_catch_for_using {
							p.log.add_error_with_notes(&p.tracker, r, strconv.v_sprintf('Cannot assign to %q because it is a constant',
								name), notes)
						} else {
							p.log.add_idw_ith_notes(logger.msg_id_js_assign_to_constant,
								logger.warning, &p.tracker, r, strconv.v_sprintf('This assignment will throw because %q is a constant',
								name), notes)
						}
					}
					ast.symbol_injected {
						mut where, ok_6 := p.injected_symbol_sources[result.ref]
						if ok {
							mut r_4 := js_lexer.range_of_identifier(p.source, expr.loc)
							mut tracker := logger.make_line_column_tracker(&where.source)
							p.log.add_error_with_notes(&p.tracker, r, strconv.v_sprintf("Cannot assign to %q because it's an import from an injected file",
								name), [
								tracker.msg_data(js_lexer.range_of_identifier(where.source,
									where.loc), strconv.v_sprintf('The symbol %q was exported from %q here:',
									name, where.source.pretty_path)),
							])
						}
					}
				}
			}
			mut method_call_must_be_replaced_with_undefined := false
			if p.symbols[e.ref.inner_index].kind.is_unbound_or_injected()
				&& !result.is_inside_with_scope && e != p.delete_target {
				mut data, ok_7 := p.options.defines.identifier_defines[name]
				if ok {
					if data.define_expr != nil {
						mut new := p.instantiate_define_expr(expr.loc, &data.define_expr,
							IdentifierOpts{
							assign_target:    in_.assign_target
							is_call_target:   is_call_target
							is_delete_target: is_delete_target
						})
						if in_.assign_target == js_ast.assign_target_none
							|| define_value_can_be_used_in_assign_target(new.data) {
							p.ignore_usage(e.ref)
							return new, ExprOut{}
						} else {
							p.log_assign_to_define(js_lexer.range_of_identifier(p.source,
								expr.loc), name, js_ast.Expr{})
						}
					}
					if data.flags.has(config.can_be_removed_if_unused) {
						e.can_be_removed_if_unused = true
					}
					if data.flags.has(config.call_can_be_unwrapped_if_unused)
						&& !p.options.ignore_dcea_nnotations {
						e.call_can_be_unwrapped_if_unused = true
					}
					if data.flags.has(config.method_calls_must_be_replaced_with_undefined) {
						method_call_must_be_replaced_with_undefined = true
					}
				}
			}
			return p.handle_identifier(expr.loc, e, IdentifierOpts{
				assign_target:             in_.assign_target
				is_call_target:            is_call_target
				is_delete_target:          is_delete_target
				was_originally_identifier: true
			}), ExprOut{
				method_call_must_be_replaced_with_undefined: method_call_must_be_replaced_with_undefined
			}
		}
		js_ast.EJSXElement {
			mut props_loc := expr.loc
			mut jsxSourceLine := 0
			mut jsxSourceColumn := 0
			if p.options.jsx.development && p.options.jsx.automatic_runtime {
				for p.jsx_source_loc < isize(props_loc.start) {
					mut r_5, size := utf8.decode_rune_in_string(p.source.contents[p.jsx_source_loc..])
					p.jsx_source_loc += size
					if r == `\n` || r == `\r` || r == `\u2028` || r == `\u2029` {
						if r == `\r` && p.jsx_source_loc < p.source.contents.len && p.source.contents[p.jsx_source_loc] == `\n` {
							p.jsx_source_loc++
						}
						p.jsx_source_line++
						p.jsx_source_column = isize(0)
					}
					else {
						if r < 0xFFFF {
							p.jsx_source_column++
						} else {
							p.jsx_source_column += isize(2)
						}
					}
				}
				jsx_source_line = p.jsx_source_line
				jsx_source_column = p.jsx_source_column
			}
			if e.tag_or_nil.data != nil {
				props_loc = e.tag_or_nil.loc
				e.tag_or_nil = p.visit_expr(e.tag_or_nil)
				p.warn_about_import_namespace_call(e.tag_or_nil, expr_kind_jsxt_ag)
			}
			mut has_spread := false
			for i, property in e.properties {
				if property.kind == js_ast.property_spread {
					has_spread = true
				}
				else {
					mut mangled, ok_8 := property.key.data
					if ok {
						mangled.ref = p.symbol_for_mangled_prop(p.load_name_from_ref(mangled.ref))
					} else {
						property.key = p.visit_expr(property.key)
					}
				}
				if property.value_or_nil.data != nil {
					property.value_or_nil = p.visit_expr(property.value_or_nil)
				}
				if property.initializer_or_nil.data != nil {
					property.initializer_or_nil = p.visit_expr(property.initializer_or_nil)
				}
				e.properties[i] = property
			}
			if p.options.minify_syntax && has_spread {
				e.properties = js_ast.mangle_object_spread(e.properties)
			}
			if e.nullable_children.len > 0 {
				for i_1, child_or_nil in e.nullable_children {
					if child_or_nil.data != nil {
						e.nullable_children[i] = p.visit_expr(child_or_nil)
					}
				}
			}
			if p.options.jsx.preserve {
				mut tag := e.tag_or_nil.data
				match tag {
					js_ast.EIdentifier {
						p.symbols[tag.ref.inner_index].flags |= ast.must_start_with_capital_letter_for_jsx
					}
					js_ast.EImportIdentifier {
						p.symbols[tag.ref.inner_index].flags |= ast.must_start_with_capital_letter_for_jsx
					}
				}
			} else {
				mut children := e.nullable_children
				{
					mut end := isize(0)
					for _, child_or_nil_1 in children {
						if child_or_nil.data != nil {
							children[end] = child_or_nil
							end++
						}
					}
					children = children[..end]
				}
				if e.tag_or_nil.data == nil {
					if p.options.jsx.automatic_runtime {
						e.tag_or_nil = p.import_jsxs_ymbol(expr.loc, jsxi_mport_fragment)
					} else {
						e.tag_or_nil = p.instantiate_define_expr(expr.loc, p.options.jsx.fragment,
							IdentifierOpts{
							was_originally_identifier: true
							match_against_defines:     true
						})
					}
				}
				mut should_use_create_element := !p.options.jsx.automatic_runtime
				if !should_use_create_element {
					mut seen_props_spread := false
					for _, property_1 in e.properties {
						if seen_props_spread && property.kind == js_ast.property_field {
							mut str, ok_9 := property.key.data
							if ok && helpers.utf_16_equals_string(str.value, 'key') {
								should_use_create_element = true
								break
							}
						} else if property.kind == js_ast.property_spread {
							seen_props_spread = true
						}
					}
				}
				if should_use_create_element {
					mut args_1 := [e.tag_or_nil]
					if e.properties.len > 0 {
						args << p.lower_object_spread(props_loc, &js_ast.EObject{
							properties:     e.properties
							is_single_line: e.is_tag_single_line
						})
					} else {
						args << js_ast.Expr{
							loc:  props_loc
							data: js_ast.en_ull_shared
						}
					}
					if children.len > 0 {
						args << children
					}
					mut target := 0
					mut kind_1 := js_ast.normal_call
					if p.options.jsx.automatic_runtime {
						target = p.import_jsxs_ymbol(expr.loc, jsxi_mport_create_element)
					} else {
						target = p.instantiate_define_expr(expr.loc, p.options.jsx.factory,
							IdentifierOpts{
							was_originally_identifier: true
							match_against_defines:     true
						})
						if js_ast.is_property_access(target) {
							kind = js_ast.target_was_originally_property_access
						}
						p.warn_about_import_namespace_call(target, expr_kind_call)
					}
					return js_ast.Expr{
						loc:  expr.loc
						data: &js_ast.ECall{
							target:                     target
							args:                       args
							close_paren_loc:            e.close_loc
							is_multi_line:              !e.is_tag_single_line
							kind:                       kind
							can_be_unwrapped_if_unused: !p.options.ignore_dcea_nnotations
								&& !p.options.jsx.side_effects
						}
					}, ExprOut{}
				} else {
					mut args_2 := [e.tag_or_nil]
					mut properties := []js_ast.Property{len: 0, cap: e.properties.len + 1}
					mut has_key := false
					mut key_property := js_ast.Expr{
						loc:  expr.loc
						data: js_ast.eu_ndefined_shared
					}
					for _, property_2 in e.properties {
						mut str_1, ok_10 := property.key.data
						if ok {
							mut prop_name := helpers.utf_16_to_string(str.value)
							match prop_name {
								'key' {
									mut boolean, ok_11 := property.value_or_nil.data
									if ok && boolean.value && property.flags.has(js_ast.property_was_shorthand) {
										mut r_6 := js_lexer.range_of_identifier(p.source,
											property.loc)
										mut msg := logger.Msg{
											kind:  logger.error
											data:  p.tracker.msg_data(r, 'Please provide an explicit value for "key":')
											notes: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
											]
										}
										msg.data.location.suggestion = 'key={true}'
										p.log.add_msg(msg)
									} else {
										key_property = property.value_or_nil
										has_key = true
									}
									continue
								}
								'__source', '__self' {
									mut r_7 := js_lexer.range_of_identifier(p.source,
										property.loc)
									p.log.add_error_with_notes(&p.tracker, r, strconv.v_sprintf('Duplicate "%s" prop found:',
										prop_name), [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
									])
									continue
								}
							}
						}
						properties << property
					}
					mut is_static_children := children.len > 1
					if children.len > 0 {
						mut children_value := children[0]
						if children.len > 1 {
							children_value.data = &js_ast.EArray{
								items: children
							}
						} else {
							// LOOL0
							_, ok_12 := children_value.data
							if ok {
								children_value.data = &js_ast.EArray{
									items: [children_value]
								}
								is_static_children = true
							}
						}
						properties << js_ast.Property{
							key:          js_ast.Expr{
								data: &js_ast.EString{
									value: helpers.string_to_utf_16('children')
								}
								loc:  children_value.loc
							}
							value_or_nil: children_value
							kind:         js_ast.property_field
							loc:          children_value.loc
						}
					}
					args << p.lower_object_spread(props_loc, &js_ast.EObject{
						properties:     properties
						is_single_line: e.is_tag_single_line
					})
					if has_key || p.options.jsx.development {
						args << key_property
					}
					if p.options.jsx.development {
						args << js_ast.Expr{
							loc:  expr.loc
							data: &js_ast.EBoolean{
								value: is_static_children
							}
						}
						args << js_ast.Expr{
							loc:  expr.loc
							data: &js_ast.EObject{
								properties: [
									js_ast.Property{
										kind:         js_ast.property_field
										key:          js_ast.Expr{
											loc:  expr.loc
											data: &js_ast.EString{
												value: helpers.string_to_utf_16('fileName')
											}
										}
										value_or_nil: js_ast.Expr{
											loc:  expr.loc
											data: &js_ast.EString{
												value: helpers.string_to_utf_16(p.source.pretty_path)
											}
										}
									},
									js_ast.Property{
										kind:         js_ast.property_field
										key:          js_ast.Expr{
											loc:  expr.loc
											data: &js_ast.EString{
												value: helpers.string_to_utf_16('lineNumber')
											}
										}
										value_or_nil: js_ast.Expr{
											loc:  expr.loc
											data: &js_ast.ENumber{
												value: f64(jsx_source_line + 1)
											}
										}
									},
									js_ast.Property{
										kind:         js_ast.property_field
										key:          js_ast.Expr{
											loc:  expr.loc
											data: &js_ast.EString{
												value: helpers.string_to_utf_16('columnNumber')
											}
										}
										value_or_nil: js_ast.Expr{
											loc:  expr.loc
											data: &js_ast.ENumber{
												value: f64(jsx_source_column + 1)
											}
										}
									},
								]
							}
						}
						mut __self := js_ast.Expr{
							loc:  expr.loc
							data: js_ast.et_his_shared
						}
						{
							if p.fn_only_data_visit.should_replace_this_with_inner_class_name_ref {
								p.record_usage(&p.fn_only_data_visit.inner_class_name_ref)
								__self.data = &js_ast.EIdentifier{
									ref: &p.fn_only_data_visit.inner_class_name_ref
								}
							} else if !p.fn_only_data_visit.is_this_nested && p.options.mode != config.mode_pass_through {
								__self.data = js_ast.eu_ndefined_shared
							} else if p.fn_or_arrow_data_visit.is_derived_class_ctor {
								__self.data = js_ast.eu_ndefined_shared
							}
						}
						_, ok_13 := __self.data
						if !ok {
							args << __self
						}
					}
					mut jsx := jsxi_mport_jsx
					if is_static_children {
						jsx = jsxi_mport_jsxs
					}
					return js_ast.Expr{
						loc:  expr.loc
						data: &js_ast.ECall{
							target:                     p.import_jsxs_ymbol(expr.loc,
								jsx)
							args:                       args
							close_paren_loc:            e.close_loc
							is_multi_line:              !e.is_tag_single_line
							can_be_unwrapped_if_unused: !p.options.ignore_dcea_nnotations
								&& !p.options.jsx.side_effects
						}
					}, ExprOut{}
				}
			}
		}
		js_ast.ETemplate {
			if e.legacy_octal_loc.start > 0 {
				p.log.add_error(&p.tracker, p.source.range_of_legacy_octal_escape(e.legacy_octal_loc),
					'Legacy octal escape sequences cannot be used in template literals')
			}
			mut tagThisFunc := 0
			mut tagWrapFunc := 0
			if e.tag_or_nil.data != nil {
				mut tag_is_lowered_optional_chain := false
				if p.options.unsupported_jsf_eatures.has(compat.optional_chain) {
					mut target_1 := e.tag_or_nil.data
					match target {
						js_ast.EDot {
							tag_is_lowered_optional_chain = target.optional_chain != js_ast.optional_chain_none
						}
						js_ast.EIndex {
							tag_is_lowered_optional_chain = target.optional_chain != js_ast.optional_chain_none
						}
					}
				}
				p.template_tag = e.tag_or_nil.data
				mut tag_1, tag_out := p.visit_expr_in_out(e.tag_or_nil, ExprIn{
					store_this_arg_for_parent_optional_chain: tag_is_lowered_optional_chain
				})
				e.tag_or_nil = tag
				tag_this_func = tag_out.this_arg_func
				tag_wrap_func = tag_out.this_arg_wrap_func
				mut id, ok_14 := tag.data
				if ok && p.symbols[id.ref.inner_index].flags.has(ast.call_can_be_unwrapped_if_unused) {
					e.can_be_unwrapped_if_unused = true
				}
				mut target_2, loc, private := p.extract_private_index(e.tag_or_nil)
				if private != nil {
					mut target_func, target_wrap_func := p.capture_value_with_possible_side_effects(target.loc,
						2, target, value_could_be_mutated)
					e.tag_or_nil = target_wrap_func(js_ast.Expr{
						loc:  target.loc
						data: &js_ast.ECall{
							target: js_ast.Expr{
								loc:  target.loc
								data: &js_ast.EDot{
									target:   p.lower_private_get(target_func(), loc,
										private)
									name:     'bind'
									name_loc: target.loc
								}
							}
							args:   [target_func()]
							kind:   js_ast.target_was_originally_property_access
						}
					})
				}
			}
			for i_2, part in e.parts {
				e.parts[i].value = p.visit_expr(part.value)
			}
			if p.should_fold_type_script_constant_expressions || p.options.minify_syntax {
				expr = js_ast.inline_primitives_into_template(expr.loc, e)
			}
			mut should_lower_template_literal := p.options.unsupported_jsf_eatures.has(compat.template_literal)
			if tag_this_func != nil {
				should_lower_template_literal = true
			}
			if !should_lower_template_literal
				&& !p.options.unsupported_jsf_eatures.has(compat.inline_script)
				&& e.tag_or_nil.data != nil {
				if contains_closing_script_tag(e.head_raw) {
					should_lower_template_literal = true
				} else {
					for _, part_1 in e.parts {
						if contains_closing_script_tag(part.tail_raw) {
							should_lower_template_literal = true
							break
						}
					}
				}
			}
			if should_lower_template_literal {
				mut e_1, ok_15 := expr.data
				if ok {
					return p.lower_template_literal(expr.loc, e, tag_this_func, tag_wrap_func), ExprOut{}
				}
			}
		}
		js_ast.EBinary {
			mut v := BinaryExprVisitor{
				e:   e
				loc: expr.loc
				in_: in_
			}
			mut stack_bottom := p.binary_expr_stack.len
			for {
				mut result_1 := v.check_and_prepare(p)
				if result.data != nil {
					expr = result
					break
				}
				mut left := v.e.left
				mut left_in := v.left_in
				mut left_binary, ok_16 := left.data
				if !ok || left_in.assign_target != js_ast.assign_target_none {
					v.e.left, _ = p.visit_expr_in_out(left, left_in)
					expr = v.visit_right_and_finish(p)
					break
				}
				p.binary_expr_stack << v
				v = BinaryExprVisitor{
					e:   left_binary
					loc: left.loc
					in_: left_in
				}
			}
			for {
				mut n := p.binary_expr_stack.len - 1
				if n < stack_bottom {
					break
				}
				mut v_1 := p.binary_expr_stack[n]
				p.binary_expr_stack = p.binary_expr_stack[..n]
				v.e.left = expr
				expr = v.visit_right_and_finish(p)
			}
			return expr, ExprOut{}
		}
		js_ast.EDot {
			mut is_delete_target_3 := e == p.delete_target
			mut is_call_target_3 := e == p.call_target
			mut is_template_tag := e == p.template_tag
			mut defines_1, ok_17 := p.options.defines.dot_defines[e.name]
			if ok {
				for _, define_1 in defines {
					if p.is_dot_or_index_define_match(expr, define.parts) {
						if define.data.define_expr != nil {
							mut new_1 := p.instantiate_define_expr(expr.loc, &define.data.define_expr,
								IdentifierOpts{
								assign_target:    in_.assign_target
								is_call_target:   is_call_target
								is_delete_target: is_delete_target
							})
							if in_.assign_target == js_ast.assign_target_none
								|| define_value_can_be_used_in_assign_target(new.data) {
								return new, ExprOut{}
							} else {
								mut r_8 := logger.Range{
									loc: expr.loc
									len: js_lexer.range_of_identifier(p.source, e.name_loc).end() - expr.loc.start
								}
								p.log_assign_to_define(r, '', expr)
							}
						}
						if define.data.flags.has(config.can_be_removed_if_unused) {
							e.can_be_removed_if_unused = true
						}
						if define.data.flags.has(config.call_can_be_unwrapped_if_unused)
							&& !p.options.ignore_dcea_nnotations {
							e.call_can_be_unwrapped_if_unused = true
						}
						if define.data.flags.has(config.is_symbol_instance) {
							e.is_symbol_instance = true
						}
						break
					}
				}
			}
			mut names_1, ok_18 := p.injected_dot_names[e.name]
			if ok {
				for _, name_3 in names {
					if p.is_dot_or_index_define_match(expr, name.parts) {
						return p.instantiate_inject_dot_name(expr.loc, name, in_.assign_target), ExprOut{}
					}
				}
			}
			if is_call_target && p.then_catch_chain.next_target == e {
				if e.name == 'catch' {
					p.then_catch_chain = ThenCatchChain{
						next_target: e.target.data
						has_catch:   true
						catch_loc:   e.name_loc
					}
				} else if e.name == 'then' {
					p.then_catch_chain = ThenCatchChain{
						next_target: e.target.data
						has_catch:   p.then_catch_chain.has_catch
							|| p.then_catch_chain.has_multiple_args
						catch_loc:   p.then_catch_chain.catch_loc
					}
				}
			}
			p.dot_or_index_target = e.target.data
			mut target_3, out := p.visit_expr_in_out(e.target, ExprIn{
				has_chain_parent: e.optional_chain == js_ast.optional_chain_continue
			})
			e.target = target
			if e.optional_chain == js_ast.optional_chain_none
				&& in_.assign_target == js_ast.assign_target_none && !is_call_target
				&& p.should_lower_super_property_access(e.target) {
				mut key := js_ast.Expr{
					loc:  e.name_loc
					data: &js_ast.EString{
						value: helpers.string_to_utf_16(e.name)
					}
				}
				mut value_1 := p.lower_super_property_get(expr.loc, key)
				if is_template_tag {
					value.data = &js_ast.ECall{
						target: js_ast.Expr{
							loc:  value.loc
							data: &js_ast.EDot{
								target:   value
								name:     'bind'
								name_loc: value.loc
							}
						}
						args:   [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
						]
						kind:   js_ast.target_was_originally_property_access
					}
				}
				return value, ExprOut{}
			}
			mut contains_optional_chain := e.optional_chain == js_ast.optional_chain_start
				|| e.optional_chain == js_ast.optional_chain_continue
				&& out.child_contains_optional_chain
			if contains_optional_chain && !in_.has_chain_parent {
				return p.lower_optional_chain(expr, in_, out)
			}
			out = ExprOut{
				child_contains_optional_chain:               contains_optional_chain
				method_call_must_be_replaced_with_undefined: out.method_call_must_be_replaced_with_undefined
				this_arg_func:                               out.this_arg_func
				this_arg_wrap_func:                          out.this_arg_wrap_func
			}
			if !in_.has_chain_parent {
				out.this_arg_func = nil
				out.this_arg_wrap_func = nil
			}
			if e.optional_chain == js_ast.optional_chain_none {
				mut value_2, ok_19 := p.maybe_rewrite_property_access(expr.loc, in_.assign_target,
					is_delete_target, e.target, e.name, e.name_loc, is_call_target, is_template_tag,
					false)
				if ok {
					return value, out
				}
			}
			return js_ast.Expr{
				loc:  expr.loc
				data: e
			}, out
		}
		js_ast.EIndex {
			mut is_call_target_4 := e == p.call_target
			mut is_template_tag_1 := e == p.template_tag
			mut is_delete_target_4 := e == p.delete_target
			mut str_2, ok_20 := e.index.data
			if ok {
				mut defines_2, ok_21 := p.options.defines.dot_defines[helpers.utf_16_to_string(str.value)]
				if ok {
					for _, define_2 in defines {
						if p.is_dot_or_index_define_match(expr, define.parts) {
							if define.data.define_expr != nil {
								mut new_2 := p.instantiate_define_expr(expr.loc, &define.data.define_expr,
									IdentifierOpts{
									assign_target:    in_.assign_target
									is_call_target:   is_call_target
									is_delete_target: is_delete_target
								})
								if in_.assign_target == js_ast.assign_target_none
									|| define_value_can_be_used_in_assign_target(new.data) {
									return new, ExprOut{}
								} else {
									mut r_9 := logger.Range{
										loc: expr.loc
									}
									mut after_index := logger.Loc{
										start: p.source.range_of_string(e.index.loc).end()
									}
									mut close_bracket := p.source.range_of_operator_after(after_index,
										']')
									if close_bracket.len > 0 {
										r.len = close_bracket.end() - r.loc.start
									}
									p.log_assign_to_define(r, '', expr)
								}
							}
							if define.data.flags.has(config.can_be_removed_if_unused) {
								e.can_be_removed_if_unused = true
							}
							if define.data.flags.has(config.call_can_be_unwrapped_if_unused)
								&& !p.options.ignore_dcea_nnotations {
								e.call_can_be_unwrapped_if_unused = true
							}
							if define.data.flags.has(config.is_symbol_instance) {
								e.is_symbol_instance = true
							}
							break
						}
					}
				}
			}
			if p.options.minify_syntax {
				mut str_3, ok_22 := e.index.data
				if ok && js_ast.is_identifier_utf_16(str.value) {
					mut dot := p.dot_or_mangled_prop_parse(e.target, js_lexer.MaybeSubstring{
						string: helpers.utf_16_to_string(str.value)
					}, e.index.loc, e.optional_chain, was_originally_index)
					if is_call_target {
						p.call_target = dot
					}
					if is_template_tag {
						p.template_tag = dot
					}
					if is_delete_target {
						p.delete_target = dot
					}
					return p.visit_expr_in_out(js_ast.Expr{
						loc:  expr.loc
						data: dot
					}, in_)
				}
			}
			p.dot_or_index_target = e.target.data
			mut target_4, out_1 := p.visit_expr_in_out(e.target, ExprIn{
				has_chain_parent: e.optional_chain == js_ast.optional_chain_continue
			})
			e.target = target
			mut private_1, ok_23 := e.index.data
			if ok {
				mut name_4 := p.load_name_from_ref(private.ref)
				mut result_2 := p.find_symbol(e.index.loc, name)
				private.ref = result.ref
				mut kind_2 := p.symbols[result.ref.inner_index].kind
				if !kind.is_private() {
					mut r_10 := logger.Range{
						loc: e.index.loc
						len: i32(name.len)
					}
					p.log.add_error(&p.tracker, r, strconv.v_sprintf('Private name %q must be declared in an enclosing class',
						name))
				} else {
					mut text := 0
					if in_.assign_target != js_ast.assign_target_none && (
						kind == ast.symbol_private_method
						|| kind == ast.symbol_private_static_method) {
						r = logger.Range{
							loc: e.index.loc
							len: i32(name.len)
						}
						text = strconv.v_sprintf('Writing to read-only method %q will throw',
							name)
					} else if in_.assign_target != js_ast.assign_target_none && (
						kind == ast.symbol_private_get || kind == ast.symbol_private_static_get) {
						r = logger.Range{
							loc: e.index.loc
							len: i32(name.len)
						}
						text = strconv.v_sprintf('Writing to getter-only property %q will throw',
							name)
					} else if in_.assign_target != js_ast.assign_target_replace && (
						kind == ast.symbol_private_set || kind == ast.symbol_private_static_set) {
						r = logger.Range{
							loc: e.index.loc
							len: i32(name.len)
						}
						text = strconv.v_sprintf('Reading from setter-only property %q will throw',
							name)
					}
					if text != '' {
						mut kind_3 := logger.warning
						if p.suppress_warnings_about_weird_code {
							kind = logger.debug
						}
						p.log.add_id(logger.msg_id_js_private_name_will_throw, kind, &p.tracker,
							r, text)
					}
				}
				if p.private_symbol_needs_to_be_lowered(private)
					&& e.optional_chain == js_ast.optional_chain_none
					&& in_.assign_target == js_ast.assign_target_none && !is_call_target
					&& !is_template_tag {
					return p.lower_private_get(e.target, e.index.loc, private), ExprOut{}
				}
			} else {
				e.index, _ = p.visit_expr_in_out(e.index, ExprIn{
					should_mangle_strings_as_props: true
				})
			}
			if e.optional_chain == js_ast.optional_chain_none
				&& in_.assign_target == js_ast.assign_target_none && !is_call_target
				&& p.should_lower_super_property_access(e.target) {
				mut value_3 := p.lower_super_property_get(expr.loc, e.index)
				if is_template_tag {
					value.data = &js_ast.ECall{
						target: js_ast.Expr{
							loc:  value.loc
							data: &js_ast.EDot{
								target:   value
								name:     'bind'
								name_loc: value.loc
							}
						}
						args:   [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
						]
						kind:   js_ast.target_was_originally_property_access
					}
				}
				return value, ExprOut{}
			}
			mut contains_optional_chain_1 := e.optional_chain == js_ast.optional_chain_start
				|| e.optional_chain == js_ast.optional_chain_continue
				&& out.child_contains_optional_chain
			if contains_optional_chain && !in_.has_chain_parent {
				return p.lower_optional_chain(expr, in_, out)
			}
			out = ExprOut{
				child_contains_optional_chain:               contains_optional_chain
				method_call_must_be_replaced_with_undefined: out.method_call_must_be_replaced_with_undefined
				this_arg_func:                               out.this_arg_func
				this_arg_wrap_func:                          out.this_arg_wrap_func
			}
			if !in_.has_chain_parent {
				out.this_arg_func = nil
				out.this_arg_wrap_func = nil
			}
			mut str_4, ok_24 := e.index.data
			if ok && e.optional_chain == js_ast.optional_chain_none {
				mut prefer_quoted_key := !p.options.minify_syntax
				mut value_4, ok_25 := p.maybe_rewrite_property_access(expr.loc, in_.assign_target,
					is_delete_target, e.target, helpers.utf_16_to_string(str.value), e.index.loc,
					is_call_target, is_template_tag, prefer_quoted_key)
				if ok {
					return value, out
				}
			}
			if p.options.mode == config.mode_bundle && (
				in_.assign_target != js_ast.assign_target_none || is_delete_target) {
				mut id_1, ok_26 := e.target.data
				if ok && p.symbols[id.ref.inner_index].kind == ast.symbol_import {
					mut r_11 := js_lexer.range_of_identifier(p.source, e.target.loc)
					p.log.add_error_with_notes(&p.tracker, r, strconv.v_sprintf('Cannot assign to property on import %q',
						p.symbols[id.ref.inner_index].original_name), [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
					])
				}
			}
			if p.options.minify_syntax {
				mut index := e.index.data
				match index {
					js_ast.EString {
						if js_ast.is_identifier_utf_16(index.value) {
							return js_ast.Expr{
								loc:  expr.loc
								data: &js_ast.EDot{
									target:                          e.target
									name:                            helpers.utf_16_to_string(index.value)
									name_loc:                        e.index.loc
									optional_chain:                  e.optional_chain
									can_be_removed_if_unused:        e.can_be_removed_if_unused
									call_can_be_unwrapped_if_unused: e.call_can_be_unwrapped_if_unused
								}
							}, out
						}
						mut number_value, ok_27 := js_ast.string_to_equivalent_number_value(index.value)
						if ok {
							e.index.data = &js_ast.ENumber{
								value: number_value
							}
						}
					}
					js_ast.ENumber {
						mut target_5, ok_28 := e.target.data
						if ok {
							mut int_value := math.floor(index.value)
							if index.value == int_value && int_value >= 0 && int_value < f64(target.value.len) {
								return js_ast.Expr{
									loc:  expr.loc
									data: &js_ast.EString{
										value: [u16(target.value[isize(int_value)])]
									}
								}, out
							}
						}
					}
				}
			}
			return js_ast.Expr{
				loc:  expr.loc
				data: e
			}, out
		}
		js_ast.EUnary {
			match e.op {
				js_ast.un_op_typeof {
					e.value, _ = p.visit_expr_in_out(e.value, ExprIn{
						assign_target: e.op.unary_assign_target()
					})
				}
				js_ast.un_op_delete {
					mut superPropLoc := 0
					mut e2 := e.value.data
					match e2 {
						js_ast.EDot {
							_, ok_29 := e2.target.data
							if ok {
								super_prop_loc = e2.target.loc
							}
						}
						js_ast.EIndex {
							_, ok_30 := e2.target.data
							if ok {
								super_prop_loc = e2.target.loc
							}
						}
						js_ast.EIdentifier {
							p.mark_strict_mode_feature(delete_bare_name, js_lexer.range_of_identifier(p.source,
								e.value.loc), '')
						}
					}
					if super_prop_loc.start != 0 {
						mut r_12 := js_lexer.range_of_identifier(p.source, super_prop_loc)
						mut text_1 := 'Attempting to delete a property of "super" will throw a ReferenceError'
						mut kind_4 := logger.warning
						if p.suppress_warnings_about_weird_code {
							kind = logger.debug
						}
						p.log.add_id(logger.msg_id_js_delete_super_property, kind, &p.tracker,
							r, text)
					}
					p.delete_target = e.value.data
					mut value_5, out_2 := p.visit_expr_in_out(e.value, ExprIn{
						has_chain_parent: true
					})
					e.value = value
					if out.child_contains_optional_chain {
						return p.lower_optional_chain(expr, in_, out)
					}
				}
				else {
					e.value, _ = p.visit_expr_in_out(e.value, ExprIn{
						assign_target: e.op.unary_assign_target()
					})
					match e.op {
						js_ast.un_op_not {
							if p.options.minify_syntax {
								e.value = p.ast_helpers.simplify_boolean_expr(e.value)
							}
							mut boolean_1, side_effects, ok_31 := js_ast.to_boolean_with_side_effects(e.value.data)
							if ok && side_effects == js_ast.no_side_effects {
								return js_ast.Expr{
									loc:  expr.loc
									data: &js_ast.EBoolean{
										value: !boolean
									}
								}, ExprOut{}
							}
							if p.options.minify_syntax {
								mut result_3, ok_32 := js_ast.maybe_simplify_not(e.value)
								if ok {
									return result, ExprOut{}
								}
							}
						}
						js_ast.un_op_void {
							if p.ast_helpers.expr_can_be_removed_if_unused(e.value) {
								return js_ast.Expr{
									loc:  expr.loc
									data: js_ast.eu_ndefined_shared
								}, ExprOut{}
							}
						}
						js_ast.un_op_pos {
							mut number, ok_33 := js_ast.to_number_without_side_effects(e.value.data)
							if ok {
								return js_ast.Expr{
									loc:  expr.loc
									data: &js_ast.ENumber{
										value: number
									}
								}, ExprOut{}
							}
						}
						js_ast.un_op_neg {
							mut number_1, ok_34 := js_ast.to_number_without_side_effects(e.value.data)
							if ok {
								return js_ast.Expr{
									loc:  expr.loc
									data: &js_ast.ENumber{
										value: -number
									}
								}, ExprOut{}
							}
						}
						js_ast.un_op_cpl {
							if p.should_fold_type_script_constant_expressions
								|| p.options.minify_syntax {
								mut number_2, ok_35 := js_ast.to_number_without_side_effects(e.value.data)
								if ok {
									return js_ast.Expr{
										loc:  expr.loc
										data: &js_ast.ENumber{
											value: f64(~js_ast.to_int32(number))
										}
									}, ExprOut{}
								}
							}
						}
						js_ast.un_op_pre_dec, js_ast.un_op_pre_inc, js_ast.un_op_post_dec,
						js_ast.un_op_post_inc {
							mut target_6, loc_1, private_2 := p.extract_private_index(e.value)
							if private != nil {
								return p.lower_private_set_un_op(target, loc, private,
									e.op), ExprOut{}
							}
							mut property_3 := p.extract_super_property(e.value)
							if property.data != nil {
								e.value = p.call_super_property_wrapper(expr.loc, property)
							}
						}
					}
				}
			}
			if p.options.minify_syntax && e.op != js_ast.un_op_delete && e.op != js_ast.un_op_typeof {
				mut comma, ok_36 := e.value.data
				if ok && comma.op == js_ast.bin_op_comma {
					return js_ast.join_with_comma(comma.left, js_ast.Expr{
						loc:  comma.right.loc
						data: &js_ast.EUnary{
							op:    e.op
							value: comma.right
						}
					}), ExprOut{}
				}
			}
		}
		js_ast.EIf {
			e.test = p.visit_expr(e.test)
			if p.options.minify_syntax {
				e.test = p.ast_helpers.simplify_boolean_expr(e.test)
			}
			mut child_in := ExprIn{
				should_mangle_strings_as_props: in_.should_mangle_strings_as_props
			}
			mut boolean_2, side_effects_1, ok_37 := js_ast.to_boolean_with_side_effects(e.test.data)
			if !ok {
				e.yes, _ = p.visit_expr_in_out(e.yes, child_in)
				e.no, _ = p.visit_expr_in_out(e.no, child_in)
			}
			else {
				if boolean {
					e.yes, _ = p.visit_expr_in_out(e.yes, child_in)
					mut old := p.is_control_flow_dead
					p.is_control_flow_dead = true
					e.no, _ = p.visit_expr_in_out(e.no, child_in)
					p.is_control_flow_dead = old
					if p.options.minify_syntax {
						if side_effects == js_ast.could_have_side_effects {
							return js_ast.join_with_comma(p.ast_helpers.simplify_unused_expr(e.test,
								p.options.unsupported_jsf_eatures), e.yes), ExprOut{}
						}
						return e.yes, ExprOut{}
					}
				} else {
					mut old_1 := p.is_control_flow_dead
					p.is_control_flow_dead = true
					e.yes, _ = p.visit_expr_in_out(e.yes, child_in)
					p.is_control_flow_dead = old
					e.no, _ = p.visit_expr_in_out(e.no, child_in)
					if p.options.minify_syntax {
						if side_effects == js_ast.could_have_side_effects {
							return js_ast.join_with_comma(p.ast_helpers.simplify_unused_expr(e.test,
								p.options.unsupported_jsf_eatures), e.no), ExprOut{}
						}
						return e.no, ExprOut{}
					}
				}
			}
			if p.options.minify_syntax {
				return p.ast_helpers.mangle_if_expr(expr.loc, e, p.options.unsupported_jsf_eatures), ExprOut{}
			}
		}
		js_ast.EAwait {
			if p.fn_or_arrow_data_visit.is_outside_fn_or_arrow {
				if p.is_control_flow_dead && (
					p.options.unsupported_jsf_eatures.has(compat.top_level_await)
					|| !p.options.output_format.keep_esmi_mport_export_syntax()) {
					return p.visit_expr_in_out(e.value, in_)
				} else {
					p.live_top_level_await_keyword = logger.Range{
						loc: expr.loc
						len: 5
					}
					p.mark_syntax_feature(compat.top_level_await, logger.Range{
						loc: expr.loc
						len: 5
					})
				}
			}
			p.await_target = e.value.data
			e.value = p.visit_expr(e.value)
			return p.maybe_lower_await(expr.loc, e), ExprOut{}
		}
		js_ast.EYield {
			if e.value_or_nil.data != nil {
				e.value_or_nil = p.visit_expr(e.value_or_nil)
			}
			if e.is_star && p.options.unsupported_jsf_eatures.has(compat.async_generator) && p.fn_or_arrow_data_visit.is_generator {
				e.value_or_nil = p.call_runtime(expr.loc, '__yieldStar', [
					e.value_or_nil,
				])
			}
		}
		js_ast.EArray {
			if in_.assign_target != js_ast.assign_target_none {
				if e.comma_after_spread.start != 0 {
					p.log.add_error(&p.tracker, logger.Range{
						loc: e.comma_after_spread
						len: 1
					}, 'Unexpected "," after rest pattern')
				}
				p.mark_syntax_feature(compat.destructuring, logger.Range{
					loc: expr.loc
					len: 1
				})
			}
			mut has_spread_1 := false
			for i_3, item in e.items {
				mut e2_1 := item.data
				match e2 {
					js_ast.EMissing {}
					js_ast.ESpread {
						e2.value, _ = p.visit_expr_in_out(e2.value, ExprIn{
							assign_target: in_.assign_target
						})
						has_spread = true
					}
					js_ast.EBinary {
						if in_.assign_target != js_ast.assign_target_none && e2.op == js_ast.bin_op_assign {
							e2.left, _ = p.visit_expr_in_out(e2.left, ExprIn{
								assign_target: js_ast.assign_target_replace
							})
							mut id_2, ok_38 := e2.left.data
							if ok {
								p.name_to_keep = p.symbols[id.ref.inner_index].original_name
								p.name_to_keep_is_for = e2.right.data
							}
							e2.right = p.visit_expr(e2.right)
						} else {
							item, _ = p.visit_expr_in_out(item, ExprIn{
								assign_target: in_.assign_target
							})
						}
					}
					else {
						item, _ = p.visit_expr_in_out(item, ExprIn{
							assign_target: in_.assign_target
						})
					}
				}
				e.items[i] = item
			}
			if p.options.minify_syntax && has_spread && in_.assign_target == js_ast.assign_target_none {
				e.items = js_ast.inline_spreads_of_array_literals(e.items)
			}
		}
		js_ast.EObject {
			if in_.assign_target != js_ast.assign_target_none {
				if e.comma_after_spread.start != 0 {
					p.log.add_error(&p.tracker, logger.Range{
						loc: e.comma_after_spread
						len: 1
					}, 'Unexpected "," after rest pattern')
				}
				p.mark_syntax_feature(compat.destructuring, logger.Range{
					loc: expr.loc
					len: 1
				})
			}
			mut has_spread_2 := false
			mut proto_range := logger.Range{}
			mut inner_class_name_ref := ast.invalid_ref
			for i_4, _ in e.properties {
				mut property_4 := &e.properties[i]
				if property.kind != js_ast.property_spread {
					mut key_1 := property.key
					mut mangled_1, ok_39 := key.data
					if ok {
						mangled.ref = p.symbol_for_mangled_prop(p.load_name_from_ref(mangled.ref))
					} else {
						key, _ = p.visit_expr_in_out(property.key, ExprIn{
							should_mangle_strings_as_props: true
						})
						property.key = key
					}
					if !property.flags.has(js_ast.property_is_computed)
						&& !property.flags.has(js_ast.property_was_shorthand)
						&& property.kind == js_ast.property_field
						&& in_.assign_target == js_ast.assign_target_none {
						mut str_5, ok_40 := key.data
						if ok && helpers.utf_16_equals_string(str.value, '__proto__') {
							mut r_13 := js_lexer.range_of_identifier(p.source, key.loc)
							if proto_range.len > 0 {
								p.log.add_error_with_notes(&p.tracker, r, 'Cannot specify the "__proto__" property more than once per object',
									[
									p.tracker.msg_data(proto_range, 'The earlier "__proto__" property is here:'),
								])
							} else {
								proto_range = r
							}
						}
					}
					if p.options.minify_syntax && property.flags.has(js_ast.property_is_computed) {
						mut inlined, ok_41 := key.data
						if ok {
							// append no rhs

							// lhs.len==0
						}
						mut k := key.data
						match k {
							js_ast.ENumber, js_ast.ENameOfSymbol {
								property.flags &= ~js_ast.property_is_computed
							}
							js_ast.EString {
								if !helpers.utf_16_equals_string(k.value, '__proto__') {
									property.flags &= ~js_ast.property_is_computed
								}
							}
						}
					}
				} else {
					has_spread = true
				}
				if in_.assign_target != js_ast.assign_target_none && property.initializer_or_nil.data == nil && property.value_or_nil.data != nil {
					mut binary, ok_42 := property.value_or_nil.data
					if ok && binary.op == js_ast.bin_op_assign {
						property.initializer_or_nil = binary.right
						property.value_or_nil = binary.left
					}
				}
				if property.value_or_nil.data != nil {
					mut old_is_in_static_class_context := p.fn_only_data_visit.is_in_static_class_context
					mut old_inner_class_name_ref := p.fn_only_data_visit.inner_class_name_ref
					if property.kind == js_ast.property_method && p.options.unsupported_jsf_eatures.has(compat.async_await) {
						mut fn_, ok_43 := property.value_or_nil.data
						if ok && fn_.fn_.is_async {
							if inner_class_name_ref == ast.invalid_ref {
								inner_class_name_ref = p.generate_temp_ref(temp_ref_needs_declare_may_be_captured_inside_loop,
									'')
							}
							p.fn_only_data_visit.is_in_static_class_context = true
							p.fn_only_data_visit.inner_class_name_ref = &inner_class_name_ref
						}
					}
					mut str_6, ok_44 := property.key.data
					if ok {
						p.name_to_keep = helpers.utf_16_to_string(str.value)
						p.name_to_keep_is_for = property.value_or_nil.data
					}
					property.value_or_nil, _ = p.visit_expr_in_out(property.value_or_nil,
						ExprIn{
						is_method:     property.kind.is_method_definition()
						assign_target: in_.assign_target
					})
					p.fn_only_data_visit.inner_class_name_ref = old_inner_class_name_ref
					p.fn_only_data_visit.is_in_static_class_context = old_is_in_static_class_context
				}
				if property.initializer_or_nil.data != nil {
					mut id_3, ok_45 := property.value_or_nil.data
					if ok {
						p.name_to_keep = p.symbols[id.ref.inner_index].original_name
						p.name_to_keep_is_for = property.initializer_or_nil.data
					}
					property.initializer_or_nil = p.visit_expr(property.initializer_or_nil)
				}
				if p.options.minify_syntax {
					mut str_7, ok_46 := property.key.data
					if ok {
						mut number_value_1, ok_47 := js_ast.string_to_equivalent_number_value(str.value)
						if ok && number_value >= 0 {
							property.key.data = &js_ast.ENumber{
								value: number_value
							}
						}
					}
				}
			}
			if !p.suppress_warnings_about_weird_code {
				p.warn_about_duplicate_properties(e.properties, duplicate_properties_in_object)
			}
			if in_.assign_target == js_ast.assign_target_none {
				if p.options.minify_syntax && has_spread {
					e.properties = js_ast.mangle_object_spread(e.properties)
				}
				mut value_6 := p.lower_object_spread(expr.loc, e)
				if inner_class_name_ref != ast.invalid_ref && p.symbols[inner_class_name_ref.inner_index].use_count_estimate > 0 {
					p.record_usage(inner_class_name_ref)
					value = js_ast.assign(js_ast.Expr{
						loc:  expr.loc
						data: &js_ast.EIdentifier{
							ref: inner_class_name_ref
						}
					}, value)
				}
				return value, ExprOut{}
			}
		}
		js_ast.EImportCall {
			mut is_await_target := e == p.await_target
			mut is_then_catch_target := e == p.then_catch_chain.next_target && p.then_catch_chain.has_catch
			e.expr = p.visit_expr(e.expr)
			mut assertOrWith := 0
			if e.options_or_nil.data != nil {
				e.options_or_nil = p.visit_expr(e.options_or_nil)
				mut why := 'the second argument was not an object literal'
				mut why_loc := e.options_or_nil.loc
				mut object, ok_48 := e.options_or_nil.data
				if ok {
					if object.properties.len == 1 {
						mut prop := object.properties[0]
						if prop.kind == js_ast.property_field
							&& !prop.flags.has(js_ast.property_is_computed) {
							mut str_8, ok_49 := prop.key.data
							if ok && (helpers.utf_16_equals_string(str.value, 'assert')
								|| helpers.utf_16_equals_string(str.value, 'with')) {
								mut keyword := ast.with_keyword
								if helpers.utf_16_equals_string(str.value, 'assert') {
									keyword = ast.assert_keyword
								}
								mut value_7, ok_50 := prop.value_or_nil.data
								if ok {
									mut entries := []
									{}
									for _, p_1 in value.properties {
										if p.kind == js_ast.property_field
											&& !p.flags.has(js_ast.property_is_computed) {
											mut key_2, ok_51 := p.key.data
											if ok {
												mut value_8, ok_52 := p.value_or_nil.data
												if ok {
													entries << ast.AssertOrWithEntry{
														key:               key.value
														key_loc:           p.key.loc
														value:             value.value
														value_loc:         p.value_or_nil.loc
														prefer_quoted_key: p.flags.has(js_ast.property_prefer_quoted_key)
													}
													if keyword == ast.assert_keyword && helpers.utf_16_equals_string(key.value,
														'type') && helpers.utf_16_equals_string(value.value,
														'json') {
														flags |= ast.assert_type_json
													}
													continue
												} else {
													why = strconv.v_sprintf('the value for the property %q was not a string literal',
														helpers.utf_16_to_string(key.value))
													why_loc = p.value_or_nil.loc
												}
											} else {
												why = 'this property was not a string literal'
												why_loc = p.key.loc
											}
										} else {
											why = 'this property was invalid'
											why_loc = p.key.loc
										}
										entries = nil
										break
									}
									if entries != nil {
										if keyword == ast.assert_keyword {
											p.maybe_warn_about_assert_keyword(prop.key.loc)
										}
										assert_or_with = &ast.ImportAssertOrWith{
											entries:               entries
											keyword:               keyword
											keyword_loc:           prop.key.loc
											inner_open_brace_loc:  prop.value_or_nil.loc
											inner_close_brace_loc: value.close_brace_loc
											outer_open_brace_loc:  e.options_or_nil.loc
											outer_close_brace_loc: object.close_brace_loc
										}
										why = ''
									}
								} else {
									why = 'the value for "assert" was not an object literal'
									why_loc = prop.value_or_nil.loc
								}
							} else {
								why = 'this property was not called "assert" or "with"'
								why_loc = prop.key.loc
							}
						} else {
							why = 'this property was invalid'
							why_loc = prop.key.loc
						}
					} else {
						why = 'the second argument was not an object literal with a single property called "assert" or "with"'
						why_loc = e.options_or_nil.loc
					}
				}
				if why != '' {
					if p.options.mode == config.mode_bundle {
						mut text_2 := 'This "import()" was not recognized because ' + why
						mut kind_5 := logger.warning
						if p.suppress_warnings_about_weird_code {
							kind = logger.debug
						}
						p.log.add_id(logger.msg_id_js_unsupported_dynamic_import, kind,
							&p.tracker, logger.Range{
							loc: why_loc
						}, text)
					}
					if p.options.unsupported_jsf_eatures.has(compat.import_assertions) && p.options.unsupported_jsf_eatures.has(compat.import_attributes) {
						if p.ast_helpers.expr_can_be_removed_if_unused(e.options_or_nil) {
							e.options_or_nil = js_ast.Expr{}
						} else {
							p.mark_syntax_feature(compat.import_attributes, logger.Range{
								loc: e.options_or_nil.loc
							})
						}
					}
					break
				}
			}
			return p.maybe_transpose_if_expr_chain(e.expr, fn (arg js_ast.Expr) {
				mut str_9, ok_53 := arg.data
				if ok {
					if p.is_control_flow_dead {
						return js_ast.Expr{
							loc:  arg.loc
							data: js_ast.en_ull_shared
						}
					}
					mut import_record_index := p.add_import_record(ast.import_dynamic,
						p.source.range_of_string(arg.loc), helpers.utf_16_to_string(str.value),
						assert_or_with, flags)
					if is_await_target && p.fn_or_arrow_data_visit.try_body_count != 0 {
						mut record := &p.import_records[import_record_index]
						record.flags |= ast.handles_import_errors
						record.error_handler_loc = p.fn_or_arrow_data_visit.try_catch_loc
					} else if is_then_catch_target {
						mut record_1 := &p.import_records[import_record_index]
						record.flags |= ast.handles_import_errors
						record.error_handler_loc = p.then_catch_chain.catch_loc
					}
					p.import_records_for_current_part << import_record_index
					return js_ast.Expr{
						loc:  expr.loc
						data: &js_ast.EImportString{
							import_record_index: import_record_index
							close_paren_loc:     e.close_paren_loc
						}
					}
				}
				if p.options.mode == config.mode_bundle {
					mut value_9 := p.handle_glob_pattern(arg, ast.import_dynamic, 'globImport',
						assert_or_with)
					if value.data != nil {
						return value
					}
				}
				mut r_14 := js_lexer.range_of_identifier(p.source, expr.loc)
				p.log.add_id(logger.msg_id_js_unsupported_dynamic_import, logger.debug,
					&p.tracker, r, 'This "import" expression will not be bundled because the argument is not a string literal')
				if p.options.unsupported_jsf_eatures.has(compat.dynamic_import) {
					mut then := 0
					mut value_10 := p.call_runtime(arg.loc, '__toESM', [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
					])
					mut body := js_ast.FnBody{
						loc:   expr.loc
						block: js_ast.SBlock{
							stmts: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
							]
						}
					}
					if p.options.unsupported_jsf_eatures.has(compat.arrow) {
						then = js_ast.Expr{
							loc:  expr.loc
							data: &js_ast.EFunction{
								fn_: js_ast.Fn{
									body: body
								}
							}
						}
					} else {
						then = js_ast.Expr{
							loc:  expr.loc
							data: &js_ast.EArrow{
								body:        body
								prefer_expr: true
							}
						}
					}
					return js_ast.Expr{
						loc:  expr.loc
						data: &js_ast.ECall{
							target: js_ast.Expr{
								loc:  expr.loc
								data: &js_ast.EDot{
									target:   js_ast.Expr{
										loc:  expr.loc
										data: &js_ast.ECall{
											target: js_ast.Expr{
												loc:  expr.loc
												data: &js_ast.EDot{
													target:   js_ast.Expr{
														loc:  expr.loc
														data: &js_ast.EIdentifier{
															ref: p.make_promise_ref()
														}
													}
													name:     'resolve'
													name_loc: expr.loc
												}
											}
											kind:   js_ast.target_was_originally_property_access
										}
									}
									name:     'then'
									name_loc: expr.loc
								}
							}
							args:   [then]
							kind:   js_ast.target_was_originally_property_access
						}
					}
				}
				return js_ast.Expr{
					loc:  expr.loc
					data: &js_ast.EImportCall{
						expr:            arg
						options_or_nil:  e.options_or_nil
						close_paren_loc: e.close_paren_loc
					}
				}
			}), ExprOut{}
		}
		js_ast.ECall {
			p.call_target = e.target.data
			p.then_catch_chain = ThenCatchChain{
				next_target:       e.target.data
				has_multiple_args: e.args.len >= 2
				has_catch:         p.then_catch_chain.next_target == e && p.then_catch_chain.has_catch
				catch_loc:         p.then_catch_chain.catch_loc
			}
			if p.then_catch_chain.has_multiple_args {
				p.then_catch_chain.catch_loc = e.args[1].loc
			}
			mut could_be_require_resolve := false
			mut could_be_object_create := false
			if e.args.len == 1 {
				mut dot_1, ok_54 := e.target.data
				if ok && dot.optional_chain == js_ast.optional_chain_none {
					if p.options.mode != config.mode_pass_through && dot.name == 'resolve' {
						could_be_require_resolve = true
					} else if dot.name == 'create' {
						could_be_object_create = true
					}
				}
			}
			mut was_identifier_before_visit := false
			mut is_parenthesized_optional_chain := false
			mut e2_2 := e.target.data
			match e2 {
				js_ast.EIdentifier {
					was_identifier_before_visit = true
				}
				js_ast.EDot {
					is_parenthesized_optional_chain = e.optional_chain == js_ast.optional_chain_none && e2.optional_chain != js_ast.optional_chain_none
				}
				js_ast.EIndex {
					is_parenthesized_optional_chain = e.optional_chain == js_ast.optional_chain_none && e2.optional_chain != js_ast.optional_chain_none
				}
			}
			mut target_7, out_3 := p.visit_expr_in_out(e.target, ExprIn{
				has_chain_parent:                         e.optional_chain == js_ast.optional_chain_continue
				store_this_arg_for_parent_optional_chain:
					e.optional_chain == js_ast.optional_chain_start
					|| is_parenthesized_optional_chain
			})
			e.target = target
			p.warn_about_import_namespace_call(e.target, expr_kind_call)
			mut has_spread_3 := false
			mut old_is_control_flow_dead := p.is_control_flow_dead
			if out.method_call_must_be_replaced_with_undefined {
				if js_ast.is_property_access(e.target) {
					p.is_control_flow_dead = true
				} else {
					out.method_call_must_be_replaced_with_undefined = false
				}
			}
			for i_5, arg_1 in e.args {
				arg = p.visit_expr(arg)
				_, ok_55 := arg.data
				if ok {
					has_spread = true
				}
				e.args[i] = arg
			}
			if !e.can_be_unwrapped_if_unused {
				mut target_8 := e.target.data
				match target {
					js_ast.EArrow {
						if !target.is_async && p.iife_can_be_removed_if_unused(target.args,
							target.body) {
							e.can_be_unwrapped_if_unused = true
						}
					}
					js_ast.EFunction {
						if !target.fn_.is_async && !target.fn_.is_generator
							&& p.iife_can_be_removed_if_unused(target.fn_.args, target.fn_.body) {
							e.can_be_unwrapped_if_unused = true
						}
					}
				}
			}
			if p.options.decode_hydrate_runtime_state_yarn_pn_p {
				mut id_4, ok_56 := e.target.data
				if ok && p.symbols[id.ref.inner_index].original_name == 'hydrateRuntimeState' && e.args.len >= 1 {
					mut arg_2 := e.args[0].data
					match arg {
						js_ast.EObject {
							mut arg_3 := e.args[0]
							if is_valid_json(arg) {
								p.manifest_for_yarn_pn_p = arg
							}
						}
						js_ast.ECall {
							if arg.args.len == 1 {
								mut dot_2, ok_57 := arg.target.data
								if ok && dot.name == 'parse' {
									mut id_5, ok_58 := dot.target.data
									if ok {
										mut symbol := &p.symbols[id.ref.inner_index]
										if symbol.kind == ast.symbol_unbound && symbol.original_name == 'JSON' {
											mut arg_4 := arg.args[0]
											mut a := arg.data
											match a {
												js_ast.EString {
													mut source := logger.Source{
														key_path: p.source.key_path
														contents: helpers.utf_16_to_string(a.value)
													}
													mut string_in_jst_able := logger.generate_string_in_jst_able(p.source.contents,
														arg.loc, source.contents)
													mut log := logger.new_string_in_jsl_og(p.log,
														&p.tracker, string_in_jst_able)
													p.manifest_for_yarn_pn_p, _ = parse_json(log,
														source, JSONOptions{})
													remap_expr_locs_in_json(&p.manifest_for_yarn_pn_p,
														string_in_jst_able)
												}
												js_ast.EIdentifier {
													mut data_1, ok_59 := p.string_locals_for_yarn_pn_p[a.ref]
													if ok {
														mut source_1 := logger.Source{
															key_path: p.source.key_path
															contents: helpers.utf_16_to_string(data.value)
														}
														mut string_in_jst_able_1 := logger.generate_string_in_jst_able(p.source.contents,
															data.loc, source.contents)
														mut log_1 := logger.new_string_in_jsl_og(p.log,
															&p.tracker, string_in_jst_able)
														p.manifest_for_yarn_pn_p, _ = parse_json(log,
															source, JSONOptions{})
														remap_expr_locs_in_json(&p.manifest_for_yarn_pn_p,
															string_in_jst_able)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if out.method_call_must_be_replaced_with_undefined {
				p.is_control_flow_dead = old_is_control_flow_dead
				return js_ast.Expr{
					loc:  expr.loc
					data: js_ast.eu_ndefined_shared
				}, ExprOut{}
			}
			if p.options.minify_syntax && has_spread {
				e.args = js_ast.inline_spreads_of_array_literals(e.args)
			}
			mut t := target.data
			match t {
				js_ast.EImportIdentifier {
					if p.options.minify_syntax && !p.is_control_flow_dead {
						p.convert_symbol_use_to_call(t.ref, e.args.len == 1 && !has_spread)
					}
				}
				js_ast.EIdentifier {
					if e.optional_chain == js_ast.optional_chain_none {
						mut symbol_1 := p.symbols[t.ref.inner_index]
						if was_identifier_before_visit && symbol.original_name == 'eval' {
							e.kind = js_ast.direct_eval
							if p.options.mode == config.mode_bundle
								&& !p.is_file_considered_to_have_esme_xports {
								p.record_usage(p.module_ref)
								p.record_usage(p.exports_ref)
							}
							for s := p.current_scope; s != nil; s = s.parent {
								s.contains_direct_eval = true
							}
							mut text_3 := 'Using direct eval with a bundler is not recommended and may cause problems'
							mut kind_6 := logger.debug
							if p.options.mode == config.mode_bundle && p.is_file_considered_esm
								&& !p.suppress_warnings_about_weird_code {
								kind = logger.warning
							}
							p.log.add_idw_ith_notes(logger.msg_id_js_direct_eval, kind,
								&p.tracker, js_lexer.range_of_identifier(p.source, e.target.loc),
								text, [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
							])
						} else if symbol.flags.has(ast.call_can_be_unwrapped_if_unused) {
							t.call_can_be_unwrapped_if_unused = true
						}
					}
					if p.options.minify_syntax && t.can_be_removed_if_unused && e.args.len <= 1
						&& !has_spread {
						mut symbol_2 := &p.symbols[t.ref.inner_index]
						if symbol.kind == ast.symbol_unbound {
							match symbol.original_name {
								'Boolean' {
									if e.args.len == 0 {
										return js_ast.Expr{
											loc:  expr.loc
											data: &js_ast.EBoolean{
												value: false
											}
										}, ExprOut{}
									} else {
										expr.data = &js_ast.EUnary{
											value: p.ast_helpers.simplify_boolean_expr(e.args[0])
											op:    js_ast.un_op_not
										}
										return js_ast.not(expr), ExprOut{}
									}
								}
								'Number' {
									if e.args.len == 0 {
										return js_ast.Expr{
											loc:  expr.loc
											data: &js_ast.ENumber{
												value: 0
											}
										}, ExprOut{}
									} else {
										mut arg_5 := e.args[0]
										match js_ast.known_primitive_type(arg.data) {
											js_ast.primitive_number {
												return arg, ExprOut{}
											}
											js_ast.primitive_undefined, js_ast.primitive_null,
											js_ast.primitive_boolean, js_ast.primitive_string {
												mut number_3, ok_60 := js_ast.to_number_without_side_effects(arg.data)
												if ok {
													expr.data = &js_ast.ENumber{
														value: number
													}
												} else {
													expr.data = &js_ast.EUnary{
														value: arg
														op:    js_ast.un_op_pos
													}
												}
												return expr, ExprOut{}
											}
										}
									}
								}
								'String' {
									if e.args.len == 0 {
										return js_ast.Expr{
											loc:  expr.loc
											data: &js_ast.EString{
												value: nil
											}
										}, ExprOut{}
									} else {
										mut arg_6 := e.args[0]
										match js_ast.known_primitive_type(arg.data) {
											js_ast.primitive_string {
												return arg, ExprOut{}
											}
										}
									}
								}
								'BigInt' {
									if e.args.len == 1 {
										mut arg_7 := e.args[0]
										match js_ast.known_primitive_type(arg.data) {
											js_ast.primitive_big_int {
												return arg, ExprOut{}
											}
										}
									}
								}
							}
						}
					}
					if t.call_can_be_unwrapped_if_unused {
						e.can_be_unwrapped_if_unused = true
					}
					if p.options.minify_syntax && !p.is_control_flow_dead {
						p.convert_symbol_use_to_call(t.ref, e.args.len == 1 && !has_spread)
					}
				}
				js_ast.EDot {
					if could_be_require_resolve && t.name == 'resolve' {
						mut id_6, ok_61 := t.target.data
						if ok && id.ref == p.require_ref {
							p.ignore_usage(p.require_ref)
							return p.maybe_transpose_if_expr_chain(e.args[0], fn (arg js_ast.Expr) {
								mut str_10, ok_62 := e.args[0].data
								if ok {
									if p.is_control_flow_dead {
										return js_ast.Expr{
											loc:  expr.loc
											data: js_ast.en_ull_shared
										}
									}
									mut import_record_index_1 := p.add_import_record(ast.import_require_resolve,
										p.source.range_of_string(e.args[0].loc), helpers.utf_16_to_string(str.value),
										nil, 0)
									if p.fn_or_arrow_data_visit.try_body_count != 0 {
										mut record_2 := &p.import_records[import_record_index]
										record.flags |= ast.handles_import_errors
										record.error_handler_loc = p.fn_or_arrow_data_visit.try_catch_loc
									}
									p.import_records_for_current_part << import_record_index
									return js_ast.Expr{
										loc:  expr.loc
										data: &js_ast.ERequireResolveString{
											import_record_index: import_record_index
											close_paren_loc:     e.close_paren_loc
										}
									}
								}
								return js_ast.Expr{
									loc:  expr.loc
									data: &js_ast.ECall{
										target:          js_ast.Expr{
											loc:  e.target.loc
											data: &js_ast.EDot{
												target:   p.value_to_substitute_for_require(t.target.loc)
												name:     t.name
												name_loc: t.name_loc
											}
										}
										args:            [arg]
										kind:            e.kind
										close_paren_loc: e.close_paren_loc
									}
								}
							}), ExprOut{}
						}
					}
					if could_be_object_create && t.name == 'create' {
						mut id_7, ok_63 := t.target.data
						if ok {
							mut symbol_3 := &p.symbols[id.ref.inner_index]
							if symbol.kind == ast.symbol_unbound && symbol.original_name == 'Object' {
								// append no rhs

								// lhs.len==0
							}
						}
					}
					if p.options.minify_syntax {
						match t.name {
							'charCodeAt' {
								mut str_11, ok_64 := t.target.data
								if ok && e.args.len <= 1 {
									mut index_1 := isize(0)
									mut has_index := false
									if e.args.len == 0 {
										has_index = true
									} else {
										// LOOL0
										mut num, ok_65 := e.args[0].data
										if ok && num.value == math.trunc(num.value) && math.abs(num.value) <= 0x7FFF_FFFF {
											index = isize(num.value)
											has_index = true
										}
									}
									if has_index {
										if index >= 0 && index < str.value.len {
											return js_ast.Expr{
												loc:  expr.loc
												data: &js_ast.ENumber{
													value: f64(str.value[index])
												}
											}, ExprOut{}
										} else {
											return js_ast.Expr{
												loc:  expr.loc
												data: &js_ast.ENumber{
													value: math.na_n()
												}
											}, ExprOut{}
										}
									}
								}
							}
							'fromCharCode' {
								mut id_8, ok_66 := t.target.data
								if ok {
									mut symbol_4 := &p.symbols[id.ref.inner_index]
									if symbol.kind == ast.symbol_unbound && symbol.original_name == 'String' {
										mut char_codes := []u16{len: 0, cap: e.Args.len}
										for _, arg_8 in e.args {
											mut arg_9, ok_67 := js_ast.to_number_without_side_effects(arg.data)
											if !ok {
												break
											}
											char_codes << u16(js_ast.to_int32(arg))
										}
										if char_codes.len == e.args.len {
											return js_ast.Expr{
												loc:  expr.loc
												data: &js_ast.EString{
													value: char_codes
												}
											}, ExprOut{}
										}
									}
								}
							}
							'toString' {
								mut target_9 := t.target.data
								match target {
									js_ast.ENumber {
										mut radix := isize(0)
										if e.args.len == 0 {
											radix = isize(10)
										} else if e.args.len == 1 {
											mut num_1, ok_68 := e.args[0].data
											if ok && num.value == math.trunc(num.value) && num.value >= 2 && num.value <= 36 {
												radix = isize(num.value)
											}
										}
										if radix != 0 {
											mut str_12, ok_69 := js_ast.try_to_string_on_number_safely(target.value,
												radix)
											if ok {
												return js_ast.Expr{
													loc:  expr.loc
													data: &js_ast.EString{
														value: helpers.string_to_utf_16(str)
													}
												}, ExprOut{}
											}
										}
									}
									js_ast.ERegExp {
										if e.args.len == 0 {
											return js_ast.Expr{
												loc:  expr.loc
												data: &js_ast.EString{
													value: helpers.string_to_utf_16(target.value)
												}
											}, ExprOut{}
										}
									}
									js_ast.EBoolean {
										if e.args.len == 0 {
											if target.value {
												return js_ast.Expr{
													loc:  expr.loc
													data: &js_ast.EString{
														value: helpers.string_to_utf_16('true')
													}
												}, ExprOut{}
											} else {
												return js_ast.Expr{
													loc:  expr.loc
													data: &js_ast.EString{
														value: helpers.string_to_utf_16('false')
													}
												}, ExprOut{}
											}
										}
									}
									js_ast.EString {
										if e.args.len == 0 {
											return t.target, ExprOut{}
										}
									}
								}
							}
						}
					}
					if t.call_can_be_unwrapped_if_unused {
						e.can_be_unwrapped_if_unused = true
					}
				}
				js_ast.EIndex {
					if t.call_can_be_unwrapped_if_unused {
						e.can_be_unwrapped_if_unused = true
					}
				}
				js_ast.ESuper {
					if p.super_ctor_ref != ast.invalid_ref {
						p.record_usage(p.super_ctor_ref)
						target.data = &js_ast.EIdentifier{
							ref: p.super_ctor_ref
						}
						e.target.data = target.data
					}
				}
			}
			if is_parenthesized_optional_chain && out.this_arg_func != nil && out.this_arg_wrap_func != nil {
				return p.lower_parenthesized_optional_chain(expr.loc, e, out), ExprOut{}
			}
			mut contains_optional_chain_2 := e.optional_chain == js_ast.optional_chain_start
				|| e.optional_chain == js_ast.optional_chain_continue
				&& out.child_contains_optional_chain
			if contains_optional_chain && !in_.has_chain_parent {
				return p.lower_optional_chain(expr, in_, out)
			}
			if !contains_optional_chain {
				mut target_10, loc_2, private_3 := p.extract_private_index(e.target)
				if private != nil {
					mut target_func_1, target_wrap_func_1 := p.capture_value_with_possible_side_effects(target.loc,
						2, target, value_could_be_mutated)
					return target_wrap_func(js_ast.Expr{
						loc:  target.loc
						data: &js_ast.ECall{
							target:                     js_ast.Expr{
								loc:  target.loc
								data: &js_ast.EDot{
									target:   p.lower_private_get(target_func(), loc,
										private)
									name:     'call'
									name_loc: target.loc
								}
							}
							args:                       append([
								target_func()], e.args)
							can_be_unwrapped_if_unused: e.can_be_unwrapped_if_unused
							kind:                       js_ast.target_was_originally_property_access
						}
					}), ExprOut{}
				}
				p.maybe_lower_super_property_get_inside_call(e)
			}
			if p.options.mode != config.mode_pass_through && e.optional_chain == js_ast.optional_chain_none {
				mut id_9, ok_70 := e.target.data
				if ok && id.ref == p.require_ref {
					mut omit_warnings := p.fn_or_arrow_data_visit.try_body_count != 0
					if p.options.mode != config.mode_pass_through {
						if e.args.len == 1 {
							p.ignore_usage(p.require_ref)
							return p.maybe_transpose_if_expr_chain(e.args[0], fn (arg js_ast.Expr) {
								mut str_13, ok_71 := arg.data
								if ok {
									if p.is_control_flow_dead {
										return js_ast.Expr{
											loc:  expr.loc
											data: js_ast.en_ull_shared
										}
									}
									mut import_record_index_2 := p.add_import_record(ast.import_require,
										p.source.range_of_string(arg.loc), helpers.utf_16_to_string(str.value),
										nil, 0)
									if p.fn_or_arrow_data_visit.try_body_count != 0 {
										mut record_3 := &p.import_records[import_record_index]
										record.flags |= ast.handles_import_errors
										record.error_handler_loc = p.fn_or_arrow_data_visit.try_catch_loc
									}
									p.import_records_for_current_part << import_record_index
									if p.options.mode != config.mode_bundle
										&& p.options.output_format == config.format_esm_odule
										&& !omit_warnings {
										mut r_15 := js_lexer.range_of_identifier(p.source,
											e.target.loc)
										p.log.add_id(logger.msg_id_js_unsupported_require_call,
											logger.warning, &p.tracker, r, 'Converting "require" to "esm" is currently not supported')
									}
									return js_ast.Expr{
										loc:  expr.loc
										data: &js_ast.ERequireString{
											import_record_index: import_record_index
											close_paren_loc:     e.close_paren_loc
										}
									}
								}
								if p.options.mode == config.mode_bundle {
									mut value_11 := p.handle_glob_pattern(arg, ast.import_require,
										'globRequire', nil)
									if value.data != nil {
										return value
									}
								}
								mut r_16 := js_lexer.range_of_identifier(p.source, e.target.loc)
								p.log.add_id(logger.msg_id_js_unsupported_require_call,
									logger.debug, &p.tracker, r, 'This call to "require" will not be bundled because the argument is not a string literal')
								return js_ast.Expr{
									loc:  expr.loc
									data: &js_ast.ECall{
										target:          p.value_to_substitute_for_require(e.target.loc)
										args:            [arg]
										close_paren_loc: e.close_paren_loc
									}
								}
							}), ExprOut{}
						} else {
							mut r_17 := js_lexer.range_of_identifier(p.source, e.target.loc)
							p.log.add_idw_ith_notes(logger.msg_id_js_unsupported_require_call,
								logger.debug, &p.tracker, r, strconv.v_sprintf('This call to "require" will not be bundled because it has %d arguments',
								e.args.len), [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
							])
						}
						return js_ast.Expr{
							loc:  expr.loc
							data: &js_ast.ECall{
								target:          p.value_to_substitute_for_require(e.target.loc)
								args:            e.args
								close_paren_loc: e.close_paren_loc
							}
						}, ExprOut{}
					}
				}
			}
			out = ExprOut{
				child_contains_optional_chain: contains_optional_chain
				this_arg_func:                 out.this_arg_func
				this_arg_wrap_func:            out.this_arg_wrap_func
			}
			if !in_.has_chain_parent {
				out.this_arg_func = nil
				out.this_arg_wrap_func = nil
			}
			return expr, out
		}
		js_ast.ENew {
			mut has_spread_4 := false
			e.target = p.visit_expr(e.target)
			p.warn_about_import_namespace_call(e.target, expr_kind_new)
			for i_6, arg_10 in e.args {
				arg = p.visit_expr(arg)
				_, ok_72 := arg.data
				if ok {
					has_spread = true
				}
				e.args[i] = arg
			}
			if p.options.minify_syntax && has_spread {
				e.args = js_ast.inline_spreads_of_array_literals(e.args)
			}
			p.maybe_mark_known_global_constructor_as_pure(e)
		}
		js_ast.EArrow {
			mut nameToKeep := 0
			if p.name_to_keep_is_for == e {
				name_to_keep = p.name_to_keep
			}
			if e.prefer_expr && e.args.len == 1 && e.args[0].default_or_nil.data == nil && e.body.block.stmts.len == 1 {
				_, ok_73 := e.args[0].binding.data
				if ok {
					mut stmt, ok_74 := e.body.block.stmts[0].data
					if ok {
						mut binary_1, ok_75 := stmt.value_or_nil.data
						if ok && (binary.op == js_ast.bin_op_logical_and
							|| binary.op == js_ast.bin_op_logical_or) {
							p.suspicious_logical_operator_inside_arrow = binary
						}
					}
				}
			}
			mut async_arrow_needs_to_be_lowered := e.is_async && p.options.unsupported_jsf_eatures.has(compat.async_await)
			mut old_fn_or_arrow_data := p.fn_or_arrow_data_visit
			p.fn_or_arrow_data_visit = FnOrArrowDataVisit{
				is_arrow:                           true
				is_async:                           e.is_async
				should_lower_super_property_access:
					old_fn_or_arrow_data.should_lower_super_property_access
					|| async_arrow_needs_to_be_lowered
			}
			mut old_inside_async_arrow_fn := p.fn_only_data_visit.is_inside_async_arrow_fn
			if e.is_async {
				p.fn_only_data_visit.is_inside_async_arrow_fn = true
			}
			p.push_scope_for_visit_pass(js_ast.scope_function_args, expr.loc)
			p.visit_args(e.args, VisitArgsOpts{
				has_rest_arg:                e.has_rest_arg
				body:                        e.body.block.stmts
				is_unique_formal_parameters: true
			})
			p.push_scope_for_visit_pass(js_ast.scope_function_body, e.body.loc)
			e.body.block.stmts = p.visit_stmts_and_prepend_temp_refs(e.body.block.stmts,
				PrependTempRefsOpts{
				kind: stmts_fn_body
			})
			p.pop_scope()
			p.lower_function(&e.is_async, nil, &e.args, e.body.loc, &e.body.block, &e.prefer_expr,
				&e.has_rest_arg, true)
			p.pop_scope()
			if p.options.minify_syntax && e.body.block.stmts.len == 1 {
				mut s_1, ok_76 := e.body.block.stmts[0].data
				if ok {
					if s.value_or_nil.data == nil {
						e.body.block.stmts = []
						{}
					} else {
						e.prefer_expr = true
					}
				}
			}
			p.fn_only_data_visit.is_inside_async_arrow_fn = old_inside_async_arrow_fn
			p.fn_or_arrow_data_visit = old_fn_or_arrow_data
			if p.options.unsupported_jsf_eatures.has(compat.arrow) {
				expr.data = &js_ast.EFunction{
					fn_: js_ast.Fn{
						args:          e.args
						body:          e.body
						arguments_ref: ast.invalid_ref
						is_async:      e.is_async
						has_rest_arg:  e.has_rest_arg
					}
				}
			}
			if p.options.keep_names && name_to_keep != '' {
				expr = p.keep_expr_symbol_name(expr, name_to_keep)
			}
		}
		js_ast.EFunction {
			if p.name_to_keep_is_for == e {
				name_to_keep = p.name_to_keep
			}
			p.visit_fn(&e.fn_, expr.loc, VisitFnOpts{
				is_method:                 in_.is_method
				is_derived_class_ctor:     e == p.prop_derived_ctor_value
				is_lowered_private_method: in_.is_lowered_private_method
			})
			mut name_5 := e.fn_.name
			if p.options.minify_syntax && !p.current_scope.contains_direct_eval && name != nil
				&& p.symbols[name.ref.inner_index].use_count_estimate == 0 {
				e.fn_.name = nil
			}
			if p.options.keep_names && (!in_.is_method || in_.is_lowered_private_method) {
				if name != nil {
					expr = p.keep_expr_symbol_name(expr, p.symbols[name.ref.inner_index].original_name)
				} else if name_to_keep != '' {
					expr = p.keep_expr_symbol_name(expr, name_to_keep)
				}
			}
		}
		js_ast.EClass {
			if p.name_to_keep_is_for == e {
				name_to_keep = p.name_to_keep
			}
			mut result_4 := p.visit_class(expr.loc, &e.class, ast.invalid_ref, name_to_keep)
			_, expr = p.lower_class(js_ast.Stmt{}, expr, result, name_to_keep)
			if result.can_be_removed_if_unused {
				expr.data = &js_ast.EAnnotation{
					value: expr
					flags: js_ast.can_be_removed_if_unused_flag
				}
			}
		}
		else {
			panic(strconv.v_sprintf('Unexpected expression of type %T', expr.data))
		}
	}
	return expr, ExprOut{}
}

// This exists to handle very deeply-nested ASTs. For example, the "grapheme-splitter"
// package contains this monstrosity:
//
//	if (
//	  (0x0300 <= code && code <= 0x036F) ||
//	  (0x0483 <= code && code <= 0x0487) ||
//	  (0x0488 <= code && code <= 0x0489) ||
//	  (0x0591 <= code && code <= 0x05BD) ||
//	  ... many hundreds of lines later ...
//	) {
//	  return;
//	}
//
// If "checkAndPrepare" returns non-nil, then the return value is the final
// expression. Otherwise, the final expression can be obtained by manually
// visiting the left child and then calling "visitRightAndFinish":
//
//	if result := v.checkAndPrepare(p); result.Data != nil {
//	  return result
//	}
//	v.e.Left, _ = p.visitExprInOut(v.e.Left, v.leftIn)
//	return v.visitRightAndFinish(p)
//
// This code is convoluted this way so that we can use our own stack on the
// heap instead of the call stack when there are additional levels of nesting.
// Before this transformation, the code previously looked something like this:
//
//	... The code in "checkAndPrepare" ...
//	e.Left, _ = p.visitExprInOut(e.Left, in)
//	... The code in "visitRightAndFinish" ...
//
// If this code is still confusing, it may be helpful to look back in git
// history at the commit that introduced this transformation.
//
// Go normally has growable call stacks so this code transformation normally
// doesn't do anything, but WebAssembly doesn't allow stack pointer manipulation
// so Go's WebAssembly implementation doesn't support growable call stacks and
// is therefore vulnerable to stack overflow. So this code transformation is
// only really relevant for esbuild's WebAssembly-based API.
struct binaryExprVisitor {
pub mut:
	// Inputs
	e   &js_ast.EBinary = unsafe { nil }
	loc logger.Loc
	in_ exprIn
	// Input for visiting the left child
	left_in exprIn
	// "Local variables" passed from "checkAndPrepare" to "visitRightAndFinish"
	is_stmt_expr                                   bool
	old_silence_warning_about_this_being_undefined bool
}

fn (v &BinaryExprVisitor) check_and_prepare(p &Parser) js_ast.Expr {
	mut e := v.e
	mut private, ok := e.left.data
	if ok && e.op == js_ast.bin_op_in {
		mut name := p.load_name_from_ref(private.ref)
		mut result := p.find_symbol(e.left.loc, name)
		private.ref = result.ref
		mut symbol := &p.symbols[result.ref.inner_index]
		if !symbol.kind.is_private() {
			mut r := logger.Range{
				loc: e.left.loc
				len: i32(name.len)
			}
			p.log.add_error(&p.tracker, r, strconv.v_sprintf('Private name %q must be declared in an enclosing class',
				name))
		}
		e.right = p.visit_expr(e.right)
		if p.private_symbol_needs_to_be_lowered(private) {
			return p.lower_private_brand_check(e.right, v.loc, private)
		}
		return js_ast.Expr{
			loc:  v.loc
			data: e
		}
	}
	v.is_stmt_expr = e == p.stmt_expr_value
	v.old_silence_warning_about_this_being_undefined = p.fn_only_data_visit.silence_message_about_this_being_undefined
	_, ok_1 := e.left.data
	if ok && e.op == js_ast.bin_op_logical_and {
		p.fn_only_data_visit.silence_message_about_this_being_undefined = true
	}
	v.left_in = ExprIn{
		assign_target:                  e.op.binary_assign_target()
		should_mangle_strings_as_props: e.op == js_ast.bin_op_in
	}
	return js_ast.Expr{}
}

fn (v &BinaryExprVisitor) visit_right_and_finish(p &Parser) js_ast.Expr {
	mut e := v.e
	match e.op {
		js_ast.bin_op_logical_or {
			mut boolean, _, ok := js_ast.to_boolean_with_side_effects(e.left.data)
			if ok && boolean {
				mut old := p.is_control_flow_dead
				p.is_control_flow_dead = true
				e.right = p.visit_expr(e.right)
				p.is_control_flow_dead = old
			} else {
				e.right = p.visit_expr(e.right)
			}
		}
		js_ast.bin_op_logical_and {
			mut boolean_1, _, ok_1 := js_ast.to_boolean_with_side_effects(e.left.data)
			if ok && !boolean {
				mut old_1 := p.is_control_flow_dead
				p.is_control_flow_dead = true
				e.right = p.visit_expr(e.right)
				p.is_control_flow_dead = old
			} else {
				e.right = p.visit_expr(e.right)
			}
		}
		js_ast.bin_op_nullish_coalescing {
			mut is_null_or_undefined, _, ok_2 := js_ast.to_null_or_undefined_with_side_effects(e.left.data)
			if ok && !is_null_or_undefined {
				mut old_2 := p.is_control_flow_dead
				p.is_control_flow_dead = true
				e.right = p.visit_expr(e.right)
				p.is_control_flow_dead = old
			} else {
				e.right = p.visit_expr(e.right)
			}
		}
		js_ast.bin_op_comma {
			e.right, _ = p.visit_expr_in_out(e.right, ExprIn{
				should_mangle_strings_as_props: v.in_.should_mangle_strings_as_props
			})
		}
		js_ast.bin_op_assign, js_ast.bin_op_logical_or_assign, js_ast.bin_op_logical_and_assign,
		js_ast.bin_op_nullish_coalescing_assign {
			mut id, ok_3 := e.left.data
			if ok {
				p.name_to_keep = p.symbols[id.ref.inner_index].original_name
				p.name_to_keep_is_for = e.right.data
			}
			e.right = p.visit_expr(e.right)
		}
		else {
			e.right = p.visit_expr(e.right)
		}
	}
	p.fn_only_data_visit.silence_message_about_this_being_undefined = v.old_silence_warning_about_this_being_undefined
	if p.options.minify_syntax {
		match e.op {
			js_ast.bin_op_loose_eq, js_ast.bin_op_loose_ne, js_ast.bin_op_strict_eq,
			js_ast.bin_op_strict_ne {
				if js_ast.is_primitive_literal(e.left.data)
					&& !js_ast.is_primitive_literal(e.right.data) {
					e.left, e.right = e.right, e.left
				}
			}
		}
	}
	if p.should_fold_type_script_constant_expressions || p.options.minify_syntax
		&& js_ast.should_fold_binary_operator_when_minifying(e) {
		mut result := js_ast.fold_binary_operator(v.loc, e)
		if result.data != nil {
			return result
		}
	}
	match e.op {
		js_ast.bin_op_comma {
			if p.options.minify_syntax {
				e.left = p.ast_helpers.simplify_unused_expr(e.left, p.options.unsupported_jsf_eatures)
				if e.left.data == nil {
					return e.right
				}
			}
		}
		js_ast.bin_op_loose_eq {
			mut result_1, ok_4 := js_ast.check_equality_if_no_side_effects(e.left.data,
				e.right.data, js_ast.loose_equality)
			if ok {
				return js_ast.Expr{
					loc:  v.loc
					data: &js_ast.EBoolean{
						value: result
					}
				}
			}
			mut after_op_loc := loc_after_op(e)
			if !p.warn_about_equality_check('==', e.left, after_op_loc) {
				p.warn_about_equality_check('==', e.right, after_op_loc)
			}
			p.warn_about_typeof_and_string(e.left, e.right, check_both_orders)
			if p.options.minify_syntax {
				_, ok_5 := e.left.data
				if ok {
					e.left.data = js_ast.en_ull_shared
				} else {
					// LOOL0
					_, ok_6 := e.right.data
					if ok {
						e.right.data = js_ast.en_ull_shared
					}
				}
				mut result_2, ok_7 := js_ast.maybe_simplify_equality_comparison(v.loc,
					e, p.options.unsupported_jsf_eatures)
				if ok {
					return result
				}
			}
		}
		js_ast.bin_op_strict_eq {
			mut result_3, ok_8 := js_ast.check_equality_if_no_side_effects(e.left.data,
				e.right.data, js_ast.strict_equality)
			if ok {
				return js_ast.Expr{
					loc:  v.loc
					data: &js_ast.EBoolean{
						value: result
					}
				}
			}
			mut after_op_loc_1 := loc_after_op(e)
			if !p.warn_about_equality_check('===', e.left, after_op_loc) {
				p.warn_about_equality_check('===', e.right, after_op_loc)
			}
			p.warn_about_typeof_and_string(e.left, e.right, check_both_orders)
			if p.options.minify_syntax {
				if js_ast.can_change_strict_to_loose(e.left, e.right) {
					e.op = js_ast.bin_op_loose_eq
				}
				mut result_4, ok_9 := js_ast.maybe_simplify_equality_comparison(v.loc,
					e, p.options.unsupported_jsf_eatures)
				if ok {
					return result
				}
			}
		}
		js_ast.bin_op_loose_ne {
			mut result_5, ok_10 := js_ast.check_equality_if_no_side_effects(e.left.data,
				e.right.data, js_ast.loose_equality)
			if ok {
				return js_ast.Expr{
					loc:  v.loc
					data: &js_ast.EBoolean{
						value: !result
					}
				}
			}
			mut after_op_loc_2 := loc_after_op(e)
			if !p.warn_about_equality_check('!=', e.left, after_op_loc) {
				p.warn_about_equality_check('!=', e.right, after_op_loc)
			}
			p.warn_about_typeof_and_string(e.left, e.right, check_both_orders)
			if p.options.minify_syntax {
				_, ok_11 := e.left.data
				if ok {
					e.left.data = js_ast.en_ull_shared
				} else {
					// LOOL0
					_, ok_12 := e.right.data
					if ok {
						e.right.data = js_ast.en_ull_shared
					}
				}
				mut result_6, ok_13 := js_ast.maybe_simplify_equality_comparison(v.loc,
					e, p.options.unsupported_jsf_eatures)
				if ok {
					return result
				}
			}
		}
		js_ast.bin_op_strict_ne {
			mut result_7, ok_14 := js_ast.check_equality_if_no_side_effects(e.left.data,
				e.right.data, js_ast.strict_equality)
			if ok {
				return js_ast.Expr{
					loc:  v.loc
					data: &js_ast.EBoolean{
						value: !result
					}
				}
			}
			mut after_op_loc_3 := loc_after_op(e)
			if !p.warn_about_equality_check('!==', e.left, after_op_loc) {
				p.warn_about_equality_check('!==', e.right, after_op_loc)
			}
			p.warn_about_typeof_and_string(e.left, e.right, check_both_orders)
			if p.options.minify_syntax {
				if js_ast.can_change_strict_to_loose(e.left, e.right) {
					e.op = js_ast.bin_op_loose_ne
				}
				mut result_8, ok_15 := js_ast.maybe_simplify_equality_comparison(v.loc,
					e, p.options.unsupported_jsf_eatures)
				if ok {
					return result
				}
			}
		}
		js_ast.bin_op_nullish_coalescing {
			mut is_null_or_undefined_1, side_effects, ok_16 := js_ast.to_null_or_undefined_with_side_effects(e.left.data)
			if ok {
				if !js_ast.is_primitive_literal(e.left.data) {
					mut which := 0
					mut leftIsNullOrUndefined := 0
					mut leftIsReturned := 0
					if !is_null_or_undefined {
						which = 'left'
						left_is_null_or_undefined = 'never'
						left_is_returned = 'always'
					} else {
						which = 'right'
						left_is_null_or_undefined = 'always'
						left_is_returned = 'never'
					}
					mut kind := logger.warning
					if p.suppress_warnings_about_weird_code {
						kind = logger.debug
					}
					mut r_op := p.source.range_of_operator_before(e.right.loc, '??')
					mut r_left := logger.Range{
						loc: e.left.loc
						len: p.source.loc_before_whitespace(r_op.loc).start - e.left.loc.start
					}
					p.log.add_idw_ith_notes(logger.msg_id_js_suspicious_nullish_coalescing,
						kind, &p.tracker, r_op, strconv.v_sprintf('The "??" operator here will always return the %s operand',
						which), [
						p.tracker.msg_data(r_left, strconv.v_sprintf('The left operand of the "??" operator here will %s be null or undefined, so it will %s be returned. This usually indicates a bug in your code:',
							left_is_null_or_undefined, left_is_returned)),
					])
				}
				if !is_null_or_undefined {
					return e.left
				} else if side_effects == js_ast.no_side_effects {
					return e.right
				}
			}
			if p.options.minify_syntax {
				mut right, ok_17 := e.right.data
				if ok && right.op == js_ast.bin_op_nullish_coalescing {
					e.left = js_ast.join_with_left_associative_op(js_ast.bin_op_nullish_coalescing,
						e.left, right.left)
					e.right = right.right
				}
			}
			if p.options.unsupported_jsf_eatures.has(compat.nullish_coalescing) {
				return p.lower_nullish_coalescing(v.loc, e.left, e.right)
			}
		}
		js_ast.bin_op_logical_or {
			mut boolean_2, side_effects_1, ok_18 := js_ast.to_boolean_with_side_effects(e.left.data)
			if ok {
				if e == p.suspicious_logical_operator_inside_arrow {
					mut arrow_loc := p.source.range_of_operator_before(v.loc, '=>')
					if arrow_loc.loc.start + 2 == p.source.loc_before_whitespace(v.loc).start {
						if boolean {
							which = 'left'
						} else {
							which = 'right'
						}
						mut kind_1 := logger.warning
						if p.suppress_warnings_about_weird_code {
							kind = logger.debug
						}
						mut note := p.tracker.msg_data(arrow_loc, 'The "=>" symbol creates an arrow function expression in JavaScript. Did you mean to use the greater-than-or-equal-to operator ">=" here instead?')
						note.location.suggestion = '>='
						mut r_op_1 := p.source.range_of_operator_before(e.right.loc, '||')
						p.log.add_idw_ith_notes(logger.msg_id_js_suspicious_logical_operator,
							kind, &p.tracker, r_op, strconv.v_sprintf('The "||" operator here will always return the %s operand',
							which), [note])
					}
				}
				if boolean {
					return e.left
				} else if side_effects == js_ast.no_side_effects {
					return e.right
				}
			}
			if p.options.minify_syntax {
				mut right_1, ok_19 := e.right.data
				if ok && right.op == js_ast.bin_op_logical_or {
					e.left = js_ast.join_with_left_associative_op(js_ast.bin_op_logical_or,
						e.left, right.left)
					e.right = right.right
				}
				mut left, right_2, ok_20 := js_ast.is_binary_null_and_undefined(e.left,
					e.right, js_ast.bin_op_strict_eq)
				if ok {
					e.op = js_ast.bin_op_loose_eq
					e.left = left
					e.right = right
				}
			}
		}
		js_ast.bin_op_logical_and {
			mut boolean_3, side_effects_2, ok_21 := js_ast.to_boolean_with_side_effects(e.left.data)
			if ok {
				if e == p.suspicious_logical_operator_inside_arrow {
					mut arrow_loc_1 := p.source.range_of_operator_before(v.loc, '=>')
					if arrow_loc.loc.start + 2 == p.source.loc_before_whitespace(v.loc).start {
						if !boolean {
							which = 'left'
						} else {
							which = 'right'
						}
						mut kind_2 := logger.warning
						if p.suppress_warnings_about_weird_code {
							kind = logger.debug
						}
						mut note_1 := p.tracker.msg_data(arrow_loc, 'The "=>" symbol creates an arrow function expression in JavaScript. Did you mean to use the greater-than-or-equal-to operator ">=" here instead?')
						note.location.suggestion = '>='
						mut r_op_2 := p.source.range_of_operator_before(e.right.loc, '&&')
						p.log.add_idw_ith_notes(logger.msg_id_js_suspicious_logical_operator,
							kind, &p.tracker, r_op, strconv.v_sprintf('The "&&" operator here will always return the %s operand',
							which), [note])
					}
				}
				if !boolean {
					return e.left
				} else if side_effects == js_ast.no_side_effects {
					return e.right
				}
			}
			if p.options.minify_syntax {
				mut right_3, ok_22 := e.right.data
				if ok && right.op == js_ast.bin_op_logical_and {
					e.left = js_ast.join_with_left_associative_op(js_ast.bin_op_logical_and,
						e.left, right.left)
					e.right = right.right
				}
				mut left_1, right_4, ok_23 := js_ast.is_binary_null_and_undefined(e.left,
					e.right, js_ast.bin_op_strict_ne)
				if ok {
					e.op = js_ast.bin_op_loose_ne
					e.left = left
					e.right = right
				}
			}
		}
		js_ast.bin_op_add {
			mut result_9 := js_ast.fold_string_addition(e.left, e.right, js_ast.string_addition_normal)
			if result.data != nil {
				return result
			}
			mut left_2, ok_24 := e.left.data
			if ok && left.op == js_ast.bin_op_add {
				mut result_10 := js_ast.fold_string_addition(left.right, e.right, js_ast.string_addition_with_nested_left)
				if result.data != nil {
					return js_ast.Expr{
						loc:  v.loc
						data: &js_ast.EBinary{
							op:    left.op
							left:  left.left
							right: result
						}
					}
				}
			}
		}
		js_ast.bin_op_pow {
			if p.options.unsupported_jsf_eatures.has(compat.exponent_operator) {
				return p.call_runtime(v.loc, '__pow', [e.left, e.right])
			}
		}
		js_ast.bin_op_assign {
			mut target, loc, private := p.extract_private_index(e.left)
			if private != nil {
				return p.lower_private_set(target, loc, private, e.right)
			}
			mut property := p.extract_super_property(e.left)
			if property.data != nil {
				return p.lower_super_property_set(e.left.loc, property, e.right)
			}
			if v.in_.assign_target == js_ast.assign_target_none {
				mut mode := obj_rest_must_return_init_expr
				if v.is_stmt_expr {
					mode = obj_rest_return_value_is_unused
				}
				mut result_11, ok_25 := p.lower_assign(e.left, e.right, mode)
				if ok {
					return result
				}
				if p.options.mode != config.mode_pass_through
					&& p.is_file_considered_to_have_esme_xports && !p.is_control_flow_dead {
					mut dot, ok_26 := e.left.data
					if ok {
						mut name := 0
						mut target_1 := dot.target.data
						match target {
							js_ast.EIdentifier {
								mut symbol := &p.symbols[target.ref.inner_index]
								if symbol.kind == ast.symbol_unbound
									&& (symbol.original_name == 'module' && dot.name == 'exports'
									|| symbol.original_name == 'exports')
									&& !symbol.flags.has(ast.did_warn_about_common_jsi_n_esm) {
									name = symbol.original_name
									loc = dot.target.loc
									symbol.flags |= ast.did_warn_about_common_jsi_n_esm
								}
							}
							js_ast.EDot {
								if target.name == 'exports' {
									mut id_1, ok_27 := target.target.data
									if ok {
										mut symbol_1 := &p.symbols[id.ref.inner_index]
										if symbol.kind == ast.symbol_unbound
											&& symbol.original_name == 'module'
											&& !symbol.flags.has(ast.did_warn_about_common_jsi_n_esm) {
											name = symbol.original_name
											loc = target.target.loc
											symbol.flags |= ast.did_warn_about_common_jsi_n_esm
										}
									}
								}
							}
						}
						if name != '' {
							mut kind_3 := logger.warning
							if p.suppress_warnings_about_weird_code {
								kind = logger.debug
							}
							mut why, notes := p.why_esm_odule()
							if why == why_esmt_ype_module_package_json {
								mut text := 'Node\'s package format requires that CommonJS files in a "type": "module" package use the ".cjs" file extension.'
								if p.options.ts.parse {
									text += ' If you are using TypeScript, you can use the ".cts" file extension with esbuild instead.'
								}
								notes << logger.MsgData{
									text: text
								}
							}
							p.log.add_idw_ith_notes(logger.msg_id_js_common_jsv_ariable_in_esm,
								kind, &p.tracker, js_lexer.range_of_identifier(p.source,
								loc), strconv.v_sprintf('The CommonJS %q variable is treated as a global variable in an ECMAScript module and may not work as expected',
								name), notes)
						}
					}
				}
			}
		}
		js_ast.bin_op_add_assign {
			mut result_12 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_add, e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_sub_assign {
			mut result_13 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_sub, e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_mul_assign {
			mut result_14 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_mul, e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_div_assign {
			mut result_15 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_div, e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_rem_assign {
			mut result_16 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_rem, e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_pow_assign {
			if p.options.unsupported_jsf_eatures.has(compat.exponent_operator) {
				return p.lower_exponentiation_assignment_operator(v.loc, e)
			}
			mut result_17 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_pow, e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_shl_assign {
			mut result_18 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_shl, e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_shr_assign {
			mut result_19 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_shr, e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_us_hr_assign {
			mut result_20 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_us_hr, e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_bitwise_or_assign {
			mut result_21 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_bitwise_or,
				e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_bitwise_and_assign {
			mut result_22 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_bitwise_and,
				e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_bitwise_xor_assign {
			mut result_23 := p.maybe_lower_set_bin_op(e.left, js_ast.bin_op_bitwise_xor,
				e.right)
			if result.data != nil {
				return result
			}
		}
		js_ast.bin_op_nullish_coalescing_assign {
			mut value, ok_28 := p.lower_nullish_coalescing_assignment_operator(v.loc,
				e)
			if ok {
				return value
			}
		}
		js_ast.bin_op_logical_and_assign {
			mut value_1, ok_29 := p.lower_logical_assignment_operator(v.loc, e, js_ast.bin_op_logical_and)
			if ok {
				return value
			}
		}
		js_ast.bin_op_logical_or_assign {
			mut value_2, ok_30 := p.lower_logical_assignment_operator(v.loc, e, js_ast.bin_op_logical_or)
			if ok {
				return value
			}
		}
	}
	if p.options.minify_syntax && e.op != js_ast.bin_op_comma {
		mut comma, ok_31 := e.left.data
		if ok && comma.op == js_ast.bin_op_comma {
			return js_ast.join_with_comma(comma.left, js_ast.Expr{
				loc:  comma.right.loc
				data: &js_ast.EBinary{
					op:    e.op
					left:  comma.right
					right: e.right
				}
			})
		}
	}
	return js_ast.Expr{
		loc:  v.loc
		data: e
	}
}

fn remap_expr_locs_in_json(expr &js_ast.Expr, table []logger.StringInJSTableEntry) {
	expr.loc = logger.remap_string_in_jsl_oc(table, expr.loc)
	mut e := expr.data
	match e {
		js_ast.EArray {
			e.close_bracket_loc = logger.remap_string_in_jsl_oc(table, e.close_bracket_loc)
			for i, _ in e.items {
				remap_expr_locs_in_json(&e.items[i], table)
			}
		}
		js_ast.EObject {
			e.close_brace_loc = logger.remap_string_in_jsl_oc(table, e.close_brace_loc)
			for i_1, _ in e.properties {
				remap_expr_locs_in_json(&e.properties[i].key, table)
				remap_expr_locs_in_json(&e.properties[i].value_or_nil, table)
			}
		}
	}
}

fn (p &Parser) handle_glob_pattern(expr js_ast.Expr, kind ast.ImportKind, prefix string, assert_or_with &ast.ImportAssertOrWith) js_ast.Expr {
	mut pattern, approximate_range := p.glob_pattern_from_expr(expr)
	if pattern == nil {
		return js_ast.Expr{}
	}
	mut last := 0
	mut parts := []helpers.GlobPart{}
	for _, part in pattern {
		if part.is_wildcard {
			if last.wildcard == helpers.glob_none {
				if !last.prefix.has_suffix('/') {
					last.wildcard = helpers.glob_all_except_slash
				} else {
					last.wildcard = helpers.glob_all_including_slash
					parts << last
					last = helpers.GlobPart{
						prefix:   '/'
						wildcard: helpers.glob_all_except_slash
					}
				}
			}
		} else if part.text != '' {
			if last.wildcard != helpers.glob_none {
				parts << last
				last = helpers.GlobPart{}
			}
			last.prefix += part.text
		}
	}
	parts << last
	if parts.len == 1 && parts[0].wildcard == helpers.glob_none {
		return js_ast.Expr{}
	}
	mut prefix_1 := parts[0].prefix
	if !prefix.has_prefix('./') && !prefix.has_prefix('../') {
		return js_ast.Expr{}
	}
	mut ref := ast.invalid_ref
	mut ref_1 := ast.invalid_ref
	if ref == ast.invalid_ref && prefix != '' {
		mut sb := strings.Builder
		{
		}
		sb.write_string(prefix)
		for _, part_1 in parts {
			mut gap := true
			for _, c in part.prefix {
				if !js_ast.is_identifier_continue(c) {
					gap = true
				}
				else {
					if gap {
						sb.write_byte(`_`)
						gap = false
					}
					sb.write_rune(c)
				}
			}
		}
		mut name := sb.string()
		ref = p.new_symbol(ast.symbol_other, name)
		p.module_scope.generated << ref
		p.glob_pattern_imports << GlobPatternImport{
			assert_or_with:    assert_or_with
			parts:             parts
			name:              name
			approximate_range: approximate_range
			ref:               ref
			kind:              kind
		}
	}
	p.record_usage(ref)
	return js_ast.Expr{
		loc:  expr.loc
		data: &js_ast.ECall{
			target: js_ast.Expr{
				loc:  expr.loc
				data: &js_ast.EIdentifier{
					ref: ref
				}
			}
			args:   [expr]
		}
	}
}

struct globPart {
pub mut:
	text        string
	is_wildcard bool
}

fn (p &Parser) glob_pattern_from_expr(expr js_ast.Expr) ([]globPart, logger.Range) {
	mut e := expr.data
	match e {
		js_ast.EString {
			return [
				globPart( // UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"),
			], p.source.range_of_string(expr.loc)
		}
		js_ast.ETemplate {
			if e.tag_or_nil.data != nil {
				break
			}
			mut pattern := []globPart{len: 0, cap: 1 + 2 * e.Parts.len}
			pattern << GlobPart{
				text: helpers.utf_16_to_string(e.head_cooked)
			}
			for _, part in e.parts {
				mut part_pattern, _ := p.glob_pattern_from_expr(part.value)
				if part_pattern != nil {
					pattern << part_pattern
				} else {
					pattern << GlobPart{
						is_wildcard: true
					}
				}
				pattern << GlobPart{
					text: helpers.utf_16_to_string(part.tail_cooked)
				}
			}
			if e.parts.len == 0 {
				return pattern, p.source.range_of_string(expr.loc)
			}
			mut text := p.source.contents
			mut template_range := logger.Range{
				loc: e.head_loc
			}
			for i := e.parts[e.parts.len - 1].tail_loc.start; i < i32(text.len); i++ {
				mut c := text[i]
				if c == `\`` {
					template_range.len = i + 1 - template_range.loc.start
					break
				} else if c == `\\` {
					i += isize(1)
				}
			}
			return pattern, template_range
		}
		js_ast.EBinary {
			if e.op != js_ast.bin_op_add {
				break
			}
			mut pattern_1, left_range := p.glob_pattern_from_expr(e.left)
			if pattern == nil {
				break
			}
			mut right_pattern, right_range := p.glob_pattern_from_expr(e.right)
			if right_pattern != nil {
				pattern << right_pattern
				left_range.len = right_range.end() - left_range.loc.start
				return pattern, left_range
			}
			pattern << GlobPart{
				is_wildcard: true
			}
			mut right := e.right.data
			match right {
				js_ast.EIdentifier {
					left_range.len = js_lexer.range_of_identifier(p.source, e.right.loc).end() - left_range.loc.start
				}
				js_ast.ECall {
					if right.close_paren_loc.start > 0 {
						left_range.len = right.close_paren_loc.start + 1 - left_range.loc.start
					}
				}
			}
			return pattern, left_range
		}
	}
	return nil, logger.Range{}
}

fn (p &Parser) convert_symbol_use_to_call(ref ast.Ref, is_single_non_spread_arg_call bool) {
	mut use := p.symbol_uses[ref]
	use.count_estimate--
	if use.count_estimate == 0 {
		p.symbol_uses.delete(ref)
	} else {
		p.symbol_uses[ref] = use
	}
	if p.symbol_call_uses == nil {
		p.symbol_call_uses = map[ast.Ref]js_ast.SymbolCallUse{}
	}
	mut call_use := p.symbol_call_uses[ref]
	call_use.call_count_estimate++
	if is_single_non_spread_arg_call {
		call_use.single_arg_non_spread_call_count_estimate++
	}
	p.symbol_call_uses[ref] = call_use
}

fn (p &Parser) warn_about_import_namespace_call(target js_ast.Expr, kind importNamespaceCallKind) {
	if p.options.output_format != config.format_preserve {
		mut id, ok := target.data
		if ok && p.import_items_for_namespace[id.ref].entries != nil {
			mut key := ImportNamespaceCall{
				ref:  id.ref
				kind: kind
			}
			if p.import_namespace_ccm_ap == nil {
				p.import_namespace_ccm_ap = map[ImportNamespaceCall]Bool{}
			}
			_, ok_1 := p.import_namespace_ccm_ap[key]
			if ok {
				return
			}
			p.import_namespace_ccm_ap[key] = true
			mut r := js_lexer.range_of_identifier(p.source, target.loc)
			mut notes := []logger.MsgData{}
			mut name := p.symbols[id.ref.inner_index].original_name
			mut member, ok_2 := p.module_scope.members[name]
			if ok && member.ref == id.ref {
				mut star := p.source.range_of_operator_before(member.loc, '*')
				if star.len > 0 {
					mut as_ := p.source.range_of_operator_before(member.loc, 'as')
					if as_.len > 0 && as_.loc.start > star.loc.start {
						mut note := p.tracker.msg_data(logger.Range{
							loc: star.loc
							len: js_lexer.range_of_identifier(p.source, member.loc).end() - star.loc.start
						}, strconv.v_sprintf('Consider changing %q to a default import instead:',
							name))
						note.location.suggestion = name
						notes << note
					}
				}
			}
			if p.options.ts.parse {
				notes << logger.MsgData{
					text:
						'Make sure to enable TypeScript\'s "esModuleInterop" setting so that TypeScript\'s type checker generates an error when you try to do this. ' +
						'You can read more about this setting here: https://www.typescriptlang.org/tsconfig#esModuleInterop'
				}
			}
			mut verb := 0
			mut where := 0
			mut noun := 0
			match kind {
				expr_kind_call {
					verb = 'Calling'
					noun = 'function'
				}
				expr_kind_new {
					verb = 'Constructing'
					noun = 'constructor'
				}
				expr_kind_jsxt_ag {
					verb = 'Using'
					where = ' in a JSX expression'
					noun = 'component'
				}
			}
			p.log.add_idw_ith_notes(logger.msg_id_js_call_import_namespace, logger.warning,
				&p.tracker, r, strconv.v_sprintf("%s %q%s will crash at run-time because it's an import namespace object, not a %s",
				verb, p.symbols[id.ref.inner_index].original_name, where, noun), notes)
		}
	}
}

fn (p &Parser) maybe_mark_known_global_constructor_as_pure(e &js_ast.ENew) {
	mut id, ok := e.target.data
	if ok {
		mut symbol := p.symbols[id.ref.inner_index]
		if symbol.kind == ast.symbol_unbound {
			match symbol.original_name {
				'WeakSet', 'WeakMap' {
					mut n := e.args.len
					if n == 0 {
						e.can_be_unwrapped_if_unused = true
						break
					}
					if n == 1 {
						mut arg := e.args[0].data
						match arg {
							js_ast.ENull, js_ast.EUndefined {
								e.can_be_unwrapped_if_unused = true
							}
							js_ast.EArray {
								if arg.items.len == 0 {
									e.can_be_unwrapped_if_unused = true
								} else {
								}
							}
							else {}
						}
					}
				}
				'Date' {
					mut n_1 := e.args.len
					if n == 0 {
						e.can_be_unwrapped_if_unused = true
						break
					}
					if n == 1 {
						match js_ast.known_primitive_type(e.args[0].data) {
							js_ast.primitive_null, js_ast.primitive_undefined,
							js_ast.primitive_boolean, js_ast.primitive_number,
							js_ast.primitive_string {
								e.can_be_unwrapped_if_unused = true
							}
							else {}
						}
					}
				}
				'Set' {
					mut n_2 := e.args.len
					if n == 0 {
						e.can_be_unwrapped_if_unused = true
						break
					}
					if n == 1 {
						// append no rhs

						// lhs.len==0
					}
				}
				'Map' {
					mut n_3 := e.args.len
					if n == 0 {
						e.can_be_unwrapped_if_unused = true
						break
					}
					if n == 1 {
						mut arg_1 := e.args[0].data
						match arg {
							js_ast.ENull, js_ast.EUndefined {
								e.can_be_unwrapped_if_unused = true
							}
							js_ast.EArray {
								mut all_entries_are_arrays := true
								for _, item in arg.items {
									_, ok_1 := item.data
									if !ok {
										all_entries_are_arrays = false
										break
									}
								}
								if all_entries_are_arrays {
									e.can_be_unwrapped_if_unused = true
								}
							}
							else {}
						}
					}
				}
			}
		}
	}
}

struct identifierOpts {
pub mut:
	assign_target             js_ast.AssignTarget
	is_call_target            bool
	is_delete_target          bool
	prefer_quoted_key         bool
	was_originally_identifier bool
	match_against_defines     bool
}

fn (p &Parser) handle_identifier(loc logger.Loc, e &js_ast.EIdentifier, opts identifierOpts) js_ast.Expr {
	mut ref := e.ref
	if p.options.minify_syntax {
		mut value, ok := p.const_values[ref]
		if ok {
			p.ignore_usage(ref)
			return js_ast.const_value_to_expr(loc, value)
		}
	}
	if p.fn_only_data_visit.arguments_ref != nil && ref == &p.fn_only_data_visit.arguments_ref {
		mut is_inside_unsupported_arrow := p.fn_or_arrow_data_visit.is_arrow && p.options.unsupported_jsf_eatures.has(compat.arrow)
		mut is_inside_unsupported_async_arrow := p.fn_only_data_visit.is_inside_async_arrow_fn && p.options.unsupported_jsf_eatures.has(compat.async_await)
		if is_inside_unsupported_arrow || is_inside_unsupported_async_arrow {
			return js_ast.Expr{
				loc:  loc
				data: &js_ast.EIdentifier{
					ref: p.capture_arguments()
				}
			}
		}
	}
	if (opts.assign_target != js_ast.assign_target_none || opts.is_delete_target
		&& p.symbols[ref.inner_index].import_item_status == ast.import_item_generated) && p.symbols[ref.inner_index].kind == ast.symbol_import {
		mut r := js_lexer.range_of_identifier(p.source, loc)
		mut setterHint := 0
		mut original_name := p.symbols[ref.inner_index].original_name
		if js_ast.is_identifier(original_name) && original_name != '_' {
			if original_name.len == 1 || original_name.len > 1 && original_name[0] < utf8.rune_self {
				setter_hint = strconv.v_sprintf(' (e.g. "set%s%s")', original_name[..1].to_upper(),
					original_name[1..])
			} else {
				setter_hint = strconv.v_sprintf(' (e.g. "set_%s")', original_name)
			}
		}
		mut notes := [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
		]
		if p.options.mode == config.mode_bundle {
			p.log.add_error_with_notes(&p.tracker, r, strconv.v_sprintf('Cannot assign to import %q',
				original_name), notes)
		} else {
			mut kind := logger.warning
			if p.suppress_warnings_about_weird_code {
				kind = logger.debug
			}
			p.log.add_idw_ith_notes(logger.msg_id_js_assign_to_import, kind, &p.tracker,
				r, strconv.v_sprintf('This assignment will throw because %q is an import',
				original_name), notes)
		}
	}
	if opts.assign_target == js_ast.assign_target_none && !opts.is_delete_target {
		mut symbol := &p.symbols[ref.inner_index]
		mut ns_alias := symbol.namespace_alias
		if ns_alias != nil {
			mut data := p.dot_or_mangled_prop_visit(js_ast.Expr{
				loc:  loc
				data: &js_ast.EIdentifier{
					ref: ns_alias.namespace_ref
				}
			}, symbol.original_name, loc)
			mut ts_member_data, ok_1 := p.ref_to_tsn_amespace_member_data[ns_alias.namespace_ref]
			if ok {
				mut ns, ok_2 := ts_member_data
				if ok {
					mut member, ok_3 := ns.exported_members[ns_alias.alias]
					if ok {
						mut m := member.data
						match m {
							js_ast.TSNamespaceMemberEnumNumber {
								return p.wrap_inlined_enum(js_ast.Expr{
									loc:  loc
									data: &js_ast.ENumber{
										value: m.value
									}
								}, ns_alias.alias)
							}
							js_ast.TSNamespaceMemberEnumString {
								return p.wrap_inlined_enum(js_ast.Expr{
									loc:  loc
									data: &js_ast.EString{
										value: m.value
									}
								}, ns_alias.alias)
							}
							js_ast.TSNamespaceMemberNamespace {
								p.ts_namespace_target = data
								p.ts_namespace_member_data = member.data
							}
						}
					}
				}
			}
			return js_ast.Expr{
				loc:  loc
				data: data
			}
		}
	}
	if p.is_import_item[ref] {
		return js_ast.Expr{
			loc:  loc
			data: &js_ast.EImportIdentifier{
				ref:                       ref
				prefer_quoted_key:         opts.prefer_quoted_key
				was_originally_identifier: opts.was_originally_identifier
			}
		}
	}
	mut ts_member_data_1, ok_4 := p.ref_to_tsn_amespace_member_data[ref]
	if ok {
		mut m_1 := ts_member_data
		match m {
			js_ast.TSNamespaceMemberEnumNumber {
				return p.wrap_inlined_enum(js_ast.Expr{
					loc:  loc
					data: &js_ast.ENumber{
						value: m.value
					}
				}, p.symbols[ref.inner_index].original_name)
			}
			js_ast.TSNamespaceMemberEnumString {
				return p.wrap_inlined_enum(js_ast.Expr{
					loc:  loc
					data: &js_ast.EString{
						value: m.value
					}
				}, p.symbols[ref.inner_index].original_name)
			}
			js_ast.TSNamespaceMemberNamespace {
				p.ts_namespace_target = e
				p.ts_namespace_member_data = ts_member_data
			}
		}
	}
	if p.options.ts.parse {
		mut ns_ref, ok_5 := p.is_exported_inside_namespace[ref]
		if ok {
			mut name := p.symbols[ref.inner_index].original_name
			p.record_usage(ns_ref)
			mut property_access := p.dot_or_mangled_prop_visit(js_ast.Expr{
				loc:  loc
				data: &js_ast.EIdentifier{
					ref: ns_ref
				}
			}, name, loc)
			if p.ts_namespace_target == e {
				p.ts_namespace_target = property_access
			}
			return js_ast.Expr{
				loc:  loc
				data: property_access
			}
		}
	}
	if ref == p.require_ref && !opts.is_call_target {
		if p.options.mode == config.mode_bundle && p.source.index != runtime.source_index && e != p.dot_or_index_target {
			p.log.add_id(logger.msg_id_js_indirect_require, logger.debug, &p.tracker,
				js_lexer.range_of_identifier(p.source, loc), 'Indirect calls to "require" will not be bundled')
		}
		return p.value_to_substitute_for_require(loc)
	}
	if opts.assign_target != js_ast.assign_target_none {
		p.symbols[e.ref.inner_index].flags |= ast.could_potentially_be_mutated
	}
	return js_ast.Expr{
		loc:  loc
		data: e
	}
}

struct visitFnOpts {
pub mut:
	is_method                 bool
	is_derived_class_ctor     bool
	is_lowered_private_method bool
}

fn (p &Parser) visit_fn(fn_ &js_ast.Fn, scope_loc logger.Loc, opts visitFnOpts) {
	mut decoratorScope := 0
	mut old_fn_or_arrow_data := p.fn_or_arrow_data_visit
	mut old_fn_only_data := p.fn_only_data_visit
	p.fn_or_arrow_data_visit = FnOrArrowDataVisit{
		is_async:                           fn_.is_async
		is_generator:                       fn_.is_generator
		is_derived_class_ctor:              opts.is_derived_class_ctor
		should_lower_super_property_access: fn_.is_async
			&& p.options.unsupported_jsf_eatures.has(compat.async_await)
			|| opts.is_lowered_private_method
	}
	p.fn_only_data_visit = FnOnlyDataVisit{
		is_this_nested:        true
		is_new_target_allowed: true
		arguments_ref:         &fn_.arguments_ref
	}
	if opts.is_method {
		decorator_scope = p.prop_method_decorator_scope
		p.fn_only_data_visit.inner_class_name_ref = old_fn_only_data.inner_class_name_ref
		p.fn_only_data_visit.is_in_static_class_context = old_fn_only_data.is_in_static_class_context
	}
	if fn_.name != nil {
		p.record_declared_symbol(fn_.name.ref)
	}
	p.push_scope_for_visit_pass(js_ast.scope_function_args, scope_loc)
	p.visit_args(fn_.args, VisitArgsOpts{
		has_rest_arg:                fn_.has_rest_arg
		body:                        fn_.body.block.stmts
		is_unique_formal_parameters: fn_.is_unique_formal_parameters
		decorator_scope:             decorator_scope
	})
	p.push_scope_for_visit_pass(js_ast.scope_function_body, fn_.body.loc)
	if fn_.name != nil {
		p.validate_declared_symbol_name(fn_.name.loc, p.symbols[fn_.name.ref.inner_index].original_name)
	}
	fn_.body.block.stmts = p.visit_stmts_and_prepend_temp_refs(fn_.body.block.stmts, PrependTempRefsOpts{
		fn_body_loc: &fn_.body.loc
		kind:        stmts_fn_body
	})
	p.pop_scope()
	p.lower_function(&fn_.is_async, &fn_.is_generator, &fn_.args, fn_.body.loc, &fn_.body.block,
		nil, &fn_.has_rest_arg, false)
	p.pop_scope()
	p.fn_or_arrow_data_visit = old_fn_or_arrow_data
	p.fn_only_data_visit = old_fn_only_data
}

fn (p &Parser) record_export(loc logger.Loc, alias string, ref ast.Ref) {
	mut name, ok := p.named_exports[alias]
	if ok {
		p.log.add_error_with_notes(&p.tracker, js_lexer.range_of_identifier(p.source,
			loc), strconv.v_sprintf('Multiple exports with the same name %q', alias),
			[
			p.tracker.msg_data(js_lexer.range_of_identifier(p.source, name.alias_loc),
				strconv.v_sprintf('The name %q was originally exported here:', alias)),
		])
	} else {
		p.named_exports[alias] = js_ast.NamedExport{
			alias_loc: loc
			ref:       ref
		}
	}
}

struct importsExportsScanResult {
pub mut:
	stmts                 []js_ast.Stmt
	kept_import_equals    bool
	removed_import_equals bool
}

// Returns true if this is an unused TypeScript import-equals statement
fn (p &Parser) check_for_unused_tsi_mport_equals(s &js_ast.SLocal, result &ImportsExportsScanResult) bool {
	if s.was_tsi_mport_equals && !s.is_export {
		mut decl := s.decls[0]
		mut value := s.decls[0].value_or_nil
		for {
			mut dot, ok := value.data
			if ok {
				value = dot.target
			} else {
				break
			}
		}
		mut value_ref := ast.invalid_ref
		mut v := value.data
		match v {
			js_ast.EIdentifier {
				value_ref = v.ref
			}
			js_ast.EImportIdentifier {
				value_ref = v.ref
			}
		}
		if value_ref != ast.invalid_ref {
			mut ref := decl.binding.data.ref
			if p.symbols[ref.inner_index].use_count_estimate == 0 {
				p.ignore_usage(value_ref)
				result.removed_import_equals = true
				return true
			} else {
				result.kept_import_equals = true
			}
		}
	}
	return false
}

fn (p &Parser) scan_for_unused_tsi_mport_equals(stmts []js_ast.Stmt) importsExportsScanResult {
	mut stmts_end := isize(0)
	for _, stmt in stmts {
		mut s, ok := stmt.data
		if ok && p.check_for_unused_tsi_mport_equals(s, &result) {
			continue
		}
		stmts[stmts_end] = stmt
		stmts_end++
	}
	result.stmts = stmts[..stmts_end]
	return
}

fn (p &Parser) scan_for_imports_and_exports(stmts []js_ast.Stmt) importsExportsScanResult {
	mut unused_import_flags := p.options.ts.config.unused_import_flags()
	mut stmts_end := isize(0)
	for _, stmt in stmts {
		mut s := stmt.data
		match s {
			js_ast.SImport {
				mut record := &p.import_records[s.import_record_index]
				mut keep_unused_imports := p.options.ts.parse
					&& (unused_import_flags & config.tsu_nused_import_keep_values) != 0
					&& p.options.mode != config.mode_bundle && !p.options.minify_identifiers
				if (record.flags & ast.assert_type_json) != 0 && p.options.mode == config.mode_bundle && s.items != nil {
					for _, item in &s.items {
						if p.options.ts.parse && p.ts_use_counts[item.name.ref.inner_index] == 0 && (unused_import_flags & config.tsu_nused_import_keep_values) == 0 {
							continue
						}
						if item.alias != 'default' {
							p.log.add_error_with_notes(&p.tracker, js_lexer.range_of_identifier(p.source,
								item.alias_loc), strconv.v_sprintf('Cannot use non-default import %q with a JSON import assertion',
								item.alias), p.notes_for_assert_type_json(record, item.alias))
						}
					}
				}
				if (p.options.minify_syntax || p.options.ts.parse) && !keep_unused_imports {
					mut found_imports := false
					mut is_unused_in_type_script := true
					if s.default_name != nil {
						found_imports = true
						mut symbol := p.symbols[s.default_name.ref.inner_index]
						if p.options.ts.parse && (
							p.ts_use_counts[s.default_name.ref.inner_index] != 0
							|| (p.options.ts.config.unused_import_flags() & config.tsu_nused_import_keep_values) != 0) {
							is_unused_in_type_script = false
						}
						if symbol.use_count_estimate == 0 && (p.options.ts.parse
							|| !p.module_scope.contains_direct_eval) {
							s.default_name = nil
						}
					}
					if s.star_name_loc != nil {
						found_imports = true
						mut symbol_1 := p.symbols[s.namespace_ref.inner_index]
						if p.options.ts.parse && (
							p.ts_use_counts[s.namespace_ref.inner_index] != 0
							|| (p.options.ts.config.unused_import_flags() & config.tsu_nused_import_keep_values) != 0) {
							is_unused_in_type_script = false
						}
						if symbol.use_count_estimate == 0 && (p.options.ts.parse
							|| !p.module_scope.contains_direct_eval) {
							mut import_items, ok := p.import_items_for_namespace[s.namespace_ref]
							if ok && import_items.entries.len == 0 {
								s.star_name_loc = nil
							}
						}
					}
					if s.items != nil {
						found_imports = true
						mut items_end := isize(0)
						for _, item_1 in &s.items {
							mut symbol_2 := p.symbols[item.name.ref.inner_index]
							if p.options.ts.parse && (
								p.ts_use_counts[item.name.ref.inner_index] != 0
								|| (p.options.ts.config.unused_import_flags() & config.tsu_nused_import_keep_values) != 0) {
								is_unused_in_type_script = false
							}
							if symbol.use_count_estimate != 0 || !p.options.ts.parse
								&& p.module_scope.contains_direct_eval {
								(&s.items)[items_end] = item
								items_end++
							}
						}
						if items_end == 0 {
							s.items = nil
						} else {
							*s.items = (&s.items)[..items_end]
						}
					}
					if p.options.ts.parse && found_imports && is_unused_in_type_script && (unused_import_flags & config.tsu_nused_import_keep_stmt) == 0 {
						if !record.source_index.is_valid() && !record.copy_source_index.is_valid() {
							record.flags |= ast.is_unused
							continue
						}
					}
				}
				if p.options.mode != config.mode_pass_through {
					if s.star_name_loc != nil {
						mut import_items_1, ok_1 := p.import_items_for_namespace[s.namespace_ref]
						if ok && import_items.entries.len > 0 {
							mut sorted := []string{len: 0, cap: import_items.Entries.len}
							for alias, _ in import_items.entries {
								sorted << alias
							}
							sort.strings(sorted)
							for _, alias_1 in sorted {
								mut name := import_items.entries[alias]
								p.named_imports[name.ref] = js_ast.NamedImport{
									alias:               alias
									alias_loc:           name.loc
									namespace_ref:       s.namespace_ref
									import_record_index: s.import_record_index
								}
								p.symbols[name.ref.inner_index].namespace_alias = &ast.NamespaceAlias{
									namespace_ref: s.namespace_ref
									alias:         alias
								}
								p.declared_symbols << js_ast.DeclaredSymbol{
									ref:          name.ref
									is_top_level: true
								}
							}
						}
					}
					if s.default_name != nil {
						p.named_imports[s.default_name.ref] = js_ast.NamedImport{
							alias:               'default'
							alias_loc:           s.default_name.loc
							namespace_ref:       s.namespace_ref
							import_record_index: s.import_record_index
						}
					}
					if s.star_name_loc != nil {
						p.named_imports[s.namespace_ref] = js_ast.NamedImport{
							alias_is_star:       true
							alias_loc:           &s.star_name_loc
							namespace_ref:       ast.invalid_ref
							import_record_index: s.import_record_index
						}
					}
					if s.items != nil {
						for _, item_2 in &s.items {
							p.named_imports[item.name.ref] = js_ast.NamedImport{
								alias:               item.alias
								alias_loc:           item.alias_loc
								namespace_ref:       s.namespace_ref
								import_record_index: s.import_record_index
							}
						}
					}
				}
				p.import_records_for_current_part << s.import_record_index
				if s.star_name_loc != nil {
					record.flags |= ast.contains_import_star
				}
				if s.default_name != nil {
					record.flags |= ast.contains_default_alias
				} else if s.items != nil {
					for _, item_3 in &s.items {
						if item.alias == 'default' {
							record.flags |= ast.contains_default_alias
						} else if item.alias == '__esModule' {
							record.flags |= ast.contains_esm_odule_alias
						}
					}
				}
			}
			js_ast.SFunction {
				if s.is_export {
					p.record_export(s.fn_.name.loc, p.symbols[s.fn_.name.ref.inner_index].original_name,
						s.fn_.name.ref)
				}
			}
			js_ast.SClass {
				if s.is_export {
					p.record_export(s.class.name.loc, p.symbols[s.class.name.ref.inner_index].original_name,
						s.class.name.ref)
				}
			}
			js_ast.SLocal {
				if s.is_export {
					js_ast.for_each_identifier_binding_in_decls(s.decls, fn (loc logger.Loc, b &js_ast.BIdentifier) {
						p.record_export(loc, p.symbols[b.ref.inner_index].original_name,
							b.ref)
					})
				}
				if p.check_for_unused_tsi_mport_equals(s, &result) {
					continue
				}
			}
			js_ast.SExportDefault {
				p.record_export(s.default_name.loc, 'default', s.default_name.ref)
			}
			js_ast.SExportClause {
				for _, item_4 in s.items {
					p.record_export(item.alias_loc, item.alias, item.name.ref)
				}
			}
			js_ast.SExportStar {
				mut record_1 := &p.import_records[s.import_record_index]
				p.import_records_for_current_part << s.import_record_index
				if s.alias != nil {
					p.named_imports[s.namespace_ref] = js_ast.NamedImport{
						alias_is_star:       true
						alias_loc:           s.alias.loc
						namespace_ref:       ast.invalid_ref
						import_record_index: s.import_record_index
						is_exported:         true
					}
					p.record_export(s.alias.loc, s.alias.original_name, s.namespace_ref)
					record.flags |= ast.contains_import_star
				} else {
					p.export_star_import_records << s.import_record_index
				}
			}
			js_ast.SExportFrom {
				mut record_2 := &p.import_records[s.import_record_index]
				p.import_records_for_current_part << s.import_record_index
				for _, item_5 in s.items {
					p.named_imports[item.name.ref] = js_ast.NamedImport{
						alias:               item.original_name
						alias_loc:           item.name.loc
						namespace_ref:       s.namespace_ref
						import_record_index: s.import_record_index
						is_exported:         true
					}
					p.record_export(item.name.loc, item.alias, item.name.ref)
					if item.original_name == 'default' {
						record.flags |= ast.contains_default_alias
					} else if item.original_name == '__esModule' {
						record.flags |= ast.contains_esm_odule_alias
					}
				}
				if (record.flags & ast.assert_type_json) != 0 && p.options.mode == config.mode_bundle {
					for _, item_6 in s.items {
						if item.original_name != 'default' {
							p.log.add_error_with_notes(&p.tracker, js_lexer.range_of_identifier(p.source,
								item.name.loc), strconv.v_sprintf('Cannot use non-default import %q with a JSON import assertion',
								item.original_name), p.notes_for_assert_type_json(record,
								item.original_name))
						}
					}
				}
				if p.options.ts.parse && s.items.len == 0 && (unused_import_flags & config.tsu_nused_import_keep_stmt) == 0 {
					continue
				}
			}
		}
		stmts[stmts_end] = stmt
		stmts_end++
	}
	result.stmts = stmts[..stmts_end]
	return
}

fn (p &Parser) append_part(parts []js_ast.Part, stmts []js_ast.Stmt) []js_ast.Part {
	p.symbol_uses = map[ast.Ref]js_ast.SymbolUse{}
	p.import_symbol_property_uses = nil
	p.symbol_call_uses = nil
	p.declared_symbols = nil
	p.import_records_for_current_part = nil
	p.scopes_for_current_part = nil
	mut part := js_ast.Part{
		stmts:       p.visit_stmts_and_prepend_temp_refs(stmts, PrependTempRefsOpts{})
		symbol_uses: p.symbol_uses
	}
	if p.current_scope != p.module_scope {
		panic('Internal error: Scope stack imbalance')
	}
	if p.relocated_top_level_vars.len > 0 {
		mut already_declared := map[ast.Ref]Bool{}
		for _, local in p.relocated_top_level_vars {
			for {
				mut link := p.symbols[local.ref.inner_index].link
				if link == ast.invalid_ref {
					break
				}
				local.ref = link
			}
			if !already_declared[local.ref] {
				already_declared[local.ref] = true
				part.stmts << js_ast.Stmt{
					loc:  local.loc
					data: &js_ast.SLocal{
						decls: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
						]
					}
				}
			}
		}
		p.relocated_top_level_vars = nil
	}
	if part.stmts.len > 0 {
		mut flags := 0
		if p.options.mode == config.mode_pass_through {
			flags |= js_ast.keep_export_clauses
		}
		part.can_be_removed_if_unused = p.ast_helpers.stmts_can_be_removed_if_unused(part.stmts,
			flags)
		part.declared_symbols = p.declared_symbols
		part.import_record_indices = p.import_records_for_current_part
		part.import_symbol_property_uses = p.import_symbol_property_uses
		part.symbol_call_uses = p.symbol_call_uses
		part.scopes = p.scopes_for_current_part
		parts << part
	}
	return parts
}

fn new_parser(log logger.Log, source logger.Source, lexer js_lexer.Lexer, options &Options) &Parser {
	if options.defines == nil {
		mut default_defines := config.process_defines(nil)
		options.defines = &default_defines
	}
	mut p := &Parser{
		log:                                log
		source:                             source
		tracker:                            logger.make_line_column_tracker(&source)
		lexer:                              lexer
		allow_in:                           true
		options:                            &options
		runtime_imports:                    map[string]ast.LocRef{}
		promise_ref:                        ast.invalid_ref
		reg_exp_ref:                        ast.invalid_ref
		after_arrow_body_loc:               logger.Loc{
			start: -1
		}
		first_jsxe_lement_loc:              logger.Loc{
			start: -1
		}
		import_meta_ref:                    ast.invalid_ref
		super_ctor_ref:                     ast.invalid_ref
		weak_map_ref:                       ast.invalid_ref
		weak_set_ref:                       ast.invalid_ref
		private_getters:                    map[ast.Ref]ast.Ref{}
		private_setters:                    map[ast.Ref]ast.Ref{}
		ref_to_tsn_amespace_member_data:    map[ast.Ref]js_ast.TSNamespaceMemberData{}
		emitted_namespace_vars:             map[ast.Ref]Bool{}
		is_exported_inside_namespace:       map[ast.Ref]ast.Ref{}
		local_type_names:                   map[string]Bool{}
		import_items_for_namespace:         map[ast.Ref]NamespaceImportItems{}
		is_import_item:                     map[ast.Ref]Bool{}
		named_imports:                      map[ast.Ref]js_ast.NamedImport{}
		named_exports:                      map[string]js_ast.NamedExport{}
		jsx_runtime_imports:                map[string]ast.LocRef{}
		jsx_legacy_imports:                 map[string]ast.LocRef{}
		suppress_warnings_about_weird_code: helpers.is_inside_node_modules(source.key_path.text)
	}
	if options.drop_labels.len > 0 {
		p.drop_labels_map = map[string]string{}
		for _, name in options.drop_labels {
		}
	}
	if !options.minify_whitespace {
		p.expr_comments = map[logger.Loc][]string{}
	}
	p.ast_helpers = js_ast.make_helper_context(fn (ref ast.Ref) {
		return p.symbols[ref.inner_index].kind == ast.symbol_unbound
	})
	p.push_scope_for_parse_pass(js_ast.scope_entry, logger.Loc{
		start: loc_module_scope
	})
	return p
}

__global defaultJSXFactory = ['React', 'createElement']
__global defaultJSXFragment = ['React', 'Fragment']
const default_jsxi_mport_source = 'react'

pub fn parse(log logger.Log, source logger.Source, options Options) (js_ast.AST, bool) {
	ok = true
	defer {
		mut r := recover()
		_, is_lexer_panic := r
		if is_lexer_panic {
			ok = false
		} else if r != nil {
			panic(r)
		}
	}
	if options.jsx.factory.parts.len == 0 {
		options.jsx.factory = config.DefineExpr{
			parts: default_jsxf_actory
		}
	}
	if options.jsx.fragment.parts.len == 0 && options.jsx.fragment.constant == nil {
		options.jsx.fragment = config.DefineExpr{
			parts: default_jsxf_ragment
		}
	}
	if options.jsx.import_source.len == 0 {
		options.jsx.import_source = default_jsxi_mport_source
	}
	mut p := new_parser(log, source, js_lexer.new_lexer(log, source, options.ts), &options)
	mut hashbang := ''
	if p.lexer.token == js_lexer.th_ashbang {
		hashbang = p.lexer.identifier.string
		p.lexer.next()
	}
	p.fn_or_arrow_data_parse.await = allow_expr
	p.fn_or_arrow_data_parse.is_top_level = true
	mut stmts := p.parse_stmts_up_to(js_lexer.te_nd_of_file, ParseStmtOpts{
		is_module_scope:          true
		allow_directive_prologue: true
	})
	p.prepare_for_visit_pass()
	mut directives := []string{}
	mut ts_always_strict := p.options.ts_always_strict
	if ts_always_strict != nil && ts_always_strict.value {
		directives << 'use strict'
	}
	{
		mut total_count := isize(0)
		mut kept_count := isize(0)
		for _, stmt in stmts {
			mut s := stmt.data
			match s {
				js_ast.SComment {
					stmts[kept_count] = stmt
					kept_count++
					total_count++
					continue
				}
				js_ast.SDirective {
					if p.is_strict_mode() && s.legacy_octal_loc.start > 0 {
						p.mark_strict_mode_feature(legacy_octal_escape, p.source.range_of_legacy_octal_escape(s.legacy_octal_loc),
							'')
					}
					mut directive := helpers.utf_16_to_string(s.value)
					mut found := false
					for _, existing in directives {
						if existing == directive {
							found = true
							break
						}
					}
					if !found {
						directives << directive
					}
					total_count++
					continue
				}
			}
			break
		}
		if kept_count < total_count {
			stmts << stmts[total_count..]
		}
	}
	mut ns_export_part := js_ast.Part{
		symbol_uses:              map[ast.Ref]js_ast.SymbolUse{}
		can_be_removed_if_unused: true
	}
	mut before := [ns_export_part]
	mut parts := []js_ast.Part{}
	mut after := []js_ast.Part{}
	for _, file in p.options.injected_files {
		mut exports_no_conflict := []string{len: 0, cap: file.Exports.len}
		mut symbols := map[string]ast.LocRef{}
		if file.define_name != '' {
			mut ref := p.new_symbol(ast.symbol_other, file.define_name)
			p.module_scope.generated << ref
			symbols['default'] = ast.LocRef{
				ref: ref
			}
			exports_no_conflict << 'default'
			p.injected_define_symbols << ref
		} else {
			// unhandled in stmt: unknown sum type value
		}
		if file.is_copy_loader {
			before, _ = p.generate_import_stmt(file.source.key_path.text, logger.Range{},
				exports_no_conflict, before, symbols, nil, &file.source.index)
		} else {
			before, _ = p.generate_import_stmt(file.source.key_path.text, logger.Range{},
				exports_no_conflict, before, symbols, &file.source.index, nil)
		}
	}
	p.will_wrap_module_in_try_catch_for_using = p.should_lower_using_declarations(stmts)
	if !p.options.tree_shaking || p.will_wrap_module_in_try_catch_for_using {
		parts = p.append_part(parts, stmts)
	} else {
		mut preprocessedEnums := map[isize][]js_ast.Part{}
		if p.scopes_in_order_for_enum != nil {
			for i, stmt_1 in stmts {
				_, ok_1 := stmt.data
				if ok {
					if preprocessed_enums == nil {
						preprocessed_enums = map[isize][]js_ast.Part{}
					}
					mut old_scopes_in_order := p.scopes_in_order
					p.scopes_in_order = p.scopes_in_order_for_enum[stmt.loc]
					preprocessed_enums[i] = p.append_part(nil, [stmt])
					p.scopes_in_order = old_scopes_in_order
				}
			}
		}
		for i_1, stmt_2 in stmts {
			mut s_1 := stmt.data
			match s {
				js_ast.SLocal {
					for _, decl in s.decls {
						mut clone := &s
						clone.decls = [decl]
						parts = p.append_part(parts, [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
						])
					}
				}
				js_ast.SImport, js_ast.SExportFrom, js_ast.SExportStar {
					if p.options.mode != config.mode_pass_through {
						before = p.append_part(before, [stmt])
					} else {
						parts = p.append_part(parts, [stmt])
					}
				}
				js_ast.SExportEquals {
					after = p.append_part(after, [stmt])
				}
				js_ast.SEnum {
					parts << preprocessed_enums[i]
					p.scopes_in_order = p.scopes_in_order[p.scopes_in_order_for_enum[stmt.loc].len..]
				}
				else {
					parts = p.append_part(parts, [stmt])
				}
			}
		}
	}
	if p.import_meta_ref != ast.invalid_ref {
		mut import_meta_stmt := js_ast.Stmt{
			data: &js_ast.SLocal{
				kind:  p.select_local_kind(js_ast.local_const)
				decls: [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				]
			}
		}
		before << js_ast.Part{
			stmts:                    [import_meta_stmt]
			symbol_uses:              map[ast.Ref]js_ast.SymbolUse{}
			declared_symbols:         [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
			]
			can_be_removed_if_unused: true
		}
	}
	p.pop_scope()
	result = p.to_ast(before, parts, after, hashbang, directives)
	result.source_map_comment = p.lexer.source_mapping_url
	return
}

pub fn lazy_export_ast(log logger.Log, source logger.Source, options Options, expr js_ast.Expr, api_call string) js_ast.AST {
	mut p := new_parser(log, source, js_lexer.Lexer{}, &options)
	p.prepare_for_visit_pass()
	if api_call != '' {
		p.symbol_uses = map[ast.Ref]js_ast.SymbolUse{}
		expr = p.call_runtime(expr.loc, api_call, [expr])
	}
	mut ns_export_part := js_ast.Part{
		symbol_uses:              map[ast.Ref]js_ast.SymbolUse{}
		can_be_removed_if_unused: true
	}
	mut part := js_ast.Part{
		stmts:       [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
		]
		symbol_uses: p.symbol_uses
	}
	p.symbol_uses = nil
	mut ast := p.to_ast([ns_export_part], [part], nil, '', nil)
	ast.has_lazy_export = true
	return ast
}

pub fn glob_resolve_ast(log logger.Log, source logger.Source, import_records []ast.ImportRecord, object &js_ast.EObject, name string) js_ast.AST {
	mut p := new_parser(log, source, js_lexer.Lexer{}, &Options{})
	p.prepare_for_visit_pass()
	mut ns_export_part := js_ast.Part{
		symbol_uses:              map[ast.Ref]js_ast.SymbolUse{}
		can_be_removed_if_unused: true
	}
	if p.import_records.len != 0 {
		panic('Internal error')
	}
	p.import_records = import_records
	mut import_record_indices := []u32{len: 0, cap: ImportRecords.len}
	for import_record_index, _ in import_records {
		import_record_indices << u32(import_record_index)
	}
	p.symbol_uses = map[ast.Ref]js_ast.SymbolUse{}
	mut ref := p.new_symbol(ast.symbol_other, name)
	p.module_scope.generated << ref
	mut part := js_ast.Part{
		stmts:                 [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
		]
		import_record_indices: import_record_indices
		symbol_uses:           p.symbol_uses
	}
	p.symbol_uses = nil
	p.esm_export_keyword.len = isize(1)
	return p.to_ast([ns_export_part], [part], nil, '', nil)
}

pub fn parse_define_expr_or_json(text string) (config.DefineExpr, js_ast.E) {
	if text == '' {
		return config.DefineExpr{}, nil
	}
	mut parts := text.split('.')
	for i, part in parts {
		if !js_ast.is_identifier(part) {
			parts = nil
			break
		}
		if i == 0 {
			mut token, ok := js_lexer.keywords[part]
			if ok && token != js_lexer.tn_ull && token != js_lexer.tt_his && (
				token != js_lexer.ti_mport || parts.len < 2 || parts[1] != 'meta') {
				parts = nil
				break
			}
		}
	}
	if parts != nil {
		return config.DefineExpr{
			parts: parts
		}, nil
	}
	mut log := logger.new_defer_log(logger.defer_log_no_verbose_or_debug, nil)
	mut expr, ok_1 := parse_json(log, logger.Source{
		contents: text
	}, JSONOptions{})
	if !ok {
		return config.DefineExpr{}, nil
	}
	// append no rhs

	// lhs.len==0
	return config.DefineExpr{}, expr.data
}

type whyESM = u8

enum whyESM {
	why_esmu_nknown
	why_esme_xport_keyword
	why_esmi_mport_meta
	why_esmt_op_level_await
	why_esmf_ile_mjs
	why_esmf_ile_mts
	why_esmt_ype_module_package_json
	why_esmi_mport_statement
}

// Say why this the current file is being considered an ES module
fn (p &Parser) why_esm_odule() (whyESM, []logger.MsgData) {
	mut because := 'This file is considered to be an ECMAScript module because'
	if p.esm_export_keyword.len > 0 {
		return why_esme_xport_keyword, [
			p.tracker.msg_data(p.esm_export_keyword, because + ' of the "export" keyword here:'),
		]
	} else if p.esm_import_meta.len > 0 {
		return why_esmi_mport_meta, [
			p.tracker.msg_data(p.esm_import_meta, because + ' of the use of "import.meta" here:'),
		]
	} else if p.top_level_await_keyword.len > 0 {
		return why_esmt_op_level_await, [
			p.tracker.msg_data(p.top_level_await_keyword, because +
				' of the top-level "await" keyword here:'),
		]
	} else if p.options.module_type_data.type == js_ast.module_esm_mjs {
		return why_esmf_ile_mjs, [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
		]
	} else if p.options.module_type_data.type == js_ast.module_esm_mts {
		return why_esmf_ile_mts, [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
		]
	} else if p.options.module_type_data.type == js_ast.module_esm_package_json {
		mut tracker := logger.make_line_column_tracker(p.options.module_type_data.source)
		return why_esmt_ype_module_package_json, [
			tracker.msg_data(p.options.module_type_data.range, because +
				' the enclosing "package.json" file sets the type of this file to "module":'),
		]
	} else if p.esm_import_statement_keyword.len > 0 {
		return why_esmi_mport_statement, [
			p.tracker.msg_data(p.esm_import_statement_keyword, because +
				' of the "import" keyword here:'),
		]
	}
	return why_esmu_nknown, nil
}

fn (p &Parser) prepare_for_visit_pass() {
	p.push_scope_for_visit_pass(js_ast.scope_entry, logger.Loc{
		start: loc_module_scope
	})
	p.fn_or_arrow_data_visit.is_outside_fn_or_arrow = true
	p.module_scope = p.current_scope
	mut ts_always_strict := p.options.ts_always_strict
	if ts_always_strict != nil && ts_always_strict.value {
		p.current_scope.strict_mode = js_ast.implicit_strict_mode_tsa_lways_strict
	}
	p.is_file_considered_to_have_esme_xports = p.esm_export_keyword.len > 0
		|| p.esm_import_meta.len > 0 || p.top_level_await_keyword.len > 0
		|| p.options.module_type_data.type.is_esm()
	p.is_file_considered_esm = p.is_file_considered_to_have_esme_xports
		|| p.esm_import_statement_keyword.len > 0
	if p.is_file_considered_esm && p.lexer.legacy_htmlc_omment_range.len > 0 {
		_, notes := p.why_esm_odule()
		p.log.add_error_with_notes(&p.tracker, p.lexer.legacy_htmlc_omment_range, 'Legacy HTML single-line comments are not allowed in ECMAScript modules',
			notes)
	}
	if p.is_file_considered_esm {
		p.module_scope.recursive_set_strict_mode(js_ast.implicit_strict_mode_esm)
	}
	p.hoist_symbols(p.module_scope)
	if p.options.mode != config.mode_pass_through {
		p.require_ref = p.declare_common_jss_ymbol(ast.symbol_unbound, 'require')
	} else {
		p.require_ref = p.new_symbol(ast.symbol_unbound, 'require')
	}
	if p.options.mode != config.mode_pass_through && !p.is_file_considered_to_have_esme_xports {
		p.exports_ref = p.declare_common_jss_ymbol(ast.symbol_hoisted, 'exports')
		p.module_ref = p.declare_common_jss_ymbol(ast.symbol_hoisted, 'module')
	} else {
		p.exports_ref = p.new_symbol(ast.symbol_hoisted, 'exports')
		p.module_ref = p.new_symbol(ast.symbol_hoisted, 'module')
	}
	if p.options.jsx.parse {
		mut jsx_runtime := p.lexer.jsxr_untime_pragma_comment
		if jsx_runtime.text != '' {
			if jsx_runtime.text == 'automatic' {
				p.options.jsx.automatic_runtime = true
			} else if jsx_runtime.text == 'classic' {
				p.options.jsx.automatic_runtime = false
			} else {
				p.log.add_idw_ith_notes(logger.msg_id_js_unsupported_jsxc_omment, logger.warning,
					&p.tracker, jsx_runtime.range, strconv.v_sprintf('Invalid JSX runtime: %q',
					jsx_runtime.text), [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				])
			}
		}
		mut jsx_factory := p.lexer.jsxf_actory_pragma_comment
		if jsx_factory.text != '' {
			if p.options.jsx.automatic_runtime {
				p.log.add_id(logger.msg_id_js_unsupported_jsxc_omment, logger.warning,
					&p.tracker, jsx_factory.range, 'The JSX factory cannot be set when using React\'s "automatic" JSX transform')
			} else {
				// LOOL0
				mut expr, _ := parse_define_expr_or_json(jsx_factory.text)
				if expr.parts.len > 0 {
					p.options.jsx.factory = expr
				} else {
					p.log.add_id(logger.msg_id_js_unsupported_jsxc_omment, logger.warning,
						&p.tracker, jsx_factory.range, strconv.v_sprintf('Invalid JSX factory: %s',
						jsx_factory.text))
				}
			}
		}
		mut jsx_fragment := p.lexer.jsxf_ragment_pragma_comment
		if jsx_fragment.text != '' {
			if p.options.jsx.automatic_runtime {
				p.log.add_id(logger.msg_id_js_unsupported_jsxc_omment, logger.warning,
					&p.tracker, jsx_fragment.range, 'The JSX fragment cannot be set when using React\'s "automatic" JSX transform')
			} else {
				// LOOL0
				mut expr_1, _ := parse_define_expr_or_json(jsx_fragment.text)
				if expr.parts.len > 0 || expr.constant != nil {
					p.options.jsx.fragment = expr
				} else {
					p.log.add_id(logger.msg_id_js_unsupported_jsxc_omment, logger.warning,
						&p.tracker, jsx_fragment.range, strconv.v_sprintf('Invalid JSX fragment: %s',
						jsx_fragment.text))
				}
			}
		}
		mut jsx_import_source := p.lexer.jsxi_mport_source_pragma_comment
		if jsx_import_source.text != '' {
			if !p.options.jsx.automatic_runtime {
				p.log.add_idw_ith_notes(logger.msg_id_js_unsupported_jsxc_omment, logger.warning,
					&p.tracker, jsx_import_source.range, 'The JSX import source cannot be set without also enabling React\'s "automatic" JSX transform',
					[// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
				])
			} else {
				p.options.jsx.import_source = jsx_import_source.text
			}
		}
	}
	if p.current_scope.strict_mode == js_ast.sloppy_mode && p.options.jsx.automatic_runtime && p.first_jsxe_lement_loc.start != -1 {
		p.current_scope.strict_mode = js_ast.implicit_strict_mode_jsxa_utomatic_runtime
	}
}

fn (p &Parser) declare_common_jss_ymbol(kind ast.SymbolKind, name string) ast.Ref {
	mut member, ok := p.module_scope.members[name]
	if ok && p.symbols[member.ref.inner_index].kind == ast.symbol_hoisted
		&& kind == ast.symbol_hoisted && !p.is_file_considered_to_have_esme_xports {
		return member.ref
	}
	mut ref := p.new_symbol(kind, name)
	if !ok {
		p.module_scope.members[name] = js_ast.ScopeMember{
			ref: ref
			loc: logger.Loc{
				start: -1
			}
		}
		return ref
	}
	p.module_scope.generated << ref
	return ref
}

// Compute a character frequency histogram for everything that's not a bound
// symbol. This is used to modify how minified names are generated for slightly
// better gzip compression. Even though it's a very small win, we still do it
// because it's simple to do and very cheap to compute.
fn (p &Parser) compute_character_frequency() &ast.CharFreq {
	if !p.options.minify_identifiers || p.source.index == runtime.source_index {
		return nil
	}
	mut char_freq := &ast.CharFreq{}
	char_freq.scan(p.source.contents, 1)
	for _, comment_range in p.lexer.all_comments {
		char_freq.scan(p.source.text_for_range(comment_range), -1)
	}
	for _, record in p.import_records {
		if !record.source_index.is_valid() {
			char_freq.scan(record.path.text, -1)
		}
	}
	mut visit := 0
	visit = fn (scope &js_ast.Scope) {
		for _, member in scope.members {
			mut symbol := &p.symbols[member.ref.inner_index]
			if symbol.slot_namespace() != ast.slot_must_not_be_renamed {
				char_freq.scan(symbol.original_name, -i32(symbol.use_count_estimate))
			}
		}
		if scope.label.ref != ast.invalid_ref {
			mut symbol_1 := &p.symbols[scope.label.ref.inner_index]
			if symbol.slot_namespace() != ast.slot_must_not_be_renamed {
				char_freq.scan(symbol.original_name, -i32(symbol.use_count_estimate) - 1)
			}
		}
		for _, child in scope.children {
			visit(child)
		}
	}

	visit(p.module_scope)
	for _, ref in p.mangled_props {
		mut symbol_2 := &p.symbols[ref.inner_index]
		char_freq.scan(symbol.original_name, -i32(symbol.use_count_estimate))
	}
	return char_freq
}

fn (p &Parser) generate_import_stmt(path string, path_range logger.Range, imports []string, parts []js_ast.Part, symbols map[string]ast.LocRef, source_index &Uint32, copy_source_index &Uint32) ([]js_ast.Part, u32) {
	if path_range.len == 0 {
		mut is_first := true
		for _, it in symbols {
			if is_first || it.loc.start < path_range.loc.start {
				path_range.loc = it.loc
			}
			is_first = false
		}
	}
	mut namespace_ref := p.new_symbol(ast.symbol_other, 'import_' +
		js_ast.generate_non_unique_name_from_path(path))
	p.module_scope.generated << namespace_ref
	mut declared_symbols := []js_ast.DeclaredSymbol{len: 1 + imports.len}
	mut clause_items := []js_ast.ClauseItem{len: imports.len}
	mut import_record_index := p.add_import_record(ast.import_stmt, path_range, path,
		nil, 0)
	if source_index != nil {
		p.import_records[import_record_index].source_index = ast.make_index32(&source_index)
	}
	if copy_source_index != nil {
		p.import_records[import_record_index].copy_source_index = ast.make_index32(&copy_source_index)
	}
	declared_symbols[0] = js_ast.DeclaredSymbol{
		ref:          namespace_ref
		is_top_level: true
	}
	for i, alias in imports {
		mut it_1 := symbols[alias]
		declared_symbols[i + 1] = js_ast.DeclaredSymbol{
			ref:          it.ref
			is_top_level: true
		}
		clause_items[i] = js_ast.ClauseItem{
			alias:     alias
			alias_loc: it.loc
			name:      ast.LocRef{
				loc: it.loc
				ref: it.ref
			}
		}
		p.is_import_item[it.ref] = true
		p.named_imports[it.ref] = js_ast.NamedImport{
			alias:               alias
			alias_loc:           it.loc
			namespace_ref:       namespace_ref
			import_record_index: import_record_index
		}
	}
	return append(parts, js_ast.Part{
		declared_symbols:      declared_symbols
		import_record_indices: [u32(import_record_index)]
		stmts:                 [// UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
		]
	}), import_record_index
}

// Sort the keys for determinism
fn sorted_keys_of_map_string_loc_ref(in_ map[string]ast.LocRef) []string {
	mut keys := []string{len: 0, cap: in_.len}
	for key, _ in in_ {
		keys << key
	}
	sort.strings(keys)
	return keys
}

fn (p &Parser) to_ast(before []js_ast.Part, parts []js_ast.Part, after []js_ast.Part, hashbang string, directives []string) js_ast.AST {
	if p.runtime_imports.len > 0 && !p.options.omit_runtime_for_tests {
		mut keys := sorted_keys_of_map_string_loc_ref(p.runtime_imports)
		mut source_index := runtime.source_index
		before, _ = p.generate_import_stmt('<runtime>', logger.Range{}, keys, before,
			p.runtime_imports, &source_index, nil)
	}
	if p.jsx_runtime_imports.len > 0 && !p.options.omit_jsxr_untime_for_tests {
		mut keys_1 := sorted_keys_of_map_string_loc_ref(p.jsx_runtime_imports)
		mut path := p.options.jsx.import_source
		if p.options.jsx.development {
			path = path + '/jsx-dev-runtime'
		} else {
			path = path + '/jsx-runtime'
		}
		before, _ = p.generate_import_stmt(path, logger.Range{}, keys, before, p.jsx_runtime_imports,
			nil, nil)
	}
	if p.jsx_legacy_imports.len > 0 && !p.options.omit_jsxr_untime_for_tests {
		mut keys_2 := sorted_keys_of_map_string_loc_ref(p.jsx_legacy_imports)
		mut path_1 := p.options.jsx.import_source
		before, _ = p.generate_import_stmt(path, logger.Range{}, keys, before, p.jsx_legacy_imports,
			nil, nil)
	}
	for _, glob in p.glob_pattern_imports {
		mut symbols := {
			glob.name: // UNHANDLED CompositeLit type  InvalidExpr strtyp="Expr(InvalidExpr{})"
		}
		mut importRecordIndex := 0
		before, import_record_index = p.generate_import_stmt(helpers.glob_pattern_to_string(glob.parts),
			glob.approximate_range, [glob.name], before, symbols, nil, nil)
		mut record := &p.import_records[import_record_index]
		record.assert_or_with = glob.assert_or_with
		record.glob_pattern = &ast.GlobPattern{
			parts:        glob.parts
			export_alias: glob.name
			kind:         glob.kind
		}
	}
	if before.len > 0 {
		parts << parts
	}
	parts << after
	mut kept_import_equals := false
	mut removed_import_equals := false
	mut parts_end := isize(0)
	for part_index, part in parts {
		p.import_records_for_current_part = nil
		p.declared_symbols = nil
		mut result := p.scan_for_imports_and_exports(part.stmts)
		part.stmts = result.stmts
		kept_import_equals = kept_import_equals || result.kept_import_equals
		removed_import_equals = removed_import_equals || result.removed_import_equals
		part.import_record_indices << p.import_records_for_current_part
		part.declared_symbols << p.declared_symbols
		if part.stmts.len > 0 || u32(part_index) == js_ast.nse_xport_part_index {
			if p.module_scope.contains_direct_eval && part.declared_symbols.len > 0 {
				part.can_be_removed_if_unused = false
			}
			parts[parts_end] = part
			parts_end++
		}
	}
	parts = parts[..parts_end]
	for kept_import_equals && removed_import_equals {
		kept_import_equals = false
		removed_import_equals = false
		mut parts_end_1 := isize(0)
		for part_index_1, part_1 in parts {
			mut result_1 := p.scan_for_unused_tsi_mport_equals(part.stmts)
			part.stmts = result.stmts
			kept_import_equals = kept_import_equals || result.kept_import_equals
			removed_import_equals = removed_import_equals || result.removed_import_equals
			if part.stmts.len > 0 || u32(part_index) == js_ast.nse_xport_part_index {
				parts[parts_end] = part
				parts_end++
			}
		}
		parts = parts[..parts_end]
	}
	for _, part_2 in parts {
		for _, stmt in part.stmts {
			mut s, ok := stmt.data
			if ok {
				for _, item in s.items {
					mut named_import, ok_1 := p.named_imports[item.name.ref]
					if ok {
						named_import.is_exported = true
						p.named_imports[item.name.ref] = named_import
					}
				}
			}
		}
	}
	{
		p.top_level_symbol_to_parts = map[ast.Ref][]u32{}
		for part_index_2, part_3 in parts {
			for _, declared in part.declared_symbols {
				if declared.is_top_level {
					mut ref := declared.ref
					for p.symbols[ref.inner_index].link != ast.invalid_ref {
						ref = p.symbols[ref.inner_index].link
					}
					p.top_level_symbol_to_parts[ref] << u32(part_index)
				}
			}
		}
		p.top_level_symbol_to_parts[p.exports_ref] << js_ast.nse_xport_part_index
	}
	mut wrapper_ref := p.new_symbol(ast.symbol_other, 'require_' + p.source.identifier_name)
	mut nestedScopeSlotCounts := 0
	if p.options.minify_identifiers {
		nested_scope_slot_counts = renamer.assign_nested_scope_slots(p.module_scope, p.symbols)
	}
	mut exports_kind := js_ast.exports_none
	mut uses_exports_ref := p.symbols[p.exports_ref.inner_index].use_count_estimate > 0
	mut uses_module_ref := p.symbols[p.module_ref.inner_index].use_count_estimate > 0
	if p.esm_export_keyword.len > 0 || p.esm_import_meta.len > 0
		|| p.top_level_await_keyword.len > 0 {
		exports_kind = js_ast.exports_esm
	} else if uses_exports_ref || uses_module_ref || p.has_top_level_return {
		exports_kind = js_ast.exports_common_js
	} else {
		if p.options.module_type_data.type.is_common_js() {
			exports_kind = js_ast.exports_common_js
		} else if p.options.module_type_data.type.is_esm() {
			exports_kind = js_ast.exports_esm
		} else {
			if p.esm_import_statement_keyword.len > 0 {
				exports_kind = js_ast.exports_esm
			}
		}
	}
	return js_ast.AST{
		parts:                                 parts
		module_type_data:                      p.options.module_type_data
		module_scope:                          p.module_scope
		char_freq:                             p.compute_character_frequency()
		symbols:                               p.symbols
		exports_ref:                           p.exports_ref
		module_ref:                            p.module_ref
		wrapper_ref:                           wrapper_ref
		hashbang:                              hashbang
		directives:                            directives
		named_imports:                         p.named_imports
		named_exports:                         p.named_exports
		tse_nums:                              p.ts_enums
		const_values:                          p.const_values
		expr_comments:                         p.expr_comments
		nested_scope_slot_counts:              nested_scope_slot_counts
		top_level_symbol_to_parts_from_parser: p.top_level_symbol_to_parts
		export_star_import_records:            p.export_star_import_records
		import_records:                        p.import_records
		approximate_line_count:                i32(p.lexer.approximate_newline_count) + 1
		mangled_props:                         p.mangled_props
		reserved_props:                        p.reserved_props
		manifest_for_yarn_pn_p:                p.manifest_for_yarn_pn_p
		uses_exports_ref:                      uses_exports_ref
		uses_module_ref:                       uses_module_ref
		exports_kind:                          exports_kind
		export_keyword:                        p.esm_export_keyword
		top_level_await_keyword:               p.top_level_await_keyword
		live_top_level_await_keyword:          p.live_top_level_await_keyword
	}
}
